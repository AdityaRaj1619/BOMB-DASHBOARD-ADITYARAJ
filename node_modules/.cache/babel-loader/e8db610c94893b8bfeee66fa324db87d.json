{"ast":null,"code":"// import { Fetcher, Route, Token } from '@uniswap/sdk';\n//import { Fetcher as FetcherSpirit, Token as TokenSpirit } from '@spiritswap/sdk';\nimport { Fetcher, Route, Token } from '@pancakeswap/sdk';\nimport { BigNumber, Contract, ethers } from 'ethers';\nimport { decimalToBalance } from './ether-utils';\nimport ERC20 from './ERC20';\nimport { getFullDisplayBalance, getDisplayBalance } from '../utils/formatBalance';\nimport { getDefaultProvider } from '../utils/provider';\nimport IUniswapV2PairABI from './IUniswapV2Pair.abi.json';\nimport IBombBorrowableABI from './IBombBorrowable.abi.json';\nimport config, { bankDefinitions } from '../config';\nimport moment from 'moment';\nimport { parseUnits } from 'ethers/lib/utils';\nimport { BNB_TICKER, SPOOKY_ROUTER_ADDR, BOMB_TICKER } from '../utils/constants';\nimport { bombMaxi } from '../services/graph';\n\n/**\n * An API module of Bomb Money contracts.\n * All contract-interacting domain logic should be defined in here.\n */\nexport class BombFinance {\n  constructor(cfg) {\n    this.myAccount = void 0;\n    this.provider = void 0;\n    this.signer = void 0;\n    this.config = void 0;\n    this.contracts = void 0;\n    this.externalTokens = void 0;\n    this.boardroomVersionOfUser = void 0;\n    this.BOMBBTCB_LP = void 0;\n    this.BOMB = void 0;\n    this.BUSD = void 0;\n    this.BSHARE = void 0;\n    this.BBOND = void 0;\n    this.XBOMB = void 0;\n    this.BNB = void 0;\n    this.BTC = void 0;\n    this.BOMB_BORROWABLE = void 0;\n    this.BTCB_BORROWABLE = void 0;\n    this.BBOMB_BOMB = void 0;\n    this.BBOMB_BTCB = void 0;\n    this.BBOMBBOMB = void 0;\n    this.BBOMBBTCB = void 0;\n    this.BUSMBUSD_LP = void 0;\n    this.BUSM = void 0;\n    this.BOMB_MAXI = void 0;\n    this.BSHARE_MAXI = void 0;\n    const {\n      deployments,\n      externalTokens\n    } = cfg;\n    const provider = getDefaultProvider();\n\n    // loads contracts from deployments\n    this.contracts = {};\n    for (const [name, deployment] of Object.entries(deployments)) {\n      this.contracts[name] = new Contract(deployment.address, deployment.abi, provider);\n    }\n    this.externalTokens = {};\n    for (const [symbol, [address, decimal]] of Object.entries(externalTokens)) {\n      this.externalTokens[symbol] = new ERC20(address, provider, symbol, decimal);\n    }\n    this.BOMB = new ERC20(deployments.Bomb.address, provider, 'BOMB');\n    this.BSHARE = new ERC20(deployments.BShare.address, provider, 'BSHARE');\n    this.BBOND = new ERC20(deployments.BBond.address, provider, 'BBOND');\n    this.BNB = this.externalTokens['WBNB'];\n    this.BTC = this.externalTokens['BTCB'];\n    this.XBOMB = new ERC20(deployments.xBOMB.address, provider, 'XBOMB');\n    this.BUSM = this.externalTokens['BUSM'];\n    this.BUSD = this.externalTokens['BUSD'];\n\n    // this.BBOMB_BOMB = new ERC20(deployments.BombBorrowable.address, provider, 'bBOMB');\n    // this.BBOMB_BTCB = new ERC20(deployments.BtcbBorrowable.address, provider, 'bBOMB');\n\n    // this.BBOMB_BOMB = new Contract(externalTokens['BBOMB-BOMB'][0], IBombBorrowableABI, provider);\n    // this.BBOMB_BTCB = new Contract(externalTokens['BBOMB-BTCB'][0], IBombBorrowableABI, provider);\n    this.BBOMB_BOMB = new ERC20(deployments.BombBorrowable.address, provider, 'bBOMB');\n    this.BBOMBBOMB = this.externalTokens['BBOMB-BOMB'];\n    this.BBOMBBTCB = this.externalTokens['BBOMB-BTCB'];\n    this.BBOMB_BTCB = new ERC20(deployments.BtcbBorrowable.address, provider, 'bBOMB');\n    this.BOMB_BORROWABLE = new Contract(externalTokens['BBOMB-BOMB'][0], IBombBorrowableABI, provider);\n    this.BTCB_BORROWABLE = new Contract(externalTokens['BBOMB-BTCB'][0], IBombBorrowableABI, provider);\n    this.BOMB_MAXI = new ERC20(deployments.BombMaxiLPBShareRewardPool.address, provider, '80BOMB-20BTCB-LP');\n    this.BSHARE_MAXI = new ERC20(deployments.BshareMaxiLPBShareRewardPool.address, provider, '80BSHARE-20WBNB-LP');\n\n    // Uniswap V2 Pair\n\n    this.BOMBBTCB_LP = new Contract(externalTokens['BOMB-BTCB-LP'][0], IUniswapV2PairABI, provider);\n    this.BUSMBUSD_LP = new Contract(externalTokens['BUSM-BUSD-LP'][0], IUniswapV2PairABI, provider);\n    this.config = cfg;\n    this.provider = provider;\n  }\n\n  /**\n   * @param provider From an unlocked wallet. (e.g. Metamask)\n   * @param account An address of unlocked wallet account.\n   */\n  unlockWallet(provider, account) {\n    const newProvider = new ethers.providers.Web3Provider(provider, this.config.chainId);\n    this.signer = newProvider.getSigner(0);\n    this.myAccount = account;\n    for (const [name, contract] of Object.entries(this.contracts)) {\n      this.contracts[name] = contract.connect(this.signer);\n    }\n    const tokens = [this.BOMB, this.BSHARE, this.BBOND, ...Object.values(this.externalTokens)];\n    for (const token of tokens) {\n      token.connect(this.signer);\n    }\n    this.BOMBBTCB_LP = this.BOMBBTCB_LP.connect(this.signer);\n    console.log(`ðŸ”“ Wallet is unlocked. Welcome, ${account}!`);\n    this.fetchBoardroomVersionOfUser().then(version => this.boardroomVersionOfUser = version).catch(err => {\n      console.error(`Failed to fetch boardroom version: ${err.stack}`);\n      this.boardroomVersionOfUser = 'latest';\n    });\n  }\n  get isUnlocked() {\n    return !!this.myAccount;\n  }\n\n  //===================================================================\n  //===================== GET ASSET STATS =============================\n  //===================FROM APE TO DISPLAY =========================\n  //=========================IN HOME PAGE==============================\n  //===================================================================\n\n  async getBombStat() {\n    const {\n      BombRewardPool,\n      BombGenesisRewardPool\n    } = this.contracts;\n    const supply = await this.BOMB.totalSupply();\n    const bombRewardPoolSupply = await this.BOMB.balanceOf(BombGenesisRewardPool.address);\n    const bombRewardPoolSupply2 = await this.BOMB.balanceOf(BombRewardPool.address);\n    const bombCirculatingSupply = supply.sub(bombRewardPoolSupply).sub(bombRewardPoolSupply2);\n    //  const priceInBNB = await this.getTokenPriceFromPancakeswap(this.BOMB);\n    //const priceInBNBstring = priceInBNB.toString();\n    const priceInBTC = await this.getTokenPriceFromPancakeswapBTC(this.BOMB);\n    // const priceOfOneBNB = await this.getWBNBPriceFromPancakeswap();\n    const priceOfOneBTC = await this.getBTCBPriceFromPancakeswap();\n    //const priceInDollars = await this.getTokenPriceFromPancakeswapBOMBUSD();\n    const priceOfBombInDollars = (Number(priceInBTC) * Number(priceOfOneBTC) / 10000).toFixed(2);\n    //console.log('priceOfBombInDollars', priceOfBombInDollars);\n\n    return {\n      //  tokenInFtm: (Number(priceInBNB) * 100).toString(),\n      tokenInFtm: priceInBTC.toString(),\n      priceInDollars: priceOfBombInDollars,\n      totalSupply: getDisplayBalance(supply, this.BOMB.decimal, 0),\n      circulatingSupply: getDisplayBalance(bombCirculatingSupply, this.BOMB.decimal, 0)\n    };\n  }\n  async getBTCPriceUSD() {\n    const priceOfOneBTC = await this.getBTCBPriceFromPancakeswap();\n    return Number(priceOfOneBTC);\n  }\n\n  /**\n   * Calculates various stats for the requested LP\n   * @param name of the LP token to load stats for\n   * @returns\n   */\n  async getLPStat(name) {\n    // console.log('NAME', name);\n\n    const lpToken = this.externalTokens[name];\n    const lpTokenSupplyBN = await lpToken.totalSupply();\n    const lpTokenSupply = getDisplayBalance(lpTokenSupplyBN, 18);\n    const token0 = name.startsWith('BOMB') ? this.BOMB : this.BSHARE;\n    // console.log('NAME', name);\n\n    const isBomb = name.startsWith('BOMB');\n    const tokenAmountBN = await token0.balanceOf(lpToken.address);\n    const tokenAmount = getDisplayBalance(tokenAmountBN, 18);\n    const ftmAmountBN = await this.BNB.balanceOf(lpToken.address);\n    const ftmAmount = getDisplayBalance(ftmAmountBN, 18);\n    const tokenAmountInOneLP = Number(tokenAmount) / Number(lpTokenSupply);\n    const ftmAmountInOneLP = Number(ftmAmount) / Number(lpTokenSupply);\n    const lpTokenPrice = await this.getLPTokenPrice(lpToken, token0, isBomb);\n    const lpTokenPriceFixed = Number(lpTokenPrice).toFixed(2).toString();\n    const liquidity = (Number(lpTokenSupply) * Number(lpTokenPrice)).toFixed(2).toString();\n    return {\n      tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      ftmAmount: ftmAmountInOneLP.toFixed(2).toString(),\n      priceOfOne: lpTokenPriceFixed,\n      totalLiquidity: liquidity,\n      totalSupply: Number(lpTokenSupply).toFixed(2).toString()\n    };\n  }\n  async getLPStatBTC(name) {\n    const lpToken = this.externalTokens[name];\n    const lpTokenSupplyBN = await lpToken.totalSupply();\n    const lpTokenSupply = getDisplayBalance(lpTokenSupplyBN, 18);\n    const token0 = name.startsWith('BOMB') ? this.BOMB : this.BSHARE;\n    const isBomb = name.startsWith('BOMB');\n    const tokenAmountBN = await token0.balanceOf(lpToken.address);\n    const tokenAmount = getDisplayBalance(tokenAmountBN, 18);\n    const btcAmountBN = await this.BTC.balanceOf(lpToken.address);\n    const btcAmount = getDisplayBalance(btcAmountBN, 18);\n    const tokenAmountInOneLP = Number(tokenAmount) / Number(lpTokenSupply);\n    const ftmAmountInOneLP = Number(btcAmount) / Number(lpTokenSupply);\n    const lpTokenPrice = await this.getLPTokenPrice(lpToken, token0, isBomb);\n    const lpTokenPriceFixed = Number(lpTokenPrice).toFixed(2).toString();\n    const liquidity = (Number(lpTokenSupply) * Number(lpTokenPrice)).toFixed(2).toString();\n    return {\n      tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      ftmAmount: ftmAmountInOneLP.toFixed(5).toString(),\n      priceOfOne: lpTokenPriceFixed,\n      totalLiquidity: liquidity,\n      totalSupply: Number(lpTokenSupply).toFixed(2).toString()\n    };\n  }\n  /**\n   * Use this method to get price for Bomb\n   * @returns TokenStat for BBOND\n   * priceInBNB\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n  async getBondStat() {\n    const {\n      Treasury\n    } = this.contracts;\n    const bombStat = await this.getBombStat();\n    const bondBombRatioBN = await Treasury.getBondPremiumRate();\n    const modifier = bondBombRatioBN / 1e14 > 1 ? bondBombRatioBN / 1e14 : 1;\n    const bondPriceInBNB = (Number(bombStat.tokenInFtm) * modifier).toFixed(4);\n    const priceOfBBondInDollars = (Number(bombStat.priceInDollars) * modifier).toFixed(4);\n    const supply = await this.BBOND.displayedTotalSupply();\n    return {\n      tokenInFtm: bondPriceInBNB,\n      priceInDollars: priceOfBBondInDollars,\n      totalSupply: supply,\n      circulatingSupply: supply\n    };\n  }\n\n  /**\n   * @returns TokenStat for BSHARE\n   * priceInBNB\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n  async getShareStat() {\n    const {\n      BShareRewardPool\n    } = this.contracts;\n    const supply = await this.BSHARE.totalSupply();\n    const priceInBNB = await this.getTokenPriceFromPancakeswap(this.BSHARE);\n    const bombRewardPoolSupply = await this.BSHARE.balanceOf(BShareRewardPool.address);\n    const tShareCirculatingSupply = supply.sub(bombRewardPoolSupply);\n    const priceOfOneBNB = await this.getWBNBPriceFromPancakeswap();\n    const priceOfSharesInDollars = (Number(priceInBNB) * Number(priceOfOneBNB)).toFixed(2);\n    return {\n      tokenInFtm: priceInBNB,\n      priceInDollars: priceOfSharesInDollars,\n      totalSupply: getDisplayBalance(supply, this.BSHARE.decimal, 0),\n      circulatingSupply: getDisplayBalance(tShareCirculatingSupply, this.BSHARE.decimal, 0)\n    };\n  }\n  async getBombStatInEstimatedTWAP() {\n    const {\n      Oracle,\n      BombRewardPool\n    } = this.contracts;\n    const expectedPrice = await Oracle.twap(this.BOMB.address, ethers.utils.parseEther('10000'));\n    const supply = await this.BOMB.totalSupply();\n    const bombRewardPoolSupply = await this.BOMB.balanceOf(BombRewardPool.address);\n    const bombCirculatingSupply = supply.sub(bombRewardPoolSupply);\n    return {\n      tokenInFtm: getDisplayBalance(expectedPrice),\n      priceInDollars: getDisplayBalance(expectedPrice),\n      totalSupply: getDisplayBalance(supply, this.BOMB.decimal, 0),\n      circulatingSupply: getDisplayBalance(bombCirculatingSupply, this.BOMB.decimal, 0)\n    };\n  }\n  async getBombPriceInLastTWAP() {\n    const {\n      Treasury\n    } = this.contracts;\n    return Treasury.getBombUpdatedPrice();\n  }\n\n  // async getBombPegTWAP(): Promise<any> {\n  //   const { Treasury } = this.contracts;\n  //   const updatedPrice = Treasury.getBombUpdatedPrice();\n  //   const updatedPrice2 = updatedPrice * 10000;\n  //   return updatedPrice2;\n  // }\n\n  async getBondsPurchasable() {\n    const {\n      Treasury\n    } = this.contracts;\n    // const burnableBomb = (Number(Treasury.getBurnableBombLeft()) * 1000).toFixed(2).toString();\n    return Treasury.getBurnableBombLeft();\n  }\n  async getBombMaxiStats(poolId) {\n    const BombMaxi = await bombMaxi(poolId);\n    return {\n      totalShares: BombMaxi.data.pool.totalShares.toString(),\n      totalLiquidity: BombMaxi.data.pool.totalLiquidity.toString()\n\n      // tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      // ftmAmount: ftmAmountInOneLP.toFixed(2).toString(),\n      // priceOfOne: lpTokenPriceFixed,\n      // totalLiquidity: liquidity,\n      // totalSupply: Number(lpTokenSupply).toFixed(2).toString(),\n    };\n  }\n\n  /**\n   * Calculates the TVL, APR and daily APR of a provided pool/bank\n   * @param bank\n   * @returns\n   */\n  async getPoolAPRs(bank) {\n    if (this.myAccount === undefined) return;\n    let depositToken = bank.depositToken;\n    // if (depositToken.symbol === '80BOMB-20BTCB-LP' || depositToken.symbol === '80BSHARE-20WBNB-LP') {\n    //   const temp = 'TBD';\n    //   return {\n    //     dailyAPR: temp,\n    //     yearlyAPR: temp,\n    //     TVL: temp,\n    //   };\n    // }\n    const poolContract = this.contracts[bank.contract];\n    let depositTokenValue;\n    if (bank.depositTokenName === \"BBOND\") {\n      depositTokenValue = this.BOMB;\n    } else {\n      depositTokenValue = depositToken;\n    }\n    const depositTokenPrice = await this.getDepositTokenPriceInDollars(bank.depositTokenName, depositTokenValue);\n    const stakeInPool = await depositToken.balanceOf(bank.address);\n    const TVL = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const stat = bank.earnTokenName === 'BOMB' ? await this.getBombStat() : await this.getShareStat();\n    const tokenPerSecond = await this.getTokenPerSecond(bank.earnTokenName, bank.contract, poolContract, bank.depositTokenName);\n    const tokenPerHour = tokenPerSecond.mul(60).mul(60);\n    const totalRewardPricePerYear = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24).mul(365)));\n    const totalRewardPricePerDay = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24)));\n    const totalStakingTokenInPool = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const dailyAPR = totalRewardPricePerDay / totalStakingTokenInPool * 100;\n    const yearlyAPR = totalRewardPricePerYear / totalStakingTokenInPool * 100;\n    return {\n      dailyAPR: dailyAPR.toFixed(2).toString(),\n      yearlyAPR: yearlyAPR.toFixed(2).toString(),\n      TVL: TVL.toFixed(2).toString()\n    };\n  }\n  async getXbombAPR() {\n    if (this.myAccount === undefined) return;\n    const bombToken = this.BOMB;\n    const xbombToken = this.XBOMB;\n    const xbombExchange = await this.getXbombExchange();\n    const xbombPercent = await xbombExchange;\n    const xbombPercentTotal = Number(xbombPercent) / 1000000000000000000 * 100 - 100;\n    const depositTokenPrice = await this.getDepositTokenPriceInDollars(bombToken.symbol, bombToken);\n    const stakeInPool = await bombToken.balanceOf(xbombToken.address);\n    const TVL = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, bombToken.decimal));\n    const startDate = new Date('January 24, 2022');\n    const nowDate = new Date(Date.now());\n    const difference = nowDate.getTime() - startDate.getTime();\n    const days = difference / 60 / 60 / 24 / 1000;\n    const aprPerDay = xbombPercentTotal / days;\n\n    // Determine days between now and a date\n\n    // const tokenPerHour = tokenPerSecond.mul(60).mul(60);\n    // const totalRewardPricePerYear =\n    //   Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24).mul(365)));\n    // const totalRewardPricePerDay = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24)));\n    // const totalStakingTokenInPool =\n    //   Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    // const dailyAPR = (totalRewardPricePerDay / totalStakingTokenInPool) * 100;\n    // const yearlyAPR = (totalRewardPricePerYear / totalStakingTokenInPool) * 100;\n\n    const dailyAPR = aprPerDay;\n    const yearlyAPR = aprPerDay * 365;\n    return {\n      dailyAPR: dailyAPR.toFixed(2).toString(),\n      yearlyAPR: yearlyAPR.toFixed(2).toString(),\n      TVL: TVL.toFixed(2).toString()\n    };\n  }\n\n  /**\n   * Method to return the amount of tokens the pool yields per second\n   * @param earnTokenName the name of the token that the pool is earning\n   * @param contractName the contract of the pool/bank\n   * @param poolContract the actual contract of the pool\n   * @returns\n   */\n  async getTokenPerSecond(earnTokenName, contractName, poolContract, depositTokenName) {\n    if (earnTokenName === 'BOMB') {\n      if (!contractName.endsWith('BombRewardPool')) {\n        const rewardPerSecond = await poolContract.tSharePerSecond();\n        if (depositTokenName === 'WBNB') {\n          return rewardPerSecond.mul(6000).div(11000).div(24);\n        } else if (depositTokenName === 'CAKE') {\n          return rewardPerSecond.mul(2500).div(11000).div(24);\n        } else if (depositTokenName === 'SUSD') {\n          return rewardPerSecond.mul(1000).div(11000).div(24);\n        } else if (depositTokenName === 'SVL') {\n          return rewardPerSecond.mul(1500).div(11000).div(24);\n        }\n        return rewardPerSecond.div(24);\n      }\n      const poolStartTime = await poolContract.poolStartTime();\n      const startDateTime = new Date(poolStartTime.toNumber() * 1000);\n      const FOUR_DAYS = 4 * 24 * 60 * 60 * 1000;\n      if (Date.now() - startDateTime.getTime() > FOUR_DAYS) {\n        return await poolContract.epochBombPerSecond(1);\n      }\n      return await poolContract.epochBombPerSecond(0);\n    }\n    const rewardPerSecond = await poolContract.tSharePerSecond();\n    if (depositTokenName.startsWith('BOMB-BTCB')) {\n      return rewardPerSecond.mul(400).div(1000);\n    } else if (depositTokenName.startsWith('BOMB-BSHARE')) {\n      return rewardPerSecond.mul(0).div(1000);\n    } else if (depositTokenName.startsWith('BOMB')) {\n      return rewardPerSecond.mul(0).div(1000);\n    } else if (depositTokenName.startsWith('BBOND')) {\n      return rewardPerSecond.mul(150).div(1000);\n    } else if (depositTokenName.startsWith('BUSM-BUSD')) {\n      return rewardPerSecond.mul(50).div(1000);\n    } else if (depositTokenName.startsWith('80BOMB')) {\n      return rewardPerSecond.mul(200).div(1000);\n    } else if (depositTokenName.startsWith('80BSHARE')) {\n      return rewardPerSecond.mul(50).div(1000);\n    } else {\n      return rewardPerSecond.mul(150).div(1000);\n    }\n    // if (depositTokenName.startsWith('BOMB-BTCB')) {\n    //   return rewardPerSecond.mul(41650).div(10000);\n    // } else if (depositTokenName.startsWith('BOMB-BSHARE')) {\n    //   return rewardPerSecond.mul(0).div(119000);\n    // } else if (depositTokenName.startsWith('BOMB')) {\n    //   return rewardPerSecond.mul(59500).div(10000);\n    // } else {\n    //   return rewardPerSecond.mul(17850).div(10000);\n    // }\n  }\n\n  /**\n   * Method to calculate the tokenPrice of the deposited asset in a pool/bank\n   * If the deposited token is an LP it will find the price of its pieces\n   * @param tokenName\n   * @param pool\n   * @param token\n   * @returns\n   */\n  async getDepositTokenPriceInDollars(tokenName, token) {\n    let tokenPrice;\n    const priceOfOneFtmInDollars = await this.getWBNBPriceFromPancakeswap();\n    if (tokenName === 'WBNB') {\n      tokenPrice = priceOfOneFtmInDollars;\n    } else {\n      if (tokenName === 'BOMB-BTCB-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BOMB, true);\n      } else if (tokenName === 'BSHARE-BNB-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BSHARE, false);\n      } else if (tokenName === 'BOMB-BSHARE-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BOMB, true);\n        // } else if (tokenName === 'BSHARE-BNB-APELP') {\n        //   tokenPrice = await this.getLPTokenPrice(token, this.BSHARE, false);\n      } else if (tokenName === 'BUSM-BUSD-LP') {\n        tokenPrice = await this.getBusdLPTokenPrice(token, this.BUSM, true);\n      } else if (tokenName === '80BOMB-20BTCB-LP') {\n        tokenPrice = await this.getMaxiLPTokenPrice('0xd6f52e8ab206e59a1e13b3d6c5b7f31e90ef46ef000200000000000000000028');\n      } else if (tokenName === '80BSHARE-20WBNB-LP') {\n        tokenPrice = await this.getMaxiLPTokenPrice('0x2c374ed1575e5c2c02c569f627299e902a1972cb000200000000000000000027');\n      } else if (tokenName === 'BBOND') {\n        tokenPrice = await this.getTokenPriceFromPancakeswap(this.BOMB);\n        tokenPrice = (Number(tokenPrice) * Number(priceOfOneFtmInDollars)).toString();\n      } else {\n        tokenPrice = await this.getTokenPriceFromPancakeswap(token);\n        tokenPrice = (Number(tokenPrice) * Number(priceOfOneFtmInDollars)).toString();\n      }\n    }\n    //console.log({ tokenPrice });\n    return tokenPrice;\n  }\n\n  //===================================================================\n  //===================== GET ASSET STATS =============================\n  //=========================== END ===================================\n  //===================================================================\n\n  async getCurrentEpoch() {\n    const {\n      Treasury\n    } = this.contracts;\n    return Treasury.epoch();\n  }\n  async getBondOraclePriceInLastTWAP() {\n    const {\n      Treasury\n    } = this.contracts;\n    return Treasury.getBondPremiumRate();\n  }\n\n  /**\n   * Buy bonds with cash.\n   * @param amount amount of cash to purchase bonds with.\n   */\n  async buyBonds(amount) {\n    const {\n      Treasury\n    } = this.contracts;\n    const treasuryBombPrice = await Treasury.getBombPrice();\n    return await Treasury.buyBonds(decimalToBalance(amount), treasuryBombPrice);\n  }\n\n  /**\n   * Redeem bonds for cash.\n   * @param amount amount of bonds to redeem.\n   */\n  async redeemBonds(amount) {\n    const {\n      Treasury\n    } = this.contracts;\n    const priceForBomb = await Treasury.getBombPrice();\n    return await Treasury.redeemBonds(decimalToBalance(amount), priceForBomb);\n  }\n  async getTotalValueLocked() {\n    let totalValue = 0;\n    for (const bankInfo of Object.values(bankDefinitions)) {\n      const pool = this.contracts[bankInfo.contract];\n      const token = this.externalTokens[bankInfo.depositTokenName];\n      const tokenPrice = await this.getDepositTokenPriceInDollars(bankInfo.depositTokenName, token);\n      const tokenAmountInPool = await token.balanceOf(pool.address);\n      const value = Number(getDisplayBalance(tokenAmountInPool, token.decimal)) * Number(tokenPrice);\n      const poolValue = Number.isNaN(value) ? 0 : value;\n      totalValue += poolValue;\n    }\n    const BSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n    const boardroomtShareBalanceOf = await this.BSHARE.balanceOf(this.currentBoardroom().address);\n    const bombStakeBalanceOf = await this.BOMB.balanceOf(this.XBOMB.address);\n    const boardroomTVL = Number(getDisplayBalance(boardroomtShareBalanceOf, this.BSHARE.decimal)) * Number(BSHAREPrice);\n    const bombTVL = Number(getDisplayBalance(bombStakeBalanceOf, this.BOMB.decimal)) * Number(BOMBPrice);\n    return totalValue + boardroomTVL + bombTVL;\n  }\n\n  /**\n   * Calculates the price of an LP token\n   * Reference https://github.com/DefiDebauchery/discordpricebot/blob/4da3cdb57016df108ad2d0bb0c91cd8dd5f9d834/pricebot/pricebot.py#L150\n   * @param lpToken the token under calculation\n   * @param token the token pair used as reference (the other one would be BNB in most cases)\n   * @param isBomb sanity check for usage of bomb token or tShare\n   * @returns price of the LP token\n   */\n  async getLPTokenPrice(lpToken, token, isBomb) {\n    const totalSupply = getFullDisplayBalance(await lpToken.totalSupply(), lpToken.decimal);\n    //Get amount of tokenA\n    const tokenSupply = getFullDisplayBalance(await token.balanceOf(lpToken.address), token.decimal);\n    const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n    const priceOfToken = stat.priceInDollars;\n    const tokenInLP = Number(tokenSupply) / Number(totalSupply);\n    const tokenPrice = (Number(priceOfToken) * tokenInLP * 2 //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n    ).toString();\n    return tokenPrice;\n  }\n\n  /**\n   * Calculates the price of an LP token\n   * Reference https://github.com/DefiDebauchery/discordpricebot/blob/4da3cdb57016df108ad2d0bb0c91cd8dd5f9d834/pricebot/pricebot.py#L150\n   * @param lpToken the token under calculation\n   * @param token the token pair used as reference (the other one would be BNB in most cases)\n   * @param isBomb sanity check for usage of bomb token or tShare\n   * @returns price of the LP token\n   */\n  async getBusdLPTokenPrice(lpToken, token, isBomb) {\n    const totalSupply = getFullDisplayBalance(await lpToken.totalSupply(), lpToken.decimal);\n    //Get amount of tokenA\n    const tokenSupply = getFullDisplayBalance(await token.balanceOf(lpToken.address), token.decimal);\n    // const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n    const priceToken = await this.getTokenPriceFromPancakeswapBUSD(this.BUSM);\n    const priceOfToken = Number(priceToken);\n    const tokenInLP = Number(tokenSupply) / Number(totalSupply);\n    const tokenPrice = (Number(priceOfToken) * tokenInLP * 2 //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n    ).toString();\n    return tokenPrice;\n  }\n  async getMaxiLPTokenPrice(maxiPool) {\n    const bombmaxi = await this.getBombMaxiStats(maxiPool);\n    const totalShares = await bombmaxi.totalShares;\n    //Get amount of tokenA\n    const totalLiquidity = await bombmaxi.totalLiquidity;\n    // const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n\n    const tokenInLP = Number(totalLiquidity) / Number(totalShares);\n    const tokenPrice = tokenInLP //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n    .toString();\n    return tokenPrice;\n  }\n  async earnedFromBank(poolName, earnTokenName, poolId) {\n    let account = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.myAccount;\n    const pool = this.contracts[poolName];\n    try {\n      if (earnTokenName === 'BOMB') {\n        return await pool.pendingBOMB(poolId, account);\n      } else {\n        return await pool.pendingShare(poolId, account);\n      }\n    } catch (err) {\n      console.error(`Failed to call pendingShare() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n  async stakedBalanceOnBank(poolName, poolId) {\n    let account = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.myAccount;\n    const pool = this.contracts[poolName];\n    try {\n      let userInfo = await pool.userInfo(poolId, account);\n      return await userInfo.amount;\n    } catch (err) {\n      console.error(`Failed to call userInfo() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n\n  /**\n   * Deposits token to given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n  async stake(poolName, poolId, amount) {\n    const pool = this.contracts[poolName];\n    return await pool.deposit(poolId, amount);\n  }\n\n  /**\n   * Withdraws token from given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n  async unstake(poolName, poolId, amount) {\n    const pool = this.contracts[poolName];\n    return await pool.withdraw(poolId, amount);\n  }\n\n  /**\n   * Transfers earned token reward from given pool to my account.\n   */\n  async harvest(poolName, poolId) {\n    const pool = this.contracts[poolName];\n    //By passing 0 as the amount, we are asking the contract to only redeem the reward and not the currently staked token\n    return await pool.withdraw(poolId, 0);\n  }\n\n  /**\n   * Harvests and withdraws deposited tokens from the pool.\n   */\n  async exit(poolName, poolId) {\n    let account = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.myAccount;\n    const pool = this.contracts[poolName];\n    let userInfo = await pool.userInfo(poolId, account);\n    return await pool.withdraw(poolId, userInfo.amount);\n  }\n  async fetchBoardroomVersionOfUser() {\n    return 'latest';\n  }\n  currentBoardroom() {\n    if (!this.boardroomVersionOfUser) {\n      //throw new Error('you must unlock the wallet to continue.');\n    }\n    return this.contracts.Boardroom;\n  }\n  isOldBoardroomMember() {\n    return this.boardroomVersionOfUser !== 'latest';\n  }\n  async getTokenPriceFromPancakeswap(tokenContract) {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    const {\n      WBNB\n    } = this.config.externalTokens;\n    const wftm = new Token(56, WBNB[0], WBNB[1], 'WBNB');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(wftm, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      return priceInBUSD.midPrice.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n  async getTokenPriceFromPancakeswapBUSD(tokenContract) {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    const {\n      BUSD\n    } = this.config.externalTokens;\n    const wftm = new Token(56, BUSD[0], BUSD[1], 'BUSD');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(wftm, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      return priceInBUSD.midPrice.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n  async getTokenPriceFromPancakeswapBTC(tokenContract) {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    // const {WBNB} = this.config.externalTokens;\n\n    // const wbnb = new Token(56, WBNB[0], WBNB[1]);\n    const btcb = new Token(56, this.BTC.address, this.BTC.decimal, 'BTCB', 'BTCB');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(btcb, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      //   console.log('priceInBUSDBTC', priceInBUSD.midPrice.toFixed(12));\n\n      const priceForPeg = Number(priceInBUSD.midPrice.toFixed(12)) * 10000;\n      return priceForPeg.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n  async getTokenPriceFromPancakeswapBOMBUSD() {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    //const {WBNB} = this.config.externalTokens;\n\n    //  const wbnb = new Token(56, WBNB[0], WBNB[1]);\n    const btcb = new Token(56, this.BTC.address, this.BTC.decimal, 'BTCB', 'BTCB');\n    const token = new Token(56, this.BOMB.address, this.BOMB.decimal, this.BOMB.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(btcb, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      // console.log('test', priceInBUSD.midPrice.toFixed(12));\n\n      const priceForPeg = Number(priceInBUSD.midPrice.toFixed(12)) * 10000;\n      return priceForPeg.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${this.BOMB.symbol}: ${err}`);\n    }\n  }\n\n  // async getTokenPriceFromSpiritswap(tokenContract: ERC20): Promise<string> {\n  //   const ready = await this.provider.ready;\n  //   if (!ready) return;\n  //   const { chainId } = this.config;\n\n  //   const { WBNB } = this.externalTokens;\n\n  //   const wftm = new TokenSpirit(chainId, WBNB.address, WBNB.decimal);\n  //   const token = new TokenSpirit(chainId, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n  //   try {\n  //     const wftmToToken = await FetcherSpirit.fetchPairData(wftm, token, this.provider);\n  //     const liquidityToken = wftmToToken.liquidityToken;\n  //     let ftmBalanceInLP = await WBNB.balanceOf(liquidityToken.address);\n  //     let ftmAmount = Number(getFullDisplayBalance(ftmBalanceInLP, WBNB.decimal));\n  //     let shibaBalanceInLP = await tokenContract.balanceOf(liquidityToken.address);\n  //     let shibaAmount = Number(getFullDisplayBalance(shibaBalanceInLP, tokenContract.decimal));\n  //     const priceOfOneFtmInDollars = await this.getWBNBPriceFromPancakeswap();\n  //     let priceOfShiba = (ftmAmount / shibaAmount) * Number(priceOfOneFtmInDollars);\n  //     return priceOfShiba.toString();\n  //   } catch (err) {\n  //     console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n  //   }\n  // }\n\n  async getWBNBPriceFromPancakeswap() {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const {\n      WBNB,\n      FUSDT\n    } = this.externalTokens;\n    try {\n      const fusdt_wftm_lp_pair = this.externalTokens['USDT-BNB-LP'];\n      let ftm_amount_BN = await WBNB.balanceOf(fusdt_wftm_lp_pair.address);\n      let ftm_amount = Number(getFullDisplayBalance(ftm_amount_BN, WBNB.decimal));\n      let fusdt_amount_BN = await FUSDT.balanceOf(fusdt_wftm_lp_pair.address);\n      let fusdt_amount = Number(getFullDisplayBalance(fusdt_amount_BN, FUSDT.decimal));\n      return (fusdt_amount / ftm_amount).toString();\n    } catch (err) {\n      console.error(`Failed to fetch token price of WBNB: ${err}`);\n    }\n  }\n  async getBTCBPriceFromPancakeswap() {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const {\n      BTCB\n    } = this.externalTokens;\n    try {\n      const btcPriceInBNB = await this.getTokenPriceFromPancakeswap(BTCB);\n      const wbnbPrice = await this.getWBNBPriceFromPancakeswap();\n      const btcprice = (Number(btcPriceInBNB) * Number(wbnbPrice)).toFixed(2).toString();\n      //console.log('btcprice', btcprice);\n      return btcprice;\n    } catch (err) {\n      console.error(`Failed to fetch token price of BTCB: ${err}`);\n    }\n  }\n\n  // async getBTCBPriceFromPancakeswap(): Promise<string> {\n  //   const ready = await this.provider.ready;\n  //   if (!ready) return;\n  //   const { BTCB, FUSDT } = this.externalTokens;\n  //   try {\n  //     const fusdt_btcb_lp_pair = this.externalTokens['USDT-BTCB-LP'];\n  //     let ftm_amount_BN = await BTCB.balanceOf(fusdt_btcb_lp_pair.address);\n  //     let ftm_amount = Number(getFullDisplayBalance(ftm_amount_BN, BTCB.decimal));\n  //     let fusdt_amount_BN = await FUSDT.balanceOf(fusdt_btcb_lp_pair.address);\n  //     let fusdt_amount = Number(getFullDisplayBalance(fusdt_amount_BN, FUSDT.decimal));\n  //     console.log('BTCB price', (fusdt_amount / ftm_amount).toString());\n  //     return (fusdt_amount / ftm_amount).toString();\n  //     console.log('BTCB price');\n  //   } catch (err) {\n  //     console.error(`Failed to fetch token price of BTCB: ${err}`);\n  //   }\n  // }\n\n  //===================================================================\n  //===================================================================\n  //===================== MASONRY METHODS =============================\n  //===================================================================\n  //===================================================================\n\n  async getBoardroomAPR() {\n    const Boardroom = this.currentBoardroom();\n    const latestSnapshotIndex = await Boardroom.latestSnapshotIndex();\n    const lastHistory = await Boardroom.boardroomHistory(latestSnapshotIndex);\n    const lastRewardsReceived = lastHistory[1];\n    const BSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n    const epochRewardsPerShare = lastRewardsReceived / 1e18;\n\n    //Mgod formula\n    const amountOfRewardsPerDay = epochRewardsPerShare * Number(BOMBPrice) * 4;\n    const boardroomtShareBalanceOf = await this.BSHARE.balanceOf(Boardroom.address);\n    const boardroomTVL = Number(getDisplayBalance(boardroomtShareBalanceOf, this.BSHARE.decimal)) * Number(BSHAREPrice);\n    const realAPR = amountOfRewardsPerDay * 100 / boardroomTVL * 365;\n    return realAPR;\n  }\n  async getBombStakeAPR() {\n    const Boardroom = this.currentBoardroom();\n    const latestSnapshotIndex = await Boardroom.latestSnapshotIndex();\n    const lastHistory = await Boardroom.boardroomHistory(latestSnapshotIndex);\n    const lastRewardsReceived = lastHistory[1];\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n    const epochRewardsPerShare = lastRewardsReceived / 1e18;\n\n    //Mgod formula\n    const amountOfRewardsPerDay = epochRewardsPerShare * Number(BOMBPrice) * 4;\n    const xBombBombBalanceOf = await this.BOMB.balanceOf(this.XBOMB.address);\n    const bombTVL = Number(getDisplayBalance(xBombBombBalanceOf, this.XBOMB.decimal)) * Number(BOMBPrice);\n    const realAPR = amountOfRewardsPerDay * 100 * 0.2 / bombTVL * 365;\n    return realAPR;\n  }\n\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Boardroom\n   * @returns true if user can withdraw reward, false if they can't\n   */\n  async canUserClaimRewardFromBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.canClaimReward(this.myAccount);\n  }\n\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Boardroom\n   * @returns true if user can withdraw reward, false if they can't\n   */\n  async canUserUnstakeFromBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    const canWithdraw = await Boardroom.canWithdraw(this.myAccount);\n    const stakedAmount = await this.getStakedSharesOnBoardroom();\n    const notStaked = Number(getDisplayBalance(stakedAmount, this.BSHARE.decimal)) === 0;\n    const result = notStaked ? true : canWithdraw;\n    return result;\n  }\n  async timeUntilClaimRewardFromBoardroom() {\n    // const Boardroom = this.currentBoardroom();\n    // const mason = await Boardroom.masons(this.myAccount);\n    return BigNumber.from(0);\n  }\n  async getTotalStakedInBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.totalSupply();\n  }\n  async stakeShareToBoardroom(amount) {\n    if (this.isOldBoardroomMember()) {\n      throw new Error(\"you're using old boardroom. please withdraw and deposit the BSHARE again.\");\n    }\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.stake(decimalToBalance(amount));\n  }\n  async stakeToBomb(amount) {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.enter(decimalToBalance(amount));\n  }\n  async redeemFromBomb(amount) {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.redeem(this.BBOMB_BOMB.address, decimalToBalance(amount), this.myAccount, expiry.getTime(), '0x');\n  }\n  async redeemFromBtcb(amount) {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.redeem(this.BBOMB_BTCB.address, decimalToBalance(amount), this.myAccount, expiry.getTime(), '0x');\n  }\n  async supplyToBtcb(amount) {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.mint(this.BBOMB_BTCB.address, decimalToBalance(amount), this.myAccount, expiry.getTime());\n  }\n  async supplyToBomb(amount) {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.mint(this.BBOMB_BOMB.address, decimalToBalance(amount), this.myAccount, expiry.getTime());\n  }\n  async getStakedSharesOnBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.getShareOf(this.myAccount);\n    }\n    return await Boardroom.balanceOf(this.myAccount);\n  }\n  async getStakedBomb() {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.balanceOf(this.myAccount);\n  }\n  async getTotalStakedBomb() {\n    const Xbomb = this.contracts.xBOMB;\n    const bomb = this.BOMB;\n    return await bomb.balanceOf(Xbomb.address);\n  }\n  async getTotalSuppliedBomb() {\n    const bbombBomb = this.BOMB_BORROWABLE;\n    // const bomb = this.BOMB;\n    const totalBomb = await bbombBomb.totalBalance();\n    //  const borrowBomb = await bbombBomb.totalBorrows();\n    // const totalSupplied = totalBomb + borrowBomb;\n    return totalBomb;\n  }\n  async getTotalSuppliedBtcb() {\n    const bbombBomb = this.BTCB_BORROWABLE;\n    // const bomb = this.BOMB;\n    const totalBtcb = await bbombBomb.totalBalance();\n    //const borrowBtcb = await bbombBomb.totalBorrows();\n    //  const totalSupplied = totalBtcb + borrowBtcb;\n    return totalBtcb;\n  }\n  async getXbombExchange() {\n    const Xbomb = this.contracts.xBOMB;\n    const XbombExchange = await Xbomb.getExchangeRate();\n    const xBombPerBomb = parseFloat(XbombExchange) / 1000000000000000000;\n    const xBombRate = xBombPerBomb.toString();\n    return parseUnits(xBombRate, 18);\n  }\n  async withdrawFromBomb(amount) {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.leave(decimalToBalance(amount));\n  }\n  async getEarningsOnBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.getCashEarningsOf(this.myAccount);\n    }\n    return await Boardroom.earned(this.myAccount);\n  }\n  async withdrawShareFromBoardroom(amount) {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.withdraw(decimalToBalance(amount));\n  }\n  async harvestCashFromBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.claimDividends();\n    }\n    return await Boardroom.claimReward();\n  }\n  async exitFromBoardroom() {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.exit();\n  }\n  async getTreasuryNextAllocationTime() {\n    const {\n      Treasury\n    } = this.contracts;\n    const nextEpochTimestamp = await Treasury.nextEpochPoint();\n    const nextAllocation = new Date(nextEpochTimestamp.mul(1000).toNumber());\n    const prevAllocation = new Date(Date.now());\n    return {\n      from: prevAllocation,\n      to: nextAllocation\n    };\n  }\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to claim\n   * their reward from the boardroom\n   * @returns Promise<AllocationTime>\n   */\n  async getUserClaimRewardTime() {\n    const {\n      Boardroom,\n      Treasury\n    } = this.contracts;\n    const nextEpochTimestamp = await Boardroom.nextEpochPoint(); //in unix timestamp\n    const currentEpoch = await Boardroom.epoch();\n    const mason = await Boardroom.members(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const periodInHours = period / 60 / 60; // 6 hours, period is displayed in seconds which is 21600\n    const rewardLockupEpochs = await Boardroom.rewardLockupEpochs();\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(rewardLockupEpochs);\n    const fromDate = new Date(Date.now());\n    if (targetEpochForClaimUnlock - currentEpoch <= 0) {\n      return {\n        from: fromDate,\n        to: fromDate\n      };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return {\n        from: fromDate,\n        to: toDate\n      };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - currentEpoch - 1;\n      const endDate = moment(toDate).add(delta * periodInHours, 'hours').toDate();\n      return {\n        from: fromDate,\n        to: endDate\n      };\n    }\n  }\n\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to unstake\n   * from the boardroom\n   * @returns Promise<AllocationTime>\n   */\n  async getUserUnstakeTime() {\n    const {\n      Boardroom,\n      Treasury\n    } = this.contracts;\n    const nextEpochTimestamp = await Boardroom.nextEpochPoint();\n    const currentEpoch = await Boardroom.epoch();\n    const mason = await Boardroom.members(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const PeriodInHours = period / 60 / 60;\n    const withdrawLockupEpochs = await Boardroom.withdrawLockupEpochs();\n    const fromDate = new Date(Date.now());\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(withdrawLockupEpochs);\n    const stakedAmount = await this.getStakedSharesOnBoardroom();\n    if (currentEpoch <= targetEpochForClaimUnlock && Number(stakedAmount) === 0) {\n      return {\n        from: fromDate,\n        to: fromDate\n      };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return {\n        from: fromDate,\n        to: toDate\n      };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - Number(currentEpoch) - 1;\n      const endDate = moment(toDate).add(delta * PeriodInHours, 'hours').toDate();\n      return {\n        from: fromDate,\n        to: endDate\n      };\n    }\n  }\n  async watchAssetInMetamask(assetName) {\n    const {\n      ethereum\n    } = window;\n    if (ethereum && ethereum.networkVersion === config.chainId.toString()) {\n      let asset;\n      let assetUrl;\n      if (assetName === 'BOMB') {\n        asset = this.BOMB;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bomb-512.png';\n      } else if (assetName === 'BSHARE') {\n        asset = this.BSHARE;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bshare-512.png';\n      } else if (assetName === 'BBOND') {\n        asset = this.BBOND;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bbond-512.png';\n      } else if (assetName === 'XBOMB') {\n        asset = this.XBOMB;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/xbomb-512.png';\n      } else if (assetName === 'BTCB') {\n        asset = this.BTC;\n        assetUrl = 'https://bscscan.com/token/images/btcb_32.png';\n      }\n      await ethereum.request({\n        method: 'wallet_watchAsset',\n        params: {\n          type: 'ERC20',\n          options: {\n            address: asset.address,\n            symbol: asset.symbol,\n            decimals: 18,\n            image: assetUrl\n          }\n        }\n      });\n    }\n    return true;\n  }\n  async provideBombFtmLP(ftmAmount, bombAmount) {\n    const {\n      TaxOffice\n    } = this.contracts;\n    let overrides = {\n      value: parseUnits(ftmAmount, 18)\n    };\n    return await TaxOffice.addLiquidityETHTaxFree(bombAmount, bombAmount.mul(992).div(1000), parseUnits(ftmAmount, 18).mul(992).div(1000), overrides);\n  }\n  async quoteFromSpooky(tokenAmount, tokenName) {\n    const {\n      SpookyRouter\n    } = this.contracts;\n    const {\n      _reserve0,\n      _reserve1\n    } = await this.BOMBBTCB_LP.getReserves();\n    let quote;\n    if (tokenName === 'BOMB') {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve0, _reserve1);\n    } else {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve1, _reserve0);\n    }\n    return (quote / 1e18).toString();\n  }\n\n  /**\n   * @returns an array of the regulation events till the most up to date epoch\n   */\n  async listenForRegulationsEvents() {\n    const {\n      Treasury\n    } = this.contracts;\n    const treasuryDaoFundedFilter = Treasury.filters.DaoFundFunded();\n    const treasuryDevFundedFilter = Treasury.filters.DevFundFunded();\n    const treasuryBoardroomFundedFilter = Treasury.filters.BoardroomFunded();\n    const boughtBondsFilter = Treasury.filters.BoughtBonds();\n    const redeemBondsFilter = Treasury.filters.RedeemedBonds();\n    let epochBlocksRanges = [];\n    let boardroomFundEvents = await Treasury.queryFilter(treasuryBoardroomFundedFilter);\n    var events = [];\n    boardroomFundEvents.forEach(function callback(value, index) {\n      events.push({\n        epoch: index + 1\n      });\n      events[index].boardroomFund = getDisplayBalance(value.args[1]);\n      if (index === 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0\n        });\n      }\n      if (index > 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0\n        });\n        epochBlocksRanges[index - 1].endBlock = value.blockNumber;\n      }\n    });\n    epochBlocksRanges.forEach(async (value, index) => {\n      events[index].bondsBought = await this.getBondsWithFilterForPeriod(boughtBondsFilter, value.startBlock, value.endBlock);\n      events[index].bondsRedeemed = await this.getBondsWithFilterForPeriod(redeemBondsFilter, value.startBlock, value.endBlock);\n    });\n    let DEVFundEvents = await Treasury.queryFilter(treasuryDevFundedFilter);\n    DEVFundEvents.forEach(function callback(value, index) {\n      events[index].devFund = getDisplayBalance(value.args[1]);\n    });\n    let DAOFundEvents = await Treasury.queryFilter(treasuryDaoFundedFilter);\n    DAOFundEvents.forEach(function callback(value, index) {\n      events[index].daoFund = getDisplayBalance(value.args[1]);\n    });\n    return events;\n  }\n\n  /**\n   * Helper method\n   * @param filter applied on the query to the treasury events\n   * @param from block number\n   * @param to block number\n   * @returns the amount of bonds events emitted based on the filter provided during a specific period\n   */\n  async getBondsWithFilterForPeriod(filter, from, to) {\n    const {\n      Treasury\n    } = this.contracts;\n    const bondsAmount = await Treasury.queryFilter(filter, from, to);\n    return bondsAmount.length;\n  }\n  async estimateZapIn(tokenName, lpName, amount) {\n    const {\n      zapper\n    } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n    let estimate;\n    if (tokenName === BNB_TICKER) {\n      estimate = await zapper.estimateZapIn(lpToken.address, SPOOKY_ROUTER_ADDR, parseUnits(amount, 18));\n    } else {\n      const token = tokenName === BOMB_TICKER ? this.BOMB : this.BSHARE;\n      estimate = await zapper.estimateZapInToken(token.address, lpToken.address, SPOOKY_ROUTER_ADDR, parseUnits(amount, 18));\n    }\n    return [estimate[0] / 1e18, estimate[1] / 1e18];\n  }\n  async zapIn(tokenName, lpName, amount) {\n    const {\n      zapper\n    } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n    if (tokenName === BNB_TICKER) {\n      let overrides = {\n        value: parseUnits(amount, 18)\n      };\n      return await zapper.zapIn(lpToken.address, SPOOKY_ROUTER_ADDR, this.myAccount, overrides);\n    } else {\n      const token = tokenName === BOMB_TICKER ? this.BOMB : this.BSHARE;\n      return await zapper.zapInToken(token.address, parseUnits(amount, 18), lpToken.address, SPOOKY_ROUTER_ADDR, this.myAccount);\n    }\n  }\n  async swapBBondToBShare(bbondAmount) {\n    const {\n      BShareSwapper\n    } = this.contracts;\n    return await BShareSwapper.swapBBondToBShare(bbondAmount);\n  }\n  async estimateAmountOfBShare(bbondAmount) {\n    const {\n      BShareSwapper\n    } = this.contracts;\n    try {\n      const estimateBN = await BShareSwapper.estimateAmountOfBShare(parseUnits(bbondAmount, 18));\n      return getDisplayBalance(estimateBN, 18, 6);\n    } catch (err) {\n      console.error(`Failed to fetch estimate bshare amount: ${err}`);\n    }\n  }\n  async getBShareSwapperStat(address) {\n    const {\n      BShareSwapper\n    } = this.contracts;\n    const bshareBalanceBN = await BShareSwapper.getBShareBalance();\n    const bbondBalanceBN = await BShareSwapper.getBBondBalance(address);\n    // const bombPriceBN = await BShareSwapper.getBombPrice();\n    // const bsharePriceBN = await BShareSwapper.getBSharePrice();\n    const rateBSharePerBombBN = await BShareSwapper.getBShareAmountPerBomb();\n    const bshareBalance = getDisplayBalance(bshareBalanceBN, 18, 5);\n    const bbondBalance = getDisplayBalance(bbondBalanceBN, 18, 5);\n    return {\n      bshareBalance: bshareBalance.toString(),\n      bbondBalance: bbondBalance.toString(),\n      // bombPrice: bombPriceBN.toString(),\n      // bsharePrice: bsharePriceBN.toString(),\n      rateBSharePerBomb: rateBSharePerBombBN.toString()\n    };\n  }\n}","map":{"version":3,"names":["Fetcher","Route","Token","BigNumber","Contract","ethers","decimalToBalance","ERC20","getFullDisplayBalance","getDisplayBalance","getDefaultProvider","IUniswapV2PairABI","IBombBorrowableABI","config","bankDefinitions","moment","parseUnits","BNB_TICKER","SPOOKY_ROUTER_ADDR","BOMB_TICKER","bombMaxi","BombFinance","constructor","cfg","myAccount","provider","signer","contracts","externalTokens","boardroomVersionOfUser","BOMBBTCB_LP","BOMB","BUSD","BSHARE","BBOND","XBOMB","BNB","BTC","BOMB_BORROWABLE","BTCB_BORROWABLE","BBOMB_BOMB","BBOMB_BTCB","BBOMBBOMB","BBOMBBTCB","BUSMBUSD_LP","BUSM","BOMB_MAXI","BSHARE_MAXI","deployments","name","deployment","Object","entries","address","abi","symbol","decimal","Bomb","BShare","BBond","xBOMB","BombBorrowable","BtcbBorrowable","BombMaxiLPBShareRewardPool","BshareMaxiLPBShareRewardPool","unlockWallet","account","newProvider","providers","Web3Provider","chainId","getSigner","contract","connect","tokens","values","token","console","log","fetchBoardroomVersionOfUser","then","version","catch","err","error","stack","isUnlocked","getBombStat","BombRewardPool","BombGenesisRewardPool","supply","totalSupply","bombRewardPoolSupply","balanceOf","bombRewardPoolSupply2","bombCirculatingSupply","sub","priceInBTC","getTokenPriceFromPancakeswapBTC","priceOfOneBTC","getBTCBPriceFromPancakeswap","priceOfBombInDollars","Number","toFixed","tokenInFtm","toString","priceInDollars","circulatingSupply","getBTCPriceUSD","getLPStat","lpToken","lpTokenSupplyBN","lpTokenSupply","token0","startsWith","isBomb","tokenAmountBN","tokenAmount","ftmAmountBN","ftmAmount","tokenAmountInOneLP","ftmAmountInOneLP","lpTokenPrice","getLPTokenPrice","lpTokenPriceFixed","liquidity","priceOfOne","totalLiquidity","getLPStatBTC","btcAmountBN","btcAmount","getBondStat","Treasury","bombStat","bondBombRatioBN","getBondPremiumRate","modifier","bondPriceInBNB","priceOfBBondInDollars","displayedTotalSupply","getShareStat","BShareRewardPool","priceInBNB","getTokenPriceFromPancakeswap","tShareCirculatingSupply","priceOfOneBNB","getWBNBPriceFromPancakeswap","priceOfSharesInDollars","getBombStatInEstimatedTWAP","Oracle","expectedPrice","twap","utils","parseEther","getBombPriceInLastTWAP","getBombUpdatedPrice","getBondsPurchasable","getBurnableBombLeft","getBombMaxiStats","poolId","BombMaxi","totalShares","data","pool","getPoolAPRs","bank","undefined","depositToken","poolContract","depositTokenValue","depositTokenName","depositTokenPrice","getDepositTokenPriceInDollars","stakeInPool","TVL","stat","earnTokenName","tokenPerSecond","getTokenPerSecond","tokenPerHour","mul","totalRewardPricePerYear","totalRewardPricePerDay","totalStakingTokenInPool","dailyAPR","yearlyAPR","getXbombAPR","bombToken","xbombToken","xbombExchange","getXbombExchange","xbombPercent","xbombPercentTotal","startDate","Date","nowDate","now","difference","getTime","days","aprPerDay","contractName","endsWith","rewardPerSecond","tSharePerSecond","div","poolStartTime","startDateTime","toNumber","FOUR_DAYS","epochBombPerSecond","tokenName","tokenPrice","priceOfOneFtmInDollars","getBusdLPTokenPrice","getMaxiLPTokenPrice","getCurrentEpoch","epoch","getBondOraclePriceInLastTWAP","buyBonds","amount","treasuryBombPrice","getBombPrice","redeemBonds","priceForBomb","getTotalValueLocked","totalValue","bankInfo","tokenAmountInPool","value","poolValue","isNaN","BSHAREPrice","BOMBPrice","boardroomtShareBalanceOf","currentBoardroom","bombStakeBalanceOf","boardroomTVL","bombTVL","tokenSupply","priceOfToken","tokenInLP","priceToken","getTokenPriceFromPancakeswapBUSD","maxiPool","bombmaxi","earnedFromBank","poolName","arguments","length","pendingBOMB","pendingShare","from","stakedBalanceOnBank","userInfo","stake","deposit","unstake","withdraw","harvest","exit","Boardroom","isOldBoardroomMember","tokenContract","ready","WBNB","wftm","wftmToToken","fetchPairData","priceInBUSD","midPrice","btcb","priceForPeg","getTokenPriceFromPancakeswapBOMBUSD","FUSDT","fusdt_wftm_lp_pair","ftm_amount_BN","ftm_amount","fusdt_amount_BN","fusdt_amount","BTCB","btcPriceInBNB","wbnbPrice","btcprice","getBoardroomAPR","latestSnapshotIndex","lastHistory","boardroomHistory","lastRewardsReceived","epochRewardsPerShare","amountOfRewardsPerDay","realAPR","getBombStakeAPR","xBombBombBalanceOf","canUserClaimRewardFromBoardroom","canClaimReward","canUserUnstakeFromBoardroom","canWithdraw","stakedAmount","getStakedSharesOnBoardroom","notStaked","result","timeUntilClaimRewardFromBoardroom","getTotalStakedInBoardroom","stakeShareToBoardroom","Error","stakeToBomb","Xbomb","enter","redeemFromBomb","BombRouter","expiry","redeem","redeemFromBtcb","supplyToBtcb","mint","supplyToBomb","getShareOf","getStakedBomb","getTotalStakedBomb","bomb","getTotalSuppliedBomb","bbombBomb","totalBomb","totalBalance","getTotalSuppliedBtcb","totalBtcb","XbombExchange","getExchangeRate","xBombPerBomb","parseFloat","xBombRate","withdrawFromBomb","leave","getEarningsOnBoardroom","getCashEarningsOf","earned","withdrawShareFromBoardroom","harvestCashFromBoardroom","claimDividends","claimReward","exitFromBoardroom","getTreasuryNextAllocationTime","nextEpochTimestamp","nextEpochPoint","nextAllocation","prevAllocation","to","getUserClaimRewardTime","currentEpoch","mason","members","startTimeEpoch","epochTimerStart","period","PERIOD","periodInHours","rewardLockupEpochs","targetEpochForClaimUnlock","fromDate","toDate","delta","endDate","add","getUserUnstakeTime","PeriodInHours","withdrawLockupEpochs","watchAssetInMetamask","assetName","ethereum","window","networkVersion","asset","assetUrl","request","method","params","type","options","decimals","image","provideBombFtmLP","bombAmount","TaxOffice","overrides","addLiquidityETHTaxFree","quoteFromSpooky","SpookyRouter","_reserve0","_reserve1","getReserves","quote","listenForRegulationsEvents","treasuryDaoFundedFilter","filters","DaoFundFunded","treasuryDevFundedFilter","DevFundFunded","treasuryBoardroomFundedFilter","BoardroomFunded","boughtBondsFilter","BoughtBonds","redeemBondsFilter","RedeemedBonds","epochBlocksRanges","boardroomFundEvents","queryFilter","events","forEach","callback","index","push","boardroomFund","args","startBlock","blockNumber","boughBonds","redeemedBonds","endBlock","bondsBought","getBondsWithFilterForPeriod","bondsRedeemed","DEVFundEvents","devFund","DAOFundEvents","daoFund","filter","bondsAmount","estimateZapIn","lpName","zapper","estimate","estimateZapInToken","zapIn","zapInToken","swapBBondToBShare","bbondAmount","BShareSwapper","estimateAmountOfBShare","estimateBN","getBShareSwapperStat","bshareBalanceBN","getBShareBalance","bbondBalanceBN","getBBondBalance","rateBSharePerBombBN","getBShareAmountPerBomb","bshareBalance","bbondBalance","rateBSharePerBomb"],"sources":["C:/Users/Aditya Raj Awasthi/Desktop/bomb-dashboard-final-task/src/bomb-finance/BombFinance.ts"],"sourcesContent":["// import { Fetcher, Route, Token } from '@uniswap/sdk';\n//import { Fetcher as FetcherSpirit, Token as TokenSpirit } from '@spiritswap/sdk';\nimport { Fetcher, Route, Token } from '@pancakeswap/sdk';\nimport { Configuration } from './config';\nimport { MaxiInfo, ContractName, TokenStat, AllocationTime, LPStat, Bank, PoolStats, BShareSwapperStat } from './types';\nimport { BigNumber, Contract, ethers, EventFilter } from 'ethers';\nimport { decimalToBalance } from './ether-utils';\nimport { TransactionResponse } from '@ethersproject/providers';\nimport ERC20 from './ERC20';\nimport { getFullDisplayBalance, getDisplayBalance } from '../utils/formatBalance';\nimport { getDefaultProvider } from '../utils/provider';\nimport IUniswapV2PairABI from './IUniswapV2Pair.abi.json';\nimport IBombBorrowableABI from './IBombBorrowable.abi.json';\n\nimport config, { bankDefinitions } from '../config';\nimport moment from 'moment';\nimport { parseUnits } from 'ethers/lib/utils';\nimport { BNB_TICKER, SPOOKY_ROUTER_ADDR, BOMB_TICKER } from '../utils/constants';\nimport { bombMaxi } from '../services/graph';\n\n/**\n * An API module of Bomb Money contracts.\n * All contract-interacting domain logic should be defined in here.\n */\nexport class BombFinance {\n  myAccount: string;\n  provider: ethers.providers.Web3Provider;\n  signer?: ethers.Signer;\n  config: Configuration;\n  contracts: { [name: string]: Contract };\n  externalTokens: { [name: string]: ERC20 };\n  boardroomVersionOfUser?: string;\n\n  BOMBBTCB_LP: Contract;\n  BOMB: ERC20;\n  BUSD: ERC20;\n  BSHARE: ERC20;\n  BBOND: ERC20;\n  XBOMB: ERC20;\n  BNB: ERC20;\n  BTC: ERC20;\n  BOMB_BORROWABLE: Contract;\n  BTCB_BORROWABLE: Contract;\n  BBOMB_BOMB: ERC20;\n  BBOMB_BTCB: ERC20;\n  BBOMBBOMB: ERC20;\n  BBOMBBTCB: ERC20;\n  BUSMBUSD_LP: Contract;\n  BUSM: ERC20;\n  BOMB_MAXI: ERC20;\n  BSHARE_MAXI: ERC20;\n\n  constructor(cfg: Configuration) {\n    const { deployments, externalTokens } = cfg;\n    const provider = getDefaultProvider();\n\n    // loads contracts from deployments\n    this.contracts = {};\n    for (const [name, deployment] of Object.entries(deployments)) {\n      this.contracts[name] = new Contract(deployment.address, deployment.abi, provider);\n    }\n    this.externalTokens = {};\n    for (const [symbol, [address, decimal]] of Object.entries(externalTokens)) {\n      this.externalTokens[symbol] = new ERC20(address, provider, symbol, decimal);\n    }\n    this.BOMB = new ERC20(deployments.Bomb.address, provider, 'BOMB');\n    this.BSHARE = new ERC20(deployments.BShare.address, provider, 'BSHARE');\n    this.BBOND = new ERC20(deployments.BBond.address, provider, 'BBOND');\n    this.BNB = this.externalTokens['WBNB'];\n    this.BTC = this.externalTokens['BTCB'];\n    this.XBOMB = new ERC20(deployments.xBOMB.address, provider, 'XBOMB');\n    this.BUSM = this.externalTokens['BUSM'];\n    this.BUSD = this.externalTokens['BUSD'];\n\n    // this.BBOMB_BOMB = new ERC20(deployments.BombBorrowable.address, provider, 'bBOMB');\n    // this.BBOMB_BTCB = new ERC20(deployments.BtcbBorrowable.address, provider, 'bBOMB');\n\n    // this.BBOMB_BOMB = new Contract(externalTokens['BBOMB-BOMB'][0], IBombBorrowableABI, provider);\n    // this.BBOMB_BTCB = new Contract(externalTokens['BBOMB-BTCB'][0], IBombBorrowableABI, provider);\n    this.BBOMB_BOMB = new ERC20(deployments.BombBorrowable.address, provider, 'bBOMB');\n    this.BBOMBBOMB = this.externalTokens['BBOMB-BOMB'];\n    this.BBOMBBTCB = this.externalTokens['BBOMB-BTCB'];\n\n    this.BBOMB_BTCB = new ERC20(deployments.BtcbBorrowable.address, provider, 'bBOMB');\n    this.BOMB_BORROWABLE = new Contract(externalTokens['BBOMB-BOMB'][0], IBombBorrowableABI, provider);\n    this.BTCB_BORROWABLE = new Contract(externalTokens['BBOMB-BTCB'][0], IBombBorrowableABI, provider);\n\n    this.BOMB_MAXI = new ERC20(deployments.BombMaxiLPBShareRewardPool.address, provider, '80BOMB-20BTCB-LP');\n    this.BSHARE_MAXI = new ERC20(deployments.BshareMaxiLPBShareRewardPool.address, provider, '80BSHARE-20WBNB-LP');\n\n    // Uniswap V2 Pair\n\n    this.BOMBBTCB_LP = new Contract(externalTokens['BOMB-BTCB-LP'][0], IUniswapV2PairABI, provider);\n    this.BUSMBUSD_LP = new Contract(externalTokens['BUSM-BUSD-LP'][0], IUniswapV2PairABI, provider);\n\n    this.config = cfg;\n    this.provider = provider;\n  }\n\n  /**\n   * @param provider From an unlocked wallet. (e.g. Metamask)\n   * @param account An address of unlocked wallet account.\n   */\n  unlockWallet(provider: any, account: string) {\n    const newProvider = new ethers.providers.Web3Provider(provider, this.config.chainId);\n    this.signer = newProvider.getSigner(0);\n    this.myAccount = account;\n    for (const [name, contract] of Object.entries(this.contracts)) {\n      this.contracts[name] = contract.connect(this.signer);\n    }\n    const tokens = [this.BOMB, this.BSHARE, this.BBOND, ...Object.values(this.externalTokens)];\n    for (const token of tokens) {\n      token.connect(this.signer);\n    }\n    this.BOMBBTCB_LP = this.BOMBBTCB_LP.connect(this.signer);\n    console.log(`ðŸ”“ Wallet is unlocked. Welcome, ${account}!`);\n    this.fetchBoardroomVersionOfUser()\n      .then((version) => (this.boardroomVersionOfUser = version))\n      .catch((err) => {\n        console.error(`Failed to fetch boardroom version: ${err.stack}`);\n        this.boardroomVersionOfUser = 'latest';\n      });\n  }\n\n  get isUnlocked(): boolean {\n    return !!this.myAccount;\n  }\n\n  //===================================================================\n  //===================== GET ASSET STATS =============================\n  //===================FROM APE TO DISPLAY =========================\n  //=========================IN HOME PAGE==============================\n  //===================================================================\n\n  async getBombStat(): Promise<TokenStat> {\n    const { BombRewardPool, BombGenesisRewardPool } = this.contracts;\n    const supply = await this.BOMB.totalSupply();\n    const bombRewardPoolSupply = await this.BOMB.balanceOf(BombGenesisRewardPool.address);\n    const bombRewardPoolSupply2 = await this.BOMB.balanceOf(BombRewardPool.address);\n    const bombCirculatingSupply = supply.sub(bombRewardPoolSupply).sub(bombRewardPoolSupply2);\n    //  const priceInBNB = await this.getTokenPriceFromPancakeswap(this.BOMB);\n    //const priceInBNBstring = priceInBNB.toString();\n    const priceInBTC = await this.getTokenPriceFromPancakeswapBTC(this.BOMB);\n    // const priceOfOneBNB = await this.getWBNBPriceFromPancakeswap();\n    const priceOfOneBTC = await this.getBTCBPriceFromPancakeswap();\n    //const priceInDollars = await this.getTokenPriceFromPancakeswapBOMBUSD();\n    const priceOfBombInDollars = ((Number(priceInBTC) * Number(priceOfOneBTC)) / 10000).toFixed(2);\n    //console.log('priceOfBombInDollars', priceOfBombInDollars);\n\n    return {\n      //  tokenInFtm: (Number(priceInBNB) * 100).toString(),\n      tokenInFtm: priceInBTC.toString(),\n      priceInDollars: priceOfBombInDollars,\n      totalSupply: getDisplayBalance(supply, this.BOMB.decimal, 0),\n      circulatingSupply: getDisplayBalance(bombCirculatingSupply, this.BOMB.decimal, 0),\n    };\n  }\n\n  async getBTCPriceUSD(): Promise<Number> {\n    const priceOfOneBTC = await this.getBTCBPriceFromPancakeswap();\n    return Number(priceOfOneBTC);\n  }\n\n  /**\n   * Calculates various stats for the requested LP\n   * @param name of the LP token to load stats for\n   * @returns\n   */\n  async getLPStat(name: string): Promise<LPStat> {\n    // console.log('NAME', name);\n\n    const lpToken = this.externalTokens[name];\n    const lpTokenSupplyBN = await lpToken.totalSupply();\n    const lpTokenSupply = getDisplayBalance(lpTokenSupplyBN, 18);\n    const token0 = name.startsWith('BOMB') ? this.BOMB : this.BSHARE;\n    // console.log('NAME', name);\n\n    const isBomb = name.startsWith('BOMB');\n    const tokenAmountBN = await token0.balanceOf(lpToken.address);\n    const tokenAmount = getDisplayBalance(tokenAmountBN, 18);\n\n    const ftmAmountBN = await this.BNB.balanceOf(lpToken.address);\n    const ftmAmount = getDisplayBalance(ftmAmountBN, 18);\n    const tokenAmountInOneLP = Number(tokenAmount) / Number(lpTokenSupply);\n    const ftmAmountInOneLP = Number(ftmAmount) / Number(lpTokenSupply);\n    const lpTokenPrice = await this.getLPTokenPrice(lpToken, token0, isBomb);\n    const lpTokenPriceFixed = Number(lpTokenPrice).toFixed(2).toString();\n    const liquidity = (Number(lpTokenSupply) * Number(lpTokenPrice)).toFixed(2).toString();\n    return {\n      tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      ftmAmount: ftmAmountInOneLP.toFixed(2).toString(),\n      priceOfOne: lpTokenPriceFixed,\n      totalLiquidity: liquidity,\n      totalSupply: Number(lpTokenSupply).toFixed(2).toString(),\n    };\n  }\n\n  async getLPStatBTC(name: string): Promise<LPStat> {\n    const lpToken = this.externalTokens[name];\n    const lpTokenSupplyBN = await lpToken.totalSupply();\n    const lpTokenSupply = getDisplayBalance(lpTokenSupplyBN, 18);\n    const token0 = name.startsWith('BOMB') ? this.BOMB : this.BSHARE;\n    const isBomb = name.startsWith('BOMB');\n    const tokenAmountBN = await token0.balanceOf(lpToken.address);\n    const tokenAmount = getDisplayBalance(tokenAmountBN, 18);\n\n    const btcAmountBN = await this.BTC.balanceOf(lpToken.address);\n    const btcAmount = getDisplayBalance(btcAmountBN, 18);\n    const tokenAmountInOneLP = Number(tokenAmount) / Number(lpTokenSupply);\n    const ftmAmountInOneLP = Number(btcAmount) / Number(lpTokenSupply);\n    const lpTokenPrice = await this.getLPTokenPrice(lpToken, token0, isBomb);\n\n    const lpTokenPriceFixed = Number(lpTokenPrice).toFixed(2).toString();\n\n    const liquidity = (Number(lpTokenSupply) * Number(lpTokenPrice)).toFixed(2).toString();\n\n    return {\n      tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      ftmAmount: ftmAmountInOneLP.toFixed(5).toString(),\n      priceOfOne: lpTokenPriceFixed,\n      totalLiquidity: liquidity,\n      totalSupply: Number(lpTokenSupply).toFixed(2).toString(),\n    };\n  }\n  /**\n   * Use this method to get price for Bomb\n   * @returns TokenStat for BBOND\n   * priceInBNB\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n  async getBondStat(): Promise<TokenStat> {\n    const { Treasury } = this.contracts;\n    const bombStat = await this.getBombStat();\n    const bondBombRatioBN = await Treasury.getBondPremiumRate();\n    const modifier = bondBombRatioBN / 1e14 > 1 ? bondBombRatioBN / 1e14 : 1;\n    const bondPriceInBNB = (Number(bombStat.tokenInFtm) * modifier).toFixed(4);\n    const priceOfBBondInDollars = (Number(bombStat.priceInDollars) * modifier).toFixed(4);\n    const supply = await this.BBOND.displayedTotalSupply();\n    return {\n      tokenInFtm: bondPriceInBNB,\n      priceInDollars: priceOfBBondInDollars,\n      totalSupply: supply,\n      circulatingSupply: supply,\n    };\n  }\n\n  /**\n   * @returns TokenStat for BSHARE\n   * priceInBNB\n   * priceInDollars\n   * TotalSupply\n   * CirculatingSupply (always equal to total supply for bonds)\n   */\n  async getShareStat(): Promise<TokenStat> {\n    const { BShareRewardPool } = this.contracts;\n\n    const supply = await this.BSHARE.totalSupply();\n\n    const priceInBNB = await this.getTokenPriceFromPancakeswap(this.BSHARE);\n    const bombRewardPoolSupply = await this.BSHARE.balanceOf(BShareRewardPool.address);\n    const tShareCirculatingSupply = supply.sub(bombRewardPoolSupply);\n    const priceOfOneBNB = await this.getWBNBPriceFromPancakeswap();\n    const priceOfSharesInDollars = (Number(priceInBNB) * Number(priceOfOneBNB)).toFixed(2);\n\n    return {\n      tokenInFtm: priceInBNB,\n      priceInDollars: priceOfSharesInDollars,\n      totalSupply: getDisplayBalance(supply, this.BSHARE.decimal, 0),\n      circulatingSupply: getDisplayBalance(tShareCirculatingSupply, this.BSHARE.decimal, 0),\n    };\n  }\n\n  async getBombStatInEstimatedTWAP(): Promise<TokenStat> {\n    const { Oracle, BombRewardPool } = this.contracts;\n    const expectedPrice = await Oracle.twap(this.BOMB.address, ethers.utils.parseEther('10000'));\n\n    const supply = await this.BOMB.totalSupply();\n    const bombRewardPoolSupply = await this.BOMB.balanceOf(BombRewardPool.address);\n    const bombCirculatingSupply = supply.sub(bombRewardPoolSupply);\n    return {\n      tokenInFtm: getDisplayBalance(expectedPrice),\n      priceInDollars: getDisplayBalance(expectedPrice),\n      totalSupply: getDisplayBalance(supply, this.BOMB.decimal, 0),\n      circulatingSupply: getDisplayBalance(bombCirculatingSupply, this.BOMB.decimal, 0),\n    };\n  }\n\n  async getBombPriceInLastTWAP(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    return Treasury.getBombUpdatedPrice();\n  }\n\n  // async getBombPegTWAP(): Promise<any> {\n  //   const { Treasury } = this.contracts;\n  //   const updatedPrice = Treasury.getBombUpdatedPrice();\n  //   const updatedPrice2 = updatedPrice * 10000;\n  //   return updatedPrice2;\n  // }\n\n  async getBondsPurchasable(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    // const burnableBomb = (Number(Treasury.getBurnableBombLeft()) * 1000).toFixed(2).toString();\n    return Treasury.getBurnableBombLeft();\n  }\n\n  async getBombMaxiStats(poolId: string): Promise<MaxiInfo> {\n    const BombMaxi = await bombMaxi(poolId);\n    return {\n      totalShares: BombMaxi.data.pool.totalShares.toString(),\n      totalLiquidity: BombMaxi.data.pool.totalLiquidity.toString(),\n\n      // tokenAmount: tokenAmountInOneLP.toFixed(2).toString(),\n      // ftmAmount: ftmAmountInOneLP.toFixed(2).toString(),\n      // priceOfOne: lpTokenPriceFixed,\n      // totalLiquidity: liquidity,\n      // totalSupply: Number(lpTokenSupply).toFixed(2).toString(),\n    };\n  }\n\n  /**\n   * Calculates the TVL, APR and daily APR of a provided pool/bank\n   * @param bank\n   * @returns\n   */\n  async getPoolAPRs(bank: Bank): Promise<PoolStats> {\n    if (this.myAccount === undefined) return;\n    let depositToken = bank.depositToken;\n    // if (depositToken.symbol === '80BOMB-20BTCB-LP' || depositToken.symbol === '80BSHARE-20WBNB-LP') {\n    //   const temp = 'TBD';\n    //   return {\n    //     dailyAPR: temp,\n    //     yearlyAPR: temp,\n    //     TVL: temp,\n    //   };\n    // }\n    const poolContract = this.contracts[bank.contract];\n    let depositTokenValue: ERC20\n    if (bank.depositTokenName === \"BBOND\") {\n      depositTokenValue = this.BOMB\n    } else {\n      depositTokenValue = depositToken\n    }\n    const depositTokenPrice = await this.getDepositTokenPriceInDollars(bank.depositTokenName, depositTokenValue);\n    const stakeInPool = await depositToken.balanceOf(bank.address);\n    const TVL = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const stat = bank.earnTokenName === 'BOMB' ? await this.getBombStat() : await this.getShareStat();\n    const tokenPerSecond = await this.getTokenPerSecond(\n      bank.earnTokenName,\n      bank.contract,\n      poolContract,\n      bank.depositTokenName,\n    );\n\n    const tokenPerHour = tokenPerSecond.mul(60).mul(60);\n    const totalRewardPricePerYear =\n      Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24).mul(365)));\n    const totalRewardPricePerDay = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24)));\n    const totalStakingTokenInPool =\n      Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    const dailyAPR = (totalRewardPricePerDay / totalStakingTokenInPool) * 100;\n    const yearlyAPR = (totalRewardPricePerYear / totalStakingTokenInPool) * 100;\n    return {\n      dailyAPR: dailyAPR.toFixed(2).toString(),\n      yearlyAPR: yearlyAPR.toFixed(2).toString(),\n      TVL: TVL.toFixed(2).toString(),\n    };\n  }\n\n  async getXbombAPR(): Promise<PoolStats> {\n    if (this.myAccount === undefined) return;\n    const bombToken = this.BOMB;\n    const xbombToken = this.XBOMB;\n\n    const xbombExchange = await this.getXbombExchange();\n    const xbombPercent = await xbombExchange;\n    const xbombPercentTotal = (Number(xbombPercent) / 1000000000000000000) * 100 - 100;\n\n    const depositTokenPrice = await this.getDepositTokenPriceInDollars(bombToken.symbol, bombToken);\n\n    const stakeInPool = await bombToken.balanceOf(xbombToken.address);\n\n    const TVL = Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, bombToken.decimal));\n\n    const startDate = new Date('January 24, 2022');\n    const nowDate = new Date(Date.now());\n    const difference = nowDate.getTime() - startDate.getTime();\n    const days = difference / 60 / 60 / 24 / 1000;\n    const aprPerDay = xbombPercentTotal / days;\n\n    // Determine days between now and a date\n\n    // const tokenPerHour = tokenPerSecond.mul(60).mul(60);\n    // const totalRewardPricePerYear =\n    //   Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24).mul(365)));\n    // const totalRewardPricePerDay = Number(stat.priceInDollars) * Number(getDisplayBalance(tokenPerHour.mul(24)));\n    // const totalStakingTokenInPool =\n    //   Number(depositTokenPrice) * Number(getDisplayBalance(stakeInPool, depositToken.decimal));\n    // const dailyAPR = (totalRewardPricePerDay / totalStakingTokenInPool) * 100;\n    // const yearlyAPR = (totalRewardPricePerYear / totalStakingTokenInPool) * 100;\n\n    const dailyAPR = aprPerDay;\n    const yearlyAPR = aprPerDay * 365;\n    return {\n      dailyAPR: dailyAPR.toFixed(2).toString(),\n      yearlyAPR: yearlyAPR.toFixed(2).toString(),\n      TVL: TVL.toFixed(2).toString(),\n    };\n  }\n\n  /**\n   * Method to return the amount of tokens the pool yields per second\n   * @param earnTokenName the name of the token that the pool is earning\n   * @param contractName the contract of the pool/bank\n   * @param poolContract the actual contract of the pool\n   * @returns\n   */\n  async getTokenPerSecond(\n    earnTokenName: string,\n    contractName: string,\n    poolContract: Contract,\n    depositTokenName: string,\n  ) {\n    if (earnTokenName === 'BOMB') {\n      if (!contractName.endsWith('BombRewardPool')) {\n        const rewardPerSecond = await poolContract.tSharePerSecond();\n        if (depositTokenName === 'WBNB') {\n          return rewardPerSecond.mul(6000).div(11000).div(24);\n        } else if (depositTokenName === 'CAKE') {\n          return rewardPerSecond.mul(2500).div(11000).div(24);\n        } else if (depositTokenName === 'SUSD') {\n          return rewardPerSecond.mul(1000).div(11000).div(24);\n        } else if (depositTokenName === 'SVL') {\n          return rewardPerSecond.mul(1500).div(11000).div(24);\n        }\n        return rewardPerSecond.div(24);\n      }\n      const poolStartTime = await poolContract.poolStartTime();\n      const startDateTime = new Date(poolStartTime.toNumber() * 1000);\n      const FOUR_DAYS = 4 * 24 * 60 * 60 * 1000;\n      if (Date.now() - startDateTime.getTime() > FOUR_DAYS) {\n        return await poolContract.epochBombPerSecond(1);\n      }\n      return await poolContract.epochBombPerSecond(0);\n    }\n    const rewardPerSecond = await poolContract.tSharePerSecond();\n    if (depositTokenName.startsWith('BOMB-BTCB')) {\n      return rewardPerSecond.mul(400).div(1000);\n    } else if (depositTokenName.startsWith('BOMB-BSHARE')) {\n      return rewardPerSecond.mul(0).div(1000);\n    } else if (depositTokenName.startsWith('BOMB')) {\n      return rewardPerSecond.mul(0).div(1000);\n    } else if (depositTokenName.startsWith('BBOND')) {\n      return rewardPerSecond.mul(150).div(1000);\n    } else if (depositTokenName.startsWith('BUSM-BUSD')) {\n      return rewardPerSecond.mul(50).div(1000);\n    } else if (depositTokenName.startsWith('80BOMB')) {\n      return rewardPerSecond.mul(200).div(1000);\n    } else if (depositTokenName.startsWith('80BSHARE')) {\n      return rewardPerSecond.mul(50).div(1000);\n    } else {\n      return rewardPerSecond.mul(150).div(1000);\n    }\n    // if (depositTokenName.startsWith('BOMB-BTCB')) {\n    //   return rewardPerSecond.mul(41650).div(10000);\n    // } else if (depositTokenName.startsWith('BOMB-BSHARE')) {\n    //   return rewardPerSecond.mul(0).div(119000);\n    // } else if (depositTokenName.startsWith('BOMB')) {\n    //   return rewardPerSecond.mul(59500).div(10000);\n    // } else {\n    //   return rewardPerSecond.mul(17850).div(10000);\n    // }\n  }\n\n  /**\n   * Method to calculate the tokenPrice of the deposited asset in a pool/bank\n   * If the deposited token is an LP it will find the price of its pieces\n   * @param tokenName\n   * @param pool\n   * @param token\n   * @returns\n   */\n  async getDepositTokenPriceInDollars(tokenName: string, token: ERC20) {\n    let tokenPrice;\n    const priceOfOneFtmInDollars = await this.getWBNBPriceFromPancakeswap();\n    if (tokenName === 'WBNB') {\n      tokenPrice = priceOfOneFtmInDollars;\n    } else {\n      if (tokenName === 'BOMB-BTCB-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BOMB, true);\n      } else if (tokenName === 'BSHARE-BNB-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BSHARE, false);\n      } else if (tokenName === 'BOMB-BSHARE-LP') {\n        tokenPrice = await this.getLPTokenPrice(token, this.BOMB, true);\n        // } else if (tokenName === 'BSHARE-BNB-APELP') {\n        //   tokenPrice = await this.getLPTokenPrice(token, this.BSHARE, false);\n      } else if (tokenName === 'BUSM-BUSD-LP') {\n        tokenPrice = await this.getBusdLPTokenPrice(token, this.BUSM, true);\n      } else if (tokenName === '80BOMB-20BTCB-LP') {\n        tokenPrice = await this.getMaxiLPTokenPrice(\n          '0xd6f52e8ab206e59a1e13b3d6c5b7f31e90ef46ef000200000000000000000028',\n        );\n      } else if (tokenName === '80BSHARE-20WBNB-LP') {\n        tokenPrice = await this.getMaxiLPTokenPrice(\n          '0x2c374ed1575e5c2c02c569f627299e902a1972cb000200000000000000000027',\n        );\n      }\n      else if (tokenName === 'BBOND') {\n        tokenPrice = await this.getTokenPriceFromPancakeswap(this.BOMB);\n        tokenPrice = (Number(tokenPrice) * Number(priceOfOneFtmInDollars)).toString();\n\n\n      } else {\n        tokenPrice = await this.getTokenPriceFromPancakeswap(token);\n        tokenPrice = (Number(tokenPrice) * Number(priceOfOneFtmInDollars)).toString();\n      }\n    }\n    //console.log({ tokenPrice });\n    return tokenPrice;\n  }\n\n  //===================================================================\n  //===================== GET ASSET STATS =============================\n  //=========================== END ===================================\n  //===================================================================\n\n  async getCurrentEpoch(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    return Treasury.epoch();\n  }\n\n  async getBondOraclePriceInLastTWAP(): Promise<BigNumber> {\n    const { Treasury } = this.contracts;\n    return Treasury.getBondPremiumRate();\n  }\n\n  /**\n   * Buy bonds with cash.\n   * @param amount amount of cash to purchase bonds with.\n   */\n  async buyBonds(amount: string | number): Promise<TransactionResponse> {\n    const { Treasury } = this.contracts;\n    const treasuryBombPrice = await Treasury.getBombPrice();\n    return await Treasury.buyBonds(decimalToBalance(amount), treasuryBombPrice);\n  }\n\n  /**\n   * Redeem bonds for cash.\n   * @param amount amount of bonds to redeem.\n   */\n  async redeemBonds(amount: string | number): Promise<TransactionResponse> {\n    const { Treasury } = this.contracts;\n    const priceForBomb = await Treasury.getBombPrice();\n\n    return await Treasury.redeemBonds(decimalToBalance(amount), priceForBomb);\n  }\n\n  async getTotalValueLocked(): Promise<Number> {\n    let totalValue = 0;\n    for (const bankInfo of Object.values(bankDefinitions)) {\n      const pool = this.contracts[bankInfo.contract];\n      const token = this.externalTokens[bankInfo.depositTokenName];\n      const tokenPrice = await this.getDepositTokenPriceInDollars(bankInfo.depositTokenName, token);\n      const tokenAmountInPool = await token.balanceOf(pool.address);\n      const value = Number(getDisplayBalance(tokenAmountInPool, token.decimal)) * Number(tokenPrice);\n      const poolValue = Number.isNaN(value) ? 0 : value;\n      totalValue += poolValue;\n    }\n\n    const BSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n\n    const boardroomtShareBalanceOf = await this.BSHARE.balanceOf(this.currentBoardroom().address);\n    const bombStakeBalanceOf = await this.BOMB.balanceOf(this.XBOMB.address);\n\n    const boardroomTVL = Number(getDisplayBalance(boardroomtShareBalanceOf, this.BSHARE.decimal)) * Number(BSHAREPrice);\n    const bombTVL = Number(getDisplayBalance(bombStakeBalanceOf, this.BOMB.decimal)) * Number(BOMBPrice);\n\n    return totalValue + boardroomTVL + bombTVL;\n  }\n\n  /**\n   * Calculates the price of an LP token\n   * Reference https://github.com/DefiDebauchery/discordpricebot/blob/4da3cdb57016df108ad2d0bb0c91cd8dd5f9d834/pricebot/pricebot.py#L150\n   * @param lpToken the token under calculation\n   * @param token the token pair used as reference (the other one would be BNB in most cases)\n   * @param isBomb sanity check for usage of bomb token or tShare\n   * @returns price of the LP token\n   */\n  async getLPTokenPrice(lpToken: ERC20, token: ERC20, isBomb: boolean): Promise<string> {\n    const totalSupply = getFullDisplayBalance(await lpToken.totalSupply(), lpToken.decimal);\n    //Get amount of tokenA\n    const tokenSupply = getFullDisplayBalance(await token.balanceOf(lpToken.address), token.decimal);\n    const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n    const priceOfToken = stat.priceInDollars;\n    const tokenInLP = Number(tokenSupply) / Number(totalSupply);\n    const tokenPrice = (Number(priceOfToken) * tokenInLP * 2) //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n      .toString();\n    return tokenPrice;\n  }\n\n  /**\n   * Calculates the price of an LP token\n   * Reference https://github.com/DefiDebauchery/discordpricebot/blob/4da3cdb57016df108ad2d0bb0c91cd8dd5f9d834/pricebot/pricebot.py#L150\n   * @param lpToken the token under calculation\n   * @param token the token pair used as reference (the other one would be BNB in most cases)\n   * @param isBomb sanity check for usage of bomb token or tShare\n   * @returns price of the LP token\n   */\n  async getBusdLPTokenPrice(lpToken: ERC20, token: ERC20, isBomb: boolean): Promise<string> {\n    const totalSupply = getFullDisplayBalance(await lpToken.totalSupply(), lpToken.decimal);\n    //Get amount of tokenA\n    const tokenSupply = getFullDisplayBalance(await token.balanceOf(lpToken.address), token.decimal);\n    // const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n    const priceToken = await this.getTokenPriceFromPancakeswapBUSD(this.BUSM);\n    const priceOfToken = Number(priceToken);\n    const tokenInLP = Number(tokenSupply) / Number(totalSupply);\n    const tokenPrice = (Number(priceOfToken) * tokenInLP * 2) //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n      .toString();\n    return tokenPrice;\n  }\n\n  async getMaxiLPTokenPrice(maxiPool: string): Promise<string> {\n    const bombmaxi = await this.getBombMaxiStats(maxiPool);\n    const totalShares = await bombmaxi.totalShares;\n    //Get amount of tokenA\n    const totalLiquidity = await bombmaxi.totalLiquidity;\n    // const stat = isBomb === true ? await this.getBombStat() : await this.getShareStat();\n\n    const tokenInLP = Number(totalLiquidity) / Number(totalShares);\n    const tokenPrice = tokenInLP //We multiply by 2 since half the price of the lp token is the price of each piece of the pair. So twice gives the total\n      .toString();\n    return tokenPrice;\n  }\n\n  async earnedFromBank(\n    poolName: ContractName,\n    earnTokenName: String,\n    poolId: Number,\n    account = this.myAccount,\n  ): Promise<BigNumber> {\n    const pool = this.contracts[poolName];\n    try {\n      if (earnTokenName === 'BOMB') {\n        return await pool.pendingBOMB(poolId, account);\n      } else {\n        return await pool.pendingShare(poolId, account);\n      }\n    } catch (err) {\n      console.error(`Failed to call pendingShare() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n\n  async stakedBalanceOnBank(poolName: ContractName, poolId: Number, account = this.myAccount): Promise<BigNumber> {\n    const pool = this.contracts[poolName];\n    try {\n      let userInfo = await pool.userInfo(poolId, account);\n      return await userInfo.amount;\n    } catch (err) {\n      console.error(`Failed to call userInfo() on pool ${pool.address}: ${err.stack}`);\n      return BigNumber.from(0);\n    }\n  }\n\n  /**\n   * Deposits token to given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n  async stake(poolName: ContractName, poolId: Number, amount: BigNumber): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    return await pool.deposit(poolId, amount);\n  }\n\n  /**\n   * Withdraws token from given pool.\n   * @param poolName A name of pool contract.\n   * @param amount Number of tokens with decimals applied. (e.g. 1.45 DAI * 10^18)\n   * @returns {string} Transaction hash\n   */\n  async unstake(poolName: ContractName, poolId: Number, amount: BigNumber): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    return await pool.withdraw(poolId, amount);\n  }\n\n  /**\n   * Transfers earned token reward from given pool to my account.\n   */\n  async harvest(poolName: ContractName, poolId: Number): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    //By passing 0 as the amount, we are asking the contract to only redeem the reward and not the currently staked token\n    return await pool.withdraw(poolId, 0);\n  }\n\n  /**\n   * Harvests and withdraws deposited tokens from the pool.\n   */\n  async exit(poolName: ContractName, poolId: Number, account = this.myAccount): Promise<TransactionResponse> {\n    const pool = this.contracts[poolName];\n    let userInfo = await pool.userInfo(poolId, account);\n    return await pool.withdraw(poolId, userInfo.amount);\n  }\n\n  async fetchBoardroomVersionOfUser(): Promise<string> {\n    return 'latest';\n  }\n\n  currentBoardroom(): Contract {\n    if (!this.boardroomVersionOfUser) {\n      //throw new Error('you must unlock the wallet to continue.');\n    }\n    return this.contracts.Boardroom;\n  }\n\n  isOldBoardroomMember(): boolean {\n    return this.boardroomVersionOfUser !== 'latest';\n  }\n\n  async getTokenPriceFromPancakeswap(tokenContract: ERC20): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    const { WBNB } = this.config.externalTokens;\n\n    const wftm = new Token(56, WBNB[0], WBNB[1], 'WBNB');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(wftm, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      return priceInBUSD.midPrice.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromPancakeswapBUSD(tokenContract: ERC20): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    const { BUSD } = this.config.externalTokens;\n\n    const wftm = new Token(56, BUSD[0], BUSD[1], 'BUSD');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(wftm, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      return priceInBUSD.midPrice.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromPancakeswapBTC(tokenContract: ERC20): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    // const {WBNB} = this.config.externalTokens;\n\n    // const wbnb = new Token(56, WBNB[0], WBNB[1]);\n    const btcb = new Token(56, this.BTC.address, this.BTC.decimal, 'BTCB', 'BTCB');\n    const token = new Token(56, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(btcb, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      //   console.log('priceInBUSDBTC', priceInBUSD.midPrice.toFixed(12));\n\n      const priceForPeg = Number(priceInBUSD.midPrice.toFixed(12)) * 10000;\n      return priceForPeg.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n    }\n  }\n\n  async getTokenPriceFromPancakeswapBOMBUSD(): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    //const { chainId } = this.config;\n    //const {WBNB} = this.config.externalTokens;\n\n    //  const wbnb = new Token(56, WBNB[0], WBNB[1]);\n    const btcb = new Token(56, this.BTC.address, this.BTC.decimal, 'BTCB', 'BTCB');\n    const token = new Token(56, this.BOMB.address, this.BOMB.decimal, this.BOMB.symbol);\n    try {\n      const wftmToToken = await Fetcher.fetchPairData(btcb, token, this.provider);\n      const priceInBUSD = new Route([wftmToToken], token);\n      // console.log('test', priceInBUSD.midPrice.toFixed(12));\n\n      const priceForPeg = Number(priceInBUSD.midPrice.toFixed(12)) * 10000;\n      return priceForPeg.toFixed(4);\n    } catch (err) {\n      console.error(`Failed to fetch token price of ${this.BOMB.symbol}: ${err}`);\n    }\n  }\n\n  // async getTokenPriceFromSpiritswap(tokenContract: ERC20): Promise<string> {\n  //   const ready = await this.provider.ready;\n  //   if (!ready) return;\n  //   const { chainId } = this.config;\n\n  //   const { WBNB } = this.externalTokens;\n\n  //   const wftm = new TokenSpirit(chainId, WBNB.address, WBNB.decimal);\n  //   const token = new TokenSpirit(chainId, tokenContract.address, tokenContract.decimal, tokenContract.symbol);\n  //   try {\n  //     const wftmToToken = await FetcherSpirit.fetchPairData(wftm, token, this.provider);\n  //     const liquidityToken = wftmToToken.liquidityToken;\n  //     let ftmBalanceInLP = await WBNB.balanceOf(liquidityToken.address);\n  //     let ftmAmount = Number(getFullDisplayBalance(ftmBalanceInLP, WBNB.decimal));\n  //     let shibaBalanceInLP = await tokenContract.balanceOf(liquidityToken.address);\n  //     let shibaAmount = Number(getFullDisplayBalance(shibaBalanceInLP, tokenContract.decimal));\n  //     const priceOfOneFtmInDollars = await this.getWBNBPriceFromPancakeswap();\n  //     let priceOfShiba = (ftmAmount / shibaAmount) * Number(priceOfOneFtmInDollars);\n  //     return priceOfShiba.toString();\n  //   } catch (err) {\n  //     console.error(`Failed to fetch token price of ${tokenContract.symbol}: ${err}`);\n  //   }\n  // }\n\n  async getWBNBPriceFromPancakeswap(): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const { WBNB, FUSDT } = this.externalTokens;\n    try {\n      const fusdt_wftm_lp_pair = this.externalTokens['USDT-BNB-LP'];\n      let ftm_amount_BN = await WBNB.balanceOf(fusdt_wftm_lp_pair.address);\n      let ftm_amount = Number(getFullDisplayBalance(ftm_amount_BN, WBNB.decimal));\n      let fusdt_amount_BN = await FUSDT.balanceOf(fusdt_wftm_lp_pair.address);\n      let fusdt_amount = Number(getFullDisplayBalance(fusdt_amount_BN, FUSDT.decimal));\n      return (fusdt_amount / ftm_amount).toString();\n    } catch (err) {\n      console.error(`Failed to fetch token price of WBNB: ${err}`);\n    }\n  }\n\n  async getBTCBPriceFromPancakeswap(): Promise<string> {\n    const ready = await this.provider.ready;\n    if (!ready) return;\n    const { BTCB } = this.externalTokens;\n    try {\n      const btcPriceInBNB = await this.getTokenPriceFromPancakeswap(BTCB);\n\n      const wbnbPrice = await this.getWBNBPriceFromPancakeswap();\n\n      const btcprice = (Number(btcPriceInBNB) * Number(wbnbPrice)).toFixed(2).toString();\n      //console.log('btcprice', btcprice);\n      return btcprice;\n    } catch (err) {\n      console.error(`Failed to fetch token price of BTCB: ${err}`);\n    }\n  }\n\n  // async getBTCBPriceFromPancakeswap(): Promise<string> {\n  //   const ready = await this.provider.ready;\n  //   if (!ready) return;\n  //   const { BTCB, FUSDT } = this.externalTokens;\n  //   try {\n  //     const fusdt_btcb_lp_pair = this.externalTokens['USDT-BTCB-LP'];\n  //     let ftm_amount_BN = await BTCB.balanceOf(fusdt_btcb_lp_pair.address);\n  //     let ftm_amount = Number(getFullDisplayBalance(ftm_amount_BN, BTCB.decimal));\n  //     let fusdt_amount_BN = await FUSDT.balanceOf(fusdt_btcb_lp_pair.address);\n  //     let fusdt_amount = Number(getFullDisplayBalance(fusdt_amount_BN, FUSDT.decimal));\n  //     console.log('BTCB price', (fusdt_amount / ftm_amount).toString());\n  //     return (fusdt_amount / ftm_amount).toString();\n  //     console.log('BTCB price');\n  //   } catch (err) {\n  //     console.error(`Failed to fetch token price of BTCB: ${err}`);\n  //   }\n  // }\n\n  //===================================================================\n  //===================================================================\n  //===================== MASONRY METHODS =============================\n  //===================================================================\n  //===================================================================\n\n  async getBoardroomAPR() {\n    const Boardroom = this.currentBoardroom();\n    const latestSnapshotIndex = await Boardroom.latestSnapshotIndex();\n    const lastHistory = await Boardroom.boardroomHistory(latestSnapshotIndex);\n\n    const lastRewardsReceived = lastHistory[1];\n\n    const BSHAREPrice = (await this.getShareStat()).priceInDollars;\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n    const epochRewardsPerShare = lastRewardsReceived / 1e18;\n\n    //Mgod formula\n    const amountOfRewardsPerDay = epochRewardsPerShare * Number(BOMBPrice) * 4;\n    const boardroomtShareBalanceOf = await this.BSHARE.balanceOf(Boardroom.address);\n    const boardroomTVL = Number(getDisplayBalance(boardroomtShareBalanceOf, this.BSHARE.decimal)) * Number(BSHAREPrice);\n    const realAPR = ((amountOfRewardsPerDay * 100) / boardroomTVL) * 365;\n    return realAPR;\n  }\n\n  async getBombStakeAPR() {\n    const Boardroom = this.currentBoardroom();\n    const latestSnapshotIndex = await Boardroom.latestSnapshotIndex();\n    const lastHistory = await Boardroom.boardroomHistory(latestSnapshotIndex);\n\n    const lastRewardsReceived = lastHistory[1];\n\n    const BOMBPrice = (await this.getBombStat()).priceInDollars;\n    const epochRewardsPerShare = lastRewardsReceived / 1e18;\n\n    //Mgod formula\n    const amountOfRewardsPerDay = epochRewardsPerShare * Number(BOMBPrice) * 4;\n    const xBombBombBalanceOf = await this.BOMB.balanceOf(this.XBOMB.address);\n    const bombTVL = Number(getDisplayBalance(xBombBombBalanceOf, this.XBOMB.decimal)) * Number(BOMBPrice);\n    const realAPR = ((amountOfRewardsPerDay * 100 * 0.2) / bombTVL) * 365;\n    return realAPR;\n  }\n\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Boardroom\n   * @returns true if user can withdraw reward, false if they can't\n   */\n  async canUserClaimRewardFromBoardroom(): Promise<boolean> {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.canClaimReward(this.myAccount);\n  }\n\n  /**\n   * Checks if the user is allowed to retrieve their reward from the Boardroom\n   * @returns true if user can withdraw reward, false if they can't\n   */\n  async canUserUnstakeFromBoardroom(): Promise<boolean> {\n    const Boardroom = this.currentBoardroom();\n    const canWithdraw = await Boardroom.canWithdraw(this.myAccount);\n    const stakedAmount = await this.getStakedSharesOnBoardroom();\n    const notStaked = Number(getDisplayBalance(stakedAmount, this.BSHARE.decimal)) === 0;\n    const result = notStaked ? true : canWithdraw;\n    return result;\n  }\n\n  async timeUntilClaimRewardFromBoardroom(): Promise<BigNumber> {\n    // const Boardroom = this.currentBoardroom();\n    // const mason = await Boardroom.masons(this.myAccount);\n    return BigNumber.from(0);\n  }\n\n  async getTotalStakedInBoardroom(): Promise<BigNumber> {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.totalSupply();\n  }\n\n  async stakeShareToBoardroom(amount: string): Promise<TransactionResponse> {\n    if (this.isOldBoardroomMember()) {\n      throw new Error(\"you're using old boardroom. please withdraw and deposit the BSHARE again.\");\n    }\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.stake(decimalToBalance(amount));\n  }\n\n  async stakeToBomb(amount: string): Promise<TransactionResponse> {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.enter(decimalToBalance(amount));\n  }\n\n  async redeemFromBomb(amount: string): Promise<TransactionResponse> {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.redeem(\n      this.BBOMB_BOMB.address,\n      decimalToBalance(amount),\n      this.myAccount,\n      expiry.getTime(),\n      '0x',\n    );\n  }\n\n  async redeemFromBtcb(amount: string): Promise<TransactionResponse> {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.redeem(\n      this.BBOMB_BTCB.address,\n      decimalToBalance(amount),\n      this.myAccount,\n      expiry.getTime(),\n      '0x',\n    );\n  }\n  async supplyToBtcb(amount: string): Promise<TransactionResponse> {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.mint(this.BBOMB_BTCB.address, decimalToBalance(amount), this.myAccount, expiry.getTime());\n  }\n\n  async supplyToBomb(amount: string): Promise<TransactionResponse> {\n    const BombRouter = this.contracts.BombRouter;\n    const expiry = new Date(Date.now() + 2880);\n    return await BombRouter.mint(this.BBOMB_BOMB.address, decimalToBalance(amount), this.myAccount, expiry.getTime());\n  }\n\n  async getStakedSharesOnBoardroom(): Promise<BigNumber> {\n    const Boardroom = this.currentBoardroom();\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.getShareOf(this.myAccount);\n    }\n    return await Boardroom.balanceOf(this.myAccount);\n  }\n\n  async getStakedBomb(): Promise<BigNumber> {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.balanceOf(this.myAccount);\n  }\n\n  async getTotalStakedBomb(): Promise<BigNumber> {\n    const Xbomb = this.contracts.xBOMB;\n    const bomb = this.BOMB;\n    return await bomb.balanceOf(Xbomb.address);\n  }\n\n  async getTotalSuppliedBomb(): Promise<BigNumber> {\n    const bbombBomb = this.BOMB_BORROWABLE;\n    // const bomb = this.BOMB;\n    const totalBomb = await bbombBomb.totalBalance();\n    //  const borrowBomb = await bbombBomb.totalBorrows();\n    // const totalSupplied = totalBomb + borrowBomb;\n    return totalBomb;\n  }\n\n  async getTotalSuppliedBtcb(): Promise<BigNumber> {\n    const bbombBomb = this.BTCB_BORROWABLE;\n    // const bomb = this.BOMB;\n    const totalBtcb = await bbombBomb.totalBalance();\n    //const borrowBtcb = await bbombBomb.totalBorrows();\n    //  const totalSupplied = totalBtcb + borrowBtcb;\n    return totalBtcb;\n  }\n\n  async getXbombExchange(): Promise<BigNumber> {\n    const Xbomb = this.contracts.xBOMB;\n    const XbombExchange = await Xbomb.getExchangeRate();\n\n    const xBombPerBomb = parseFloat(XbombExchange) / 1000000000000000000;\n    const xBombRate = xBombPerBomb.toString();\n    return parseUnits(xBombRate, 18);\n  }\n\n  async withdrawFromBomb(amount: string): Promise<TransactionResponse> {\n    const Xbomb = this.contracts.xBOMB;\n    return await Xbomb.leave(decimalToBalance(amount));\n  }\n\n  async getEarningsOnBoardroom(): Promise<BigNumber> {\n    const Boardroom = this.currentBoardroom();\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.getCashEarningsOf(this.myAccount);\n    }\n    return await Boardroom.earned(this.myAccount);\n  }\n\n  async withdrawShareFromBoardroom(amount: string): Promise<TransactionResponse> {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.withdraw(decimalToBalance(amount));\n  }\n\n  async harvestCashFromBoardroom(): Promise<TransactionResponse> {\n    const Boardroom = this.currentBoardroom();\n    if (this.boardroomVersionOfUser === 'v1') {\n      return await Boardroom.claimDividends();\n    }\n    return await Boardroom.claimReward();\n  }\n\n  async exitFromBoardroom(): Promise<TransactionResponse> {\n    const Boardroom = this.currentBoardroom();\n    return await Boardroom.exit();\n  }\n\n  async getTreasuryNextAllocationTime(): Promise<AllocationTime> {\n    const { Treasury } = this.contracts;\n    const nextEpochTimestamp: BigNumber = await Treasury.nextEpochPoint();\n    const nextAllocation = new Date(nextEpochTimestamp.mul(1000).toNumber());\n    const prevAllocation = new Date(Date.now());\n\n    return { from: prevAllocation, to: nextAllocation };\n  }\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to claim\n   * their reward from the boardroom\n   * @returns Promise<AllocationTime>\n   */\n  async getUserClaimRewardTime(): Promise<AllocationTime> {\n    const { Boardroom, Treasury } = this.contracts;\n    const nextEpochTimestamp = await Boardroom.nextEpochPoint(); //in unix timestamp\n    const currentEpoch = await Boardroom.epoch();\n    const mason = await Boardroom.members(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const periodInHours = period / 60 / 60; // 6 hours, period is displayed in seconds which is 21600\n    const rewardLockupEpochs = await Boardroom.rewardLockupEpochs();\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(rewardLockupEpochs);\n\n    const fromDate = new Date(Date.now());\n    if (targetEpochForClaimUnlock - currentEpoch <= 0) {\n      return { from: fromDate, to: fromDate };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return { from: fromDate, to: toDate };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - currentEpoch - 1;\n      const endDate = moment(toDate)\n        .add(delta * periodInHours, 'hours')\n        .toDate();\n      return { from: fromDate, to: endDate };\n    }\n  }\n\n  /**\n   * This method calculates and returns in a from to to format\n   * the period the user needs to wait before being allowed to unstake\n   * from the boardroom\n   * @returns Promise<AllocationTime>\n   */\n  async getUserUnstakeTime(): Promise<AllocationTime> {\n    const { Boardroom, Treasury } = this.contracts;\n    const nextEpochTimestamp = await Boardroom.nextEpochPoint();\n    const currentEpoch = await Boardroom.epoch();\n    const mason = await Boardroom.members(this.myAccount);\n    const startTimeEpoch = mason.epochTimerStart;\n    const period = await Treasury.PERIOD();\n    const PeriodInHours = period / 60 / 60;\n    const withdrawLockupEpochs = await Boardroom.withdrawLockupEpochs();\n    const fromDate = new Date(Date.now());\n    const targetEpochForClaimUnlock = Number(startTimeEpoch) + Number(withdrawLockupEpochs);\n    const stakedAmount = await this.getStakedSharesOnBoardroom();\n    if (currentEpoch <= targetEpochForClaimUnlock && Number(stakedAmount) === 0) {\n      return { from: fromDate, to: fromDate };\n    } else if (targetEpochForClaimUnlock - currentEpoch === 1) {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      return { from: fromDate, to: toDate };\n    } else {\n      const toDate = new Date(nextEpochTimestamp * 1000);\n      const delta = targetEpochForClaimUnlock - Number(currentEpoch) - 1;\n      const endDate = moment(toDate)\n        .add(delta * PeriodInHours, 'hours')\n        .toDate();\n      return { from: fromDate, to: endDate };\n    }\n  }\n\n  async watchAssetInMetamask(assetName: string): Promise<boolean> {\n    const { ethereum } = window as any;\n    if (ethereum && ethereum.networkVersion === config.chainId.toString()) {\n      let asset;\n      let assetUrl;\n      if (assetName === 'BOMB') {\n        asset = this.BOMB;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bomb-512.png';\n      } else if (assetName === 'BSHARE') {\n        asset = this.BSHARE;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bshare-512.png';\n      } else if (assetName === 'BBOND') {\n        asset = this.BBOND;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/bbond-512.png';\n      } else if (assetName === 'XBOMB') {\n        asset = this.XBOMB;\n        assetUrl = 'https://raw.githubusercontent.com/bombmoney/bomb-assets/master/xbomb-512.png';\n      } else if (assetName === 'BTCB') {\n        asset = this.BTC;\n        assetUrl = 'https://bscscan.com/token/images/btcb_32.png';\n      }\n      await ethereum.request({\n        method: 'wallet_watchAsset',\n        params: {\n          type: 'ERC20',\n          options: {\n            address: asset.address,\n            symbol: asset.symbol,\n            decimals: 18,\n            image: assetUrl,\n          },\n        },\n      });\n    }\n    return true;\n  }\n\n  async provideBombFtmLP(ftmAmount: string, bombAmount: BigNumber): Promise<TransactionResponse> {\n    const { TaxOffice } = this.contracts;\n    let overrides = {\n      value: parseUnits(ftmAmount, 18),\n    };\n    return await TaxOffice.addLiquidityETHTaxFree(\n      bombAmount,\n      bombAmount.mul(992).div(1000),\n      parseUnits(ftmAmount, 18).mul(992).div(1000),\n      overrides,\n    );\n  }\n\n  async quoteFromSpooky(tokenAmount: string, tokenName: string): Promise<string> {\n    const { SpookyRouter } = this.contracts;\n    const { _reserve0, _reserve1 } = await this.BOMBBTCB_LP.getReserves();\n    let quote;\n    if (tokenName === 'BOMB') {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve0, _reserve1);\n    } else {\n      quote = await SpookyRouter.quote(parseUnits(tokenAmount), _reserve1, _reserve0);\n    }\n    return (quote / 1e18).toString();\n  }\n\n  /**\n   * @returns an array of the regulation events till the most up to date epoch\n   */\n  async listenForRegulationsEvents(): Promise<any> {\n    const { Treasury } = this.contracts;\n\n    const treasuryDaoFundedFilter = Treasury.filters.DaoFundFunded();\n    const treasuryDevFundedFilter = Treasury.filters.DevFundFunded();\n    const treasuryBoardroomFundedFilter = Treasury.filters.BoardroomFunded();\n    const boughtBondsFilter = Treasury.filters.BoughtBonds();\n    const redeemBondsFilter = Treasury.filters.RedeemedBonds();\n\n    let epochBlocksRanges: any[] = [];\n    let boardroomFundEvents = await Treasury.queryFilter(treasuryBoardroomFundedFilter);\n    var events: any[] = [];\n    boardroomFundEvents.forEach(function callback(value, index) {\n      events.push({ epoch: index + 1 });\n      events[index].boardroomFund = getDisplayBalance(value.args[1]);\n      if (index === 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0,\n        });\n      }\n      if (index > 0) {\n        epochBlocksRanges.push({\n          index: index,\n          startBlock: value.blockNumber,\n          boughBonds: 0,\n          redeemedBonds: 0,\n        });\n        epochBlocksRanges[index - 1].endBlock = value.blockNumber;\n      }\n    });\n\n    epochBlocksRanges.forEach(async (value, index) => {\n      events[index].bondsBought = await this.getBondsWithFilterForPeriod(\n        boughtBondsFilter,\n        value.startBlock,\n        value.endBlock,\n      );\n      events[index].bondsRedeemed = await this.getBondsWithFilterForPeriod(\n        redeemBondsFilter,\n        value.startBlock,\n        value.endBlock,\n      );\n    });\n    let DEVFundEvents = await Treasury.queryFilter(treasuryDevFundedFilter);\n    DEVFundEvents.forEach(function callback(value, index) {\n      events[index].devFund = getDisplayBalance(value.args[1]);\n    });\n    let DAOFundEvents = await Treasury.queryFilter(treasuryDaoFundedFilter);\n    DAOFundEvents.forEach(function callback(value, index) {\n      events[index].daoFund = getDisplayBalance(value.args[1]);\n    });\n    return events;\n  }\n\n  /**\n   * Helper method\n   * @param filter applied on the query to the treasury events\n   * @param from block number\n   * @param to block number\n   * @returns the amount of bonds events emitted based on the filter provided during a specific period\n   */\n  async getBondsWithFilterForPeriod(filter: EventFilter, from: number, to: number): Promise<number> {\n    const { Treasury } = this.contracts;\n    const bondsAmount = await Treasury.queryFilter(filter, from, to);\n    return bondsAmount.length;\n  }\n\n  async estimateZapIn(tokenName: string, lpName: string, amount: string): Promise<number[]> {\n    const { zapper } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n    let estimate;\n    if (tokenName === BNB_TICKER) {\n      estimate = await zapper.estimateZapIn(lpToken.address, SPOOKY_ROUTER_ADDR, parseUnits(amount, 18));\n    } else {\n      const token = tokenName === BOMB_TICKER ? this.BOMB : this.BSHARE;\n      estimate = await zapper.estimateZapInToken(\n        token.address,\n        lpToken.address,\n        SPOOKY_ROUTER_ADDR,\n        parseUnits(amount, 18),\n      );\n    }\n    return [estimate[0] / 1e18, estimate[1] / 1e18];\n  }\n  async zapIn(tokenName: string, lpName: string, amount: string): Promise<TransactionResponse> {\n    const { zapper } = this.contracts;\n    const lpToken = this.externalTokens[lpName];\n    if (tokenName === BNB_TICKER) {\n      let overrides = {\n        value: parseUnits(amount, 18),\n      };\n      return await zapper.zapIn(lpToken.address, SPOOKY_ROUTER_ADDR, this.myAccount, overrides);\n    } else {\n      const token = tokenName === BOMB_TICKER ? this.BOMB : this.BSHARE;\n      return await zapper.zapInToken(\n        token.address,\n        parseUnits(amount, 18),\n        lpToken.address,\n        SPOOKY_ROUTER_ADDR,\n        this.myAccount,\n      );\n    }\n  }\n  async swapBBondToBShare(bbondAmount: BigNumber): Promise<TransactionResponse> {\n    const { BShareSwapper } = this.contracts;\n    return await BShareSwapper.swapBBondToBShare(bbondAmount);\n  }\n  async estimateAmountOfBShare(bbondAmount: string): Promise<string> {\n    const { BShareSwapper } = this.contracts;\n    try {\n      const estimateBN = await BShareSwapper.estimateAmountOfBShare(parseUnits(bbondAmount, 18));\n      return getDisplayBalance(estimateBN, 18, 6);\n    } catch (err) {\n      console.error(`Failed to fetch estimate bshare amount: ${err}`);\n    }\n  }\n\n  async getBShareSwapperStat(address: string): Promise<BShareSwapperStat> {\n    const { BShareSwapper } = this.contracts;\n    const bshareBalanceBN = await BShareSwapper.getBShareBalance();\n    const bbondBalanceBN = await BShareSwapper.getBBondBalance(address);\n    // const bombPriceBN = await BShareSwapper.getBombPrice();\n    // const bsharePriceBN = await BShareSwapper.getBSharePrice();\n    const rateBSharePerBombBN = await BShareSwapper.getBShareAmountPerBomb();\n    const bshareBalance = getDisplayBalance(bshareBalanceBN, 18, 5);\n    const bbondBalance = getDisplayBalance(bbondBalanceBN, 18, 5);\n    return {\n      bshareBalance: bshareBalance.toString(),\n      bbondBalance: bbondBalance.toString(),\n      // bombPrice: bombPriceBN.toString(),\n      // bsharePrice: bsharePriceBN.toString(),\n      rateBSharePerBomb: rateBSharePerBombBN.toString(),\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}