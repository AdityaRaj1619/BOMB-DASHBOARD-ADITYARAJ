{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar constants_1 = require(\"../utils/constants\");\nvar queue_1 = require(\"../utils/queue\");\nvar RawCalldata = /** @class */function () {\n  function RawCalldata(value, hasSelector) {\n    if (hasSelector === void 0) {\n      hasSelector = true;\n    }\n    // Sanity check\n    if (typeof value === 'string' && !_.startsWith(value, '0x')) {\n      throw new Error(\"Expected raw calldata to start with '0x'\");\n    }\n    // Construct initial values\n    this._value = ethUtil.toBuffer(value);\n    this._selector = '0x';\n    this._scopes = new queue_1.Queue();\n    this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\n    this._offset = RawCalldata._INITIAL_OFFSET;\n    // If there's a selector then slice it\n    if (hasSelector) {\n      var selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n      this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n      this._selector = ethUtil.bufferToHex(selectorBuf);\n    }\n  }\n  RawCalldata.prototype.popBytes = function (lengthInBytes) {\n    var popBegin = this._offset;\n    var popEnd = popBegin + lengthInBytes;\n    if (popEnd > this._value.byteLength) {\n      throw new Error(\"Tried to decode beyond the end of calldata\");\n    }\n    var value = this._value.slice(popBegin, popEnd);\n    this.setOffset(popEnd);\n    return value;\n  };\n  RawCalldata.prototype.popWord = function () {\n    var wordInBytes = 32;\n    return this.popBytes(wordInBytes);\n  };\n  RawCalldata.prototype.popWords = function (length) {\n    var wordInBytes = 32;\n    return this.popBytes(length * wordInBytes);\n  };\n  RawCalldata.prototype.readBytes = function (from, to) {\n    var value = this._value.slice(from, to);\n    return value;\n  };\n  RawCalldata.prototype.setOffset = function (offsetInBytes) {\n    this._offset = offsetInBytes;\n  };\n  RawCalldata.prototype.startScope = function () {\n    this._scopes.pushFront(this._offset);\n  };\n  RawCalldata.prototype.endScope = function () {\n    this._scopes.popFront();\n  };\n  RawCalldata.prototype.getOffset = function () {\n    return this._offset;\n  };\n  RawCalldata.prototype.toAbsoluteOffset = function (relativeOffset) {\n    var scopeOffset = this._scopes.peekFront();\n    if (scopeOffset === undefined) {\n      throw new Error(\"Tried to access undefined scope.\");\n    }\n    var absoluteOffset = relativeOffset + scopeOffset;\n    return absoluteOffset;\n  };\n  RawCalldata.prototype.getSelector = function () {\n    return this._selector;\n  };\n  RawCalldata.prototype.getSizeInBytes = function () {\n    var sizeInBytes = this._value.byteLength;\n    return sizeInBytes;\n  };\n  RawCalldata._INITIAL_OFFSET = 0;\n  return RawCalldata;\n}();\nexports.RawCalldata = RawCalldata;","map":{"version":3,"sources":["../../../../src/abi_encoder/calldata/raw_calldata.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar constants_1 = require(\"../utils/constants\");\nvar queue_1 = require(\"../utils/queue\");\nvar RawCalldata = /** @class */ (function () {\n    function RawCalldata(value, hasSelector) {\n        if (hasSelector === void 0) { hasSelector = true; }\n        // Sanity check\n        if (typeof value === 'string' && !_.startsWith(value, '0x')) {\n            throw new Error(\"Expected raw calldata to start with '0x'\");\n        }\n        // Construct initial values\n        this._value = ethUtil.toBuffer(value);\n        this._selector = '0x';\n        this._scopes = new queue_1.Queue();\n        this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\n        this._offset = RawCalldata._INITIAL_OFFSET;\n        // If there's a selector then slice it\n        if (hasSelector) {\n            var selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n            this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n            this._selector = ethUtil.bufferToHex(selectorBuf);\n        }\n    }\n    RawCalldata.prototype.popBytes = function (lengthInBytes) {\n        var popBegin = this._offset;\n        var popEnd = popBegin + lengthInBytes;\n        if (popEnd > this._value.byteLength) {\n            throw new Error(\"Tried to decode beyond the end of calldata\");\n        }\n        var value = this._value.slice(popBegin, popEnd);\n        this.setOffset(popEnd);\n        return value;\n    };\n    RawCalldata.prototype.popWord = function () {\n        var wordInBytes = 32;\n        return this.popBytes(wordInBytes);\n    };\n    RawCalldata.prototype.popWords = function (length) {\n        var wordInBytes = 32;\n        return this.popBytes(length * wordInBytes);\n    };\n    RawCalldata.prototype.readBytes = function (from, to) {\n        var value = this._value.slice(from, to);\n        return value;\n    };\n    RawCalldata.prototype.setOffset = function (offsetInBytes) {\n        this._offset = offsetInBytes;\n    };\n    RawCalldata.prototype.startScope = function () {\n        this._scopes.pushFront(this._offset);\n    };\n    RawCalldata.prototype.endScope = function () {\n        this._scopes.popFront();\n    };\n    RawCalldata.prototype.getOffset = function () {\n        return this._offset;\n    };\n    RawCalldata.prototype.toAbsoluteOffset = function (relativeOffset) {\n        var scopeOffset = this._scopes.peekFront();\n        if (scopeOffset === undefined) {\n            throw new Error(\"Tried to access undefined scope.\");\n        }\n        var absoluteOffset = relativeOffset + scopeOffset;\n        return absoluteOffset;\n    };\n    RawCalldata.prototype.getSelector = function () {\n        return this._selector;\n    };\n    RawCalldata.prototype.getSizeInBytes = function () {\n        var sizeInBytes = this._value.byteLength;\n        return sizeInBytes;\n    };\n    RawCalldata._INITIAL_OFFSET = 0;\n    return RawCalldata;\n}());\nexports.RawCalldata = RawCalldata;\n//# sourceMappingURL=raw_calldata.js.map"]},"metadata":{},"sourceType":"script"}