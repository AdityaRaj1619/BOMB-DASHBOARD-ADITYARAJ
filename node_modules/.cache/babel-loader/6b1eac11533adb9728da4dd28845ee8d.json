{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar ethers = require(\"ethers\");\nvar _ = require(\"lodash\");\nvar _1 = require(\".\");\nvar address_utils_1 = require(\"./address_utils\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n/**\n * AbiDecoder allows you to decode event logs given a set of supplied contract ABI's. It takes the contract's event\n * signature from the ABI and attempts to decode the logs using it.\n */\nvar AbiDecoder = /** @class */function () {\n  /**\n   * Instantiate an AbiDecoder\n   * @param abiArrays An array of contract ABI's\n   * @return AbiDecoder instance\n   */\n  function AbiDecoder(abiArrays) {\n    var _this = this;\n    this._eventIds = {};\n    this._selectorToFunctionInfo = {};\n    _.each(abiArrays, function (abi) {\n      _this.addABI(abi);\n    });\n  }\n  /**\n   * Retrieves the function selector from calldata.\n   * @param calldata hex-encoded calldata.\n   * @return hex-encoded function selector.\n   */\n  AbiDecoder._getFunctionSelector = function (calldata) {\n    var functionSelectorLength = 10;\n    if (!calldata.startsWith('0x') || calldata.length < functionSelectorLength) {\n      throw new Error(\"Malformed calldata. Must include a hex prefix '0x' and 4-byte function selector. Got '\" + calldata + \"'\");\n    }\n    var functionSelector = calldata.substr(0, functionSelectorLength);\n    return functionSelector;\n  };\n  /**\n   * Attempt to decode a log given the ABI's the AbiDecoder knows about.\n   * @param log The log to attempt to decode\n   * @return The decoded log if the requisite ABI was available. Otherwise the log unaltered.\n   */\n  AbiDecoder.prototype.tryToDecodeLogOrNoop = function (log) {\n    var eventId = log.topics[0];\n    var numIndexedArgs = log.topics.length - 1;\n    if (this._eventIds[eventId] === undefined || this._eventIds[eventId][numIndexedArgs] === undefined) {\n      return log;\n    }\n    var event = this._eventIds[eventId][numIndexedArgs];\n    var ethersInterface = new ethers.utils.Interface([event]);\n    var decodedParams = {};\n    var topicsIndex = 1;\n    var decodedData;\n    try {\n      decodedData = ethersInterface.events[event.name].decode(log.data);\n    } catch (error) {\n      if (error.code === ethers.errors.INVALID_ARGUMENT) {\n        // Because we index events by Method ID, and Method IDs are derived from the method\n        // name and the input parameters, it's possible that the return value of the event\n        // does not match our ABI. If that's the case, then ethers will throw an error\n        // when we try to parse the event. We handle that case here by returning the log rather\n        // than throwing an error.\n        return log;\n      }\n      throw error;\n    }\n    var didFailToDecode = false;\n    _.forEach(event.inputs, function (param, i) {\n      // Indexed parameters are stored in topics. Non-indexed ones in decodedData\n      var value = param.indexed ? log.topics[topicsIndex++] : decodedData[i];\n      if (value === undefined) {\n        didFailToDecode = true;\n        return;\n      }\n      if (param.type === ethereum_types_1.SolidityTypes.Address) {\n        var baseHex = 16;\n        value = address_utils_1.addressUtils.padZeros(new configured_bignumber_1.BigNumber(value.toLowerCase()).toString(baseHex));\n      } else if (param.type === ethereum_types_1.SolidityTypes.Uint256 || param.type === ethereum_types_1.SolidityTypes.Uint) {\n        value = new configured_bignumber_1.BigNumber(value);\n      } else if (param.type === ethereum_types_1.SolidityTypes.Uint8) {\n        value = new configured_bignumber_1.BigNumber(value).toNumber();\n      }\n      decodedParams[param.name] = value;\n    });\n    if (didFailToDecode) {\n      return log;\n    } else {\n      return __assign({}, log, {\n        event: event.name,\n        args: decodedParams\n      });\n    }\n  };\n  /**\n   * Decodes calldata for a known ABI.\n   * @param calldata hex-encoded calldata.\n   * @param contractName used to disambiguate similar ABI's (optional).\n   * @return Decoded calldata. Includes: function name and signature, along with the decoded arguments.\n   */\n  AbiDecoder.prototype.decodeCalldataOrThrow = function (calldata, contractName) {\n    var functionSelector = AbiDecoder._getFunctionSelector(calldata);\n    var candidateFunctionInfos = this._selectorToFunctionInfo[functionSelector];\n    if (candidateFunctionInfos === undefined) {\n      throw new Error(\"No functions registered for selector '\" + functionSelector + \"'\");\n    }\n    var functionInfo = _.find(candidateFunctionInfos, function (candidateFunctionInfo) {\n      return contractName === undefined || _.toLower(contractName) === _.toLower(candidateFunctionInfo.contractName);\n    });\n    if (functionInfo === undefined) {\n      throw new Error(\"No function registered with selector \" + functionSelector + \" and contract name \" + contractName + \".\");\n    } else if (functionInfo.abiEncoder === undefined) {\n      throw new Error(\"Function ABI Encoder is not defined, for function registered with selector \" + functionSelector + \" and contract name \" + contractName + \".\");\n    }\n    var functionName = functionInfo.abiEncoder.getDataItem().name;\n    var functionSignature = functionInfo.abiEncoder.getSignatureType();\n    var functionArguments = functionInfo.abiEncoder.decode(calldata);\n    var decodedCalldata = {\n      functionName: functionName,\n      functionSignature: functionSignature,\n      functionArguments: functionArguments\n    };\n    return decodedCalldata;\n  };\n  /**\n   * Adds a set of ABI definitions, after which calldata and logs targeting these ABI's can be decoded.\n   * Additional properties can be included to disambiguate similar ABI's. For example, if two functions\n   * have the same signature but different parameter names, then their ABI definitions can be disambiguated\n   * by specifying a contract name.\n   * @param abiDefinitions ABI definitions for a given contract.\n   * @param contractName Name of contract that encapsulates the ABI definitions (optional).\n   *                     This can be used when decoding calldata to disambiguate methods with\n   *                     the same signature but different parameter names.\n   */\n  AbiDecoder.prototype.addABI = function (abiArray, contractName) {\n    var _this = this;\n    if (abiArray === undefined) {\n      return;\n    }\n    var ethersInterface = new ethers.utils.Interface(abiArray);\n    _.map(abiArray, function (abi) {\n      switch (abi.type) {\n        case ethereum_types_1.AbiType.Event:\n          // tslint:disable-next-line:no-unnecessary-type-assertion\n          _this._addEventABI(abi, ethersInterface);\n          break;\n        case ethereum_types_1.AbiType.Function:\n          // tslint:disable-next-line:no-unnecessary-type-assertion\n          _this._addMethodABI(abi, contractName);\n          break;\n        default:\n          // ignore other types\n          break;\n      }\n    });\n  };\n  AbiDecoder.prototype._addEventABI = function (eventAbi, ethersInterface) {\n    var _a;\n    var topic = ethersInterface.events[eventAbi.name].topic;\n    var numIndexedArgs = _.reduce(eventAbi.inputs, function (sum, input) {\n      return input.indexed ? sum + 1 : sum;\n    }, 0);\n    this._eventIds[topic] = __assign({}, this._eventIds[topic], (_a = {}, _a[numIndexedArgs] = eventAbi, _a));\n  };\n  AbiDecoder.prototype._addMethodABI = function (methodAbi, contractName) {\n    var abiEncoder = new _1.AbiEncoder.Method(methodAbi);\n    var functionSelector = abiEncoder.getSelector();\n    if (!(functionSelector in this._selectorToFunctionInfo)) {\n      this._selectorToFunctionInfo[functionSelector] = [];\n    }\n    // Recored a copy of this ABI for each deployment\n    var functionSignature = abiEncoder.getSignature();\n    this._selectorToFunctionInfo[functionSelector].push({\n      functionSignature: functionSignature,\n      abiEncoder: abiEncoder,\n      contractName: contractName\n    });\n  };\n  return AbiDecoder;\n}();\nexports.AbiDecoder = AbiDecoder;","map":{"version":3,"sources":["../../src/abi_decoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar ethers = require(\"ethers\");\nvar _ = require(\"lodash\");\nvar _1 = require(\".\");\nvar address_utils_1 = require(\"./address_utils\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n/**\n * AbiDecoder allows you to decode event logs given a set of supplied contract ABI's. It takes the contract's event\n * signature from the ABI and attempts to decode the logs using it.\n */\nvar AbiDecoder = /** @class */ (function () {\n    /**\n     * Instantiate an AbiDecoder\n     * @param abiArrays An array of contract ABI's\n     * @return AbiDecoder instance\n     */\n    function AbiDecoder(abiArrays) {\n        var _this = this;\n        this._eventIds = {};\n        this._selectorToFunctionInfo = {};\n        _.each(abiArrays, function (abi) {\n            _this.addABI(abi);\n        });\n    }\n    /**\n     * Retrieves the function selector from calldata.\n     * @param calldata hex-encoded calldata.\n     * @return hex-encoded function selector.\n     */\n    AbiDecoder._getFunctionSelector = function (calldata) {\n        var functionSelectorLength = 10;\n        if (!calldata.startsWith('0x') || calldata.length < functionSelectorLength) {\n            throw new Error(\"Malformed calldata. Must include a hex prefix '0x' and 4-byte function selector. Got '\" + calldata + \"'\");\n        }\n        var functionSelector = calldata.substr(0, functionSelectorLength);\n        return functionSelector;\n    };\n    /**\n     * Attempt to decode a log given the ABI's the AbiDecoder knows about.\n     * @param log The log to attempt to decode\n     * @return The decoded log if the requisite ABI was available. Otherwise the log unaltered.\n     */\n    AbiDecoder.prototype.tryToDecodeLogOrNoop = function (log) {\n        var eventId = log.topics[0];\n        var numIndexedArgs = log.topics.length - 1;\n        if (this._eventIds[eventId] === undefined || this._eventIds[eventId][numIndexedArgs] === undefined) {\n            return log;\n        }\n        var event = this._eventIds[eventId][numIndexedArgs];\n        var ethersInterface = new ethers.utils.Interface([event]);\n        var decodedParams = {};\n        var topicsIndex = 1;\n        var decodedData;\n        try {\n            decodedData = ethersInterface.events[event.name].decode(log.data);\n        }\n        catch (error) {\n            if (error.code === ethers.errors.INVALID_ARGUMENT) {\n                // Because we index events by Method ID, and Method IDs are derived from the method\n                // name and the input parameters, it's possible that the return value of the event\n                // does not match our ABI. If that's the case, then ethers will throw an error\n                // when we try to parse the event. We handle that case here by returning the log rather\n                // than throwing an error.\n                return log;\n            }\n            throw error;\n        }\n        var didFailToDecode = false;\n        _.forEach(event.inputs, function (param, i) {\n            // Indexed parameters are stored in topics. Non-indexed ones in decodedData\n            var value = param.indexed ? log.topics[topicsIndex++] : decodedData[i];\n            if (value === undefined) {\n                didFailToDecode = true;\n                return;\n            }\n            if (param.type === ethereum_types_1.SolidityTypes.Address) {\n                var baseHex = 16;\n                value = address_utils_1.addressUtils.padZeros(new configured_bignumber_1.BigNumber(value.toLowerCase()).toString(baseHex));\n            }\n            else if (param.type === ethereum_types_1.SolidityTypes.Uint256 || param.type === ethereum_types_1.SolidityTypes.Uint) {\n                value = new configured_bignumber_1.BigNumber(value);\n            }\n            else if (param.type === ethereum_types_1.SolidityTypes.Uint8) {\n                value = new configured_bignumber_1.BigNumber(value).toNumber();\n            }\n            decodedParams[param.name] = value;\n        });\n        if (didFailToDecode) {\n            return log;\n        }\n        else {\n            return __assign({}, log, { event: event.name, args: decodedParams });\n        }\n    };\n    /**\n     * Decodes calldata for a known ABI.\n     * @param calldata hex-encoded calldata.\n     * @param contractName used to disambiguate similar ABI's (optional).\n     * @return Decoded calldata. Includes: function name and signature, along with the decoded arguments.\n     */\n    AbiDecoder.prototype.decodeCalldataOrThrow = function (calldata, contractName) {\n        var functionSelector = AbiDecoder._getFunctionSelector(calldata);\n        var candidateFunctionInfos = this._selectorToFunctionInfo[functionSelector];\n        if (candidateFunctionInfos === undefined) {\n            throw new Error(\"No functions registered for selector '\" + functionSelector + \"'\");\n        }\n        var functionInfo = _.find(candidateFunctionInfos, function (candidateFunctionInfo) {\n            return (contractName === undefined || _.toLower(contractName) === _.toLower(candidateFunctionInfo.contractName));\n        });\n        if (functionInfo === undefined) {\n            throw new Error(\"No function registered with selector \" + functionSelector + \" and contract name \" + contractName + \".\");\n        }\n        else if (functionInfo.abiEncoder === undefined) {\n            throw new Error(\"Function ABI Encoder is not defined, for function registered with selector \" + functionSelector + \" and contract name \" + contractName + \".\");\n        }\n        var functionName = functionInfo.abiEncoder.getDataItem().name;\n        var functionSignature = functionInfo.abiEncoder.getSignatureType();\n        var functionArguments = functionInfo.abiEncoder.decode(calldata);\n        var decodedCalldata = {\n            functionName: functionName,\n            functionSignature: functionSignature,\n            functionArguments: functionArguments,\n        };\n        return decodedCalldata;\n    };\n    /**\n     * Adds a set of ABI definitions, after which calldata and logs targeting these ABI's can be decoded.\n     * Additional properties can be included to disambiguate similar ABI's. For example, if two functions\n     * have the same signature but different parameter names, then their ABI definitions can be disambiguated\n     * by specifying a contract name.\n     * @param abiDefinitions ABI definitions for a given contract.\n     * @param contractName Name of contract that encapsulates the ABI definitions (optional).\n     *                     This can be used when decoding calldata to disambiguate methods with\n     *                     the same signature but different parameter names.\n     */\n    AbiDecoder.prototype.addABI = function (abiArray, contractName) {\n        var _this = this;\n        if (abiArray === undefined) {\n            return;\n        }\n        var ethersInterface = new ethers.utils.Interface(abiArray);\n        _.map(abiArray, function (abi) {\n            switch (abi.type) {\n                case ethereum_types_1.AbiType.Event:\n                    // tslint:disable-next-line:no-unnecessary-type-assertion\n                    _this._addEventABI(abi, ethersInterface);\n                    break;\n                case ethereum_types_1.AbiType.Function:\n                    // tslint:disable-next-line:no-unnecessary-type-assertion\n                    _this._addMethodABI(abi, contractName);\n                    break;\n                default:\n                    // ignore other types\n                    break;\n            }\n        });\n    };\n    AbiDecoder.prototype._addEventABI = function (eventAbi, ethersInterface) {\n        var _a;\n        var topic = ethersInterface.events[eventAbi.name].topic;\n        var numIndexedArgs = _.reduce(eventAbi.inputs, function (sum, input) { return (input.indexed ? sum + 1 : sum); }, 0);\n        this._eventIds[topic] = __assign({}, this._eventIds[topic], (_a = {}, _a[numIndexedArgs] = eventAbi, _a));\n    };\n    AbiDecoder.prototype._addMethodABI = function (methodAbi, contractName) {\n        var abiEncoder = new _1.AbiEncoder.Method(methodAbi);\n        var functionSelector = abiEncoder.getSelector();\n        if (!(functionSelector in this._selectorToFunctionInfo)) {\n            this._selectorToFunctionInfo[functionSelector] = [];\n        }\n        // Recored a copy of this ABI for each deployment\n        var functionSignature = abiEncoder.getSignature();\n        this._selectorToFunctionInfo[functionSelector].push({\n            functionSignature: functionSignature,\n            abiEncoder: abiEncoder,\n            contractName: contractName,\n        });\n    };\n    return AbiDecoder;\n}());\nexports.AbiDecoder = AbiDecoder;\n//# sourceMappingURL=abi_decoder.js.map"]},"metadata":{},"sourceType":"script"}