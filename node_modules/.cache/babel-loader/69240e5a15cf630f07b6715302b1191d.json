{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ethUtil = require(\"ethereumjs-util\");\nvar ethers = require(\"ethers\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\nexports.signTypedDataUtils = {\n  /**\n   * Generates the EIP712 Typed Data hash for signing\n   * @param   typedData An object that conforms to the EIP712TypedData interface\n   * @return  A Buffer containing the hash of the typed data.\n   */\n  generateTypedDataHash: function (typedData) {\n    return ethUtil.sha3(Buffer.concat([Buffer.from('1901', 'hex'), exports.signTypedDataUtils._structHash('EIP712Domain', typedData.domain, typedData.types), exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types)]));\n  },\n  _findDependencies: function (primaryType, types, found) {\n    if (found === void 0) {\n      found = [];\n    }\n    var e_1, _a, e_2, _b;\n    if (found.includes(primaryType) || types[primaryType] === undefined) {\n      return found;\n    }\n    found.push(primaryType);\n    try {\n      for (var _c = __values(types[primaryType]), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var field = _d.value;\n        try {\n          for (var _e = __values(exports.signTypedDataUtils._findDependencies(field.type, types, found)), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var dep = _f.value;\n            if (!found.includes(dep)) {\n              found.push(dep);\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return found;\n  },\n  _encodeType: function (primaryType, types) {\n    var e_3, _a;\n    var deps = exports.signTypedDataUtils._findDependencies(primaryType, types);\n    deps = deps.filter(function (d) {\n      return d !== primaryType;\n    });\n    deps = [primaryType].concat(deps.sort());\n    var result = '';\n    try {\n      for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {\n        var dep = deps_1_1.value;\n        result += dep + \"(\" + types[dep].map(function (_a) {\n          var name = _a.name,\n            type = _a.type;\n          return type + \" \" + name;\n        }).join(',') + \")\";\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    return result;\n  },\n  _encodeData: function (primaryType, data, types) {\n    var e_4, _a;\n    var encodedTypes = ['bytes32'];\n    var encodedValues = [exports.signTypedDataUtils._typeHash(primaryType, types)];\n    try {\n      for (var _b = __values(types[primaryType]), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var field = _c.value;\n        var value = data[field.name];\n        if (field.type === 'string' || field.type === 'bytes') {\n          var hashValue = ethUtil.sha3(value);\n          encodedTypes.push('bytes32');\n          encodedValues.push(hashValue);\n        } else if (types[field.type] !== undefined) {\n          encodedTypes.push('bytes32');\n          var hashValue = ethUtil.sha3(\n          // tslint:disable-next-line:no-unnecessary-type-assertion\n          exports.signTypedDataUtils._encodeData(field.type, value, types));\n          encodedValues.push(hashValue);\n        } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n          throw new Error('Arrays currently unimplemented in encodeData');\n        } else {\n          encodedTypes.push(field.type);\n          var normalizedValue = exports.signTypedDataUtils._normalizeValue(field.type, value);\n          encodedValues.push(normalizedValue);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n    return ethers.utils.defaultAbiCoder.encode(encodedTypes, encodedValues);\n  },\n  _normalizeValue: function (type, value) {\n    var normalizedValue = type === 'uint256' && configured_bignumber_1.BigNumber.isBigNumber(value) ? value.toString() : value;\n    return normalizedValue;\n  },\n  _typeHash: function (primaryType, types) {\n    return ethUtil.sha3(exports.signTypedDataUtils._encodeType(primaryType, types));\n  },\n  _structHash: function (primaryType, data, types) {\n    return ethUtil.sha3(exports.signTypedDataUtils._encodeData(primaryType, data, types));\n  }\n};","map":{"version":3,"sources":["../../src/sign_typed_data_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethUtil = require(\"ethereumjs-util\");\nvar ethers = require(\"ethers\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\nexports.signTypedDataUtils = {\n    /**\n     * Generates the EIP712 Typed Data hash for signing\n     * @param   typedData An object that conforms to the EIP712TypedData interface\n     * @return  A Buffer containing the hash of the typed data.\n     */\n    generateTypedDataHash: function (typedData) {\n        return ethUtil.sha3(Buffer.concat([\n            Buffer.from('1901', 'hex'),\n            exports.signTypedDataUtils._structHash('EIP712Domain', typedData.domain, typedData.types),\n            exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types),\n        ]));\n    },\n    _findDependencies: function (primaryType, types, found) {\n        if (found === void 0) { found = []; }\n        var e_1, _a, e_2, _b;\n        if (found.includes(primaryType) || types[primaryType] === undefined) {\n            return found;\n        }\n        found.push(primaryType);\n        try {\n            for (var _c = __values(types[primaryType]), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var field = _d.value;\n                try {\n                    for (var _e = __values(exports.signTypedDataUtils._findDependencies(field.type, types, found)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                        var dep = _f.value;\n                        if (!found.includes(dep)) {\n                            found.push(dep);\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return found;\n    },\n    _encodeType: function (primaryType, types) {\n        var e_3, _a;\n        var deps = exports.signTypedDataUtils._findDependencies(primaryType, types);\n        deps = deps.filter(function (d) { return d !== primaryType; });\n        deps = [primaryType].concat(deps.sort());\n        var result = '';\n        try {\n            for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {\n                var dep = deps_1_1.value;\n                result += dep + \"(\" + types[dep].map(function (_a) {\n                    var name = _a.name, type = _a.type;\n                    return type + \" \" + name;\n                }).join(',') + \")\";\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return result;\n    },\n    _encodeData: function (primaryType, data, types) {\n        var e_4, _a;\n        var encodedTypes = ['bytes32'];\n        var encodedValues = [exports.signTypedDataUtils._typeHash(primaryType, types)];\n        try {\n            for (var _b = __values(types[primaryType]), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var field = _c.value;\n                var value = data[field.name];\n                if (field.type === 'string' || field.type === 'bytes') {\n                    var hashValue = ethUtil.sha3(value);\n                    encodedTypes.push('bytes32');\n                    encodedValues.push(hashValue);\n                }\n                else if (types[field.type] !== undefined) {\n                    encodedTypes.push('bytes32');\n                    var hashValue = ethUtil.sha3(\n                    // tslint:disable-next-line:no-unnecessary-type-assertion\n                    exports.signTypedDataUtils._encodeData(field.type, value, types));\n                    encodedValues.push(hashValue);\n                }\n                else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n                    throw new Error('Arrays currently unimplemented in encodeData');\n                }\n                else {\n                    encodedTypes.push(field.type);\n                    var normalizedValue = exports.signTypedDataUtils._normalizeValue(field.type, value);\n                    encodedValues.push(normalizedValue);\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        return ethers.utils.defaultAbiCoder.encode(encodedTypes, encodedValues);\n    },\n    _normalizeValue: function (type, value) {\n        var normalizedValue = type === 'uint256' && configured_bignumber_1.BigNumber.isBigNumber(value) ? value.toString() : value;\n        return normalizedValue;\n    },\n    _typeHash: function (primaryType, types) {\n        return ethUtil.sha3(exports.signTypedDataUtils._encodeType(primaryType, types));\n    },\n    _structHash: function (primaryType, data, types) {\n        return ethUtil.sha3(exports.signTypedDataUtils._encodeData(primaryType, data, types));\n    },\n};\n//# sourceMappingURL=sign_typed_data_utils.js.map"]},"metadata":{},"sourceType":"script"}