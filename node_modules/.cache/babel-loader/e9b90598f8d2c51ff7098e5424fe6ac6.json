{"ast":null,"code":"import JSBI from 'jsbi';\nexport { default as JSBI } from 'jsbi';\nimport invariant from 'tiny-invariant';\nimport warning from 'tiny-warning';\nimport { getAddress, getCreate2Address } from '@ethersproject/address';\nimport _Big from 'big.js';\nimport toFormat from 'toformat';\nimport _Decimal from 'decimal.js-light';\nimport { keccak256, pack } from '@ethersproject/solidity';\nimport { Contract } from '@ethersproject/contracts';\nimport { getNetwork } from '@ethersproject/networks';\nimport { getDefaultProvider } from '@ethersproject/providers';\nvar _FACTORY_ADDRESS_MAP, _INIT_CODE_HASH_MAP, _SOLIDITY_TYPE_MAXIMA;\nvar ChainId;\n(function (ChainId) {\n  ChainId[ChainId[\"MAINNET\"] = 56] = \"MAINNET\";\n  ChainId[ChainId[\"TESTNET\"] = 97] = \"TESTNET\";\n})(ChainId || (ChainId = {}));\nvar TradeType;\n(function (TradeType) {\n  TradeType[TradeType[\"EXACT_INPUT\"] = 0] = \"EXACT_INPUT\";\n  TradeType[TradeType[\"EXACT_OUTPUT\"] = 1] = \"EXACT_OUTPUT\";\n})(TradeType || (TradeType = {}));\nvar Rounding;\n(function (Rounding) {\n  Rounding[Rounding[\"ROUND_DOWN\"] = 0] = \"ROUND_DOWN\";\n  Rounding[Rounding[\"ROUND_HALF_UP\"] = 1] = \"ROUND_HALF_UP\";\n  Rounding[Rounding[\"ROUND_UP\"] = 2] = \"ROUND_UP\";\n})(Rounding || (Rounding = {}));\nvar FACTORY_ADDRESS = '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73';\nvar FACTORY_ADDRESS_MAP = (_FACTORY_ADDRESS_MAP = {}, _FACTORY_ADDRESS_MAP[ChainId.MAINNET] = FACTORY_ADDRESS, _FACTORY_ADDRESS_MAP[ChainId.TESTNET] = '0x6725f303b657a9451d8ba641348b6761a6cc7a17', _FACTORY_ADDRESS_MAP);\nvar INIT_CODE_HASH = '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5';\nvar INIT_CODE_HASH_MAP = (_INIT_CODE_HASH_MAP = {}, _INIT_CODE_HASH_MAP[ChainId.MAINNET] = INIT_CODE_HASH, _INIT_CODE_HASH_MAP[ChainId.TESTNET] = '0xd0d4c4cd0848c93cb4fd1f498d7013ee6bfb25783ea21593d5834f5d250ece66', _INIT_CODE_HASH_MAP);\nvar MINIMUM_LIQUIDITY = /*#__PURE__*/JSBI.BigInt(1000); // exports for internal consumption\n\nvar ZERO = /*#__PURE__*/JSBI.BigInt(0);\nvar ONE = /*#__PURE__*/JSBI.BigInt(1);\nvar TWO = /*#__PURE__*/JSBI.BigInt(2);\nvar THREE = /*#__PURE__*/JSBI.BigInt(3);\nvar FIVE = /*#__PURE__*/JSBI.BigInt(5);\nvar TEN = /*#__PURE__*/JSBI.BigInt(10);\nvar _100 = /*#__PURE__*/JSBI.BigInt(100);\nvar FEES_NUMERATOR = /*#__PURE__*/JSBI.BigInt(9975);\nvar FEES_DENOMINATOR = /*#__PURE__*/JSBI.BigInt(10000);\nvar SolidityType;\n(function (SolidityType) {\n  SolidityType[\"uint8\"] = \"uint8\";\n  SolidityType[\"uint256\"] = \"uint256\";\n})(SolidityType || (SolidityType = {}));\nvar SOLIDITY_TYPE_MAXIMA = (_SOLIDITY_TYPE_MAXIMA = {}, _SOLIDITY_TYPE_MAXIMA[SolidityType.uint8] = /*#__PURE__*/JSBI.BigInt('0xff'), _SOLIDITY_TYPE_MAXIMA[SolidityType.uint256] = /*#__PURE__*/JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'), _SOLIDITY_TYPE_MAXIMA);\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\n// see https://stackoverflow.com/a/41102306\nvar CAN_SET_PROTOTYPE = ('setPrototypeOf' in Object);\n/**\r\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\r\n * obtained by sending any amount of input.\r\n */\n\nvar InsufficientReservesError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(InsufficientReservesError, _Error);\n  function InsufficientReservesError() {\n    var _this;\n    _this = _Error.call(this) || this;\n    _this.isInsufficientReservesError = true;\n    _this.name = _this.constructor.name;\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof InsufficientReservesError ? this.constructor : void 0).prototype);\n    return _this;\n  }\n  return InsufficientReservesError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\r\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\r\n * than the price of a single unit of output after fees.\r\n */\n\nvar InsufficientInputAmountError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(InsufficientInputAmountError, _Error2);\n  function InsufficientInputAmountError() {\n    var _this2;\n    _this2 = _Error2.call(this) || this;\n    _this2.isInsufficientInputAmountError = true;\n    _this2.name = _this2.constructor.name;\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(_assertThisInitialized(_this2), (this instanceof InsufficientInputAmountError ? this.constructor : void 0).prototype);\n    return _this2;\n  }\n  return InsufficientInputAmountError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nfunction validateSolidityTypeInstance(value, solidityType) {\n  !JSBI.greaterThanOrEqual(value, ZERO) ? process.env.NODE_ENV !== \"production\" ? invariant(false, value + \" is not a \" + solidityType + \".\") : invariant(false) : void 0;\n  !JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]) ? process.env.NODE_ENV !== \"production\" ? invariant(false, value + \" is not a \" + solidityType + \".\") : invariant(false) : void 0;\n} // warns if addresses are not checksummed\n\nfunction validateAndParseAddress(address) {\n  try {\n    var checksummedAddress = getAddress(address);\n    process.env.NODE_ENV !== \"production\" ? warning(address === checksummedAddress, address + \" is not checksummed.\") : void 0;\n    return checksummedAddress;\n  } catch (error) {\n    process.env.NODE_ENV !== \"production\" ? invariant(false, address + \" is not a valid address.\") : invariant(false);\n  }\n}\nfunction parseBigintIsh(bigintIsh) {\n  return bigintIsh instanceof JSBI ? bigintIsh : JSBI.BigInt(bigintIsh);\n} // mock the on-chain sqrt function\n\nfunction sqrt(y) {\n  validateSolidityTypeInstance(y, SolidityType.uint256);\n  var z = ZERO;\n  var x;\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y;\n    x = JSBI.add(JSBI.divide(y, TWO), ONE);\n    while (JSBI.lessThan(x, z)) {\n      z = x;\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO);\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE;\n  }\n  return z;\n} // given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\n\nfunction sortedInsert(items, add, maxSize, comparator) {\n  !(maxSize > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MAX_SIZE_ZERO') : invariant(false) : void 0; // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n\n  !(items.length <= maxSize) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ITEMS_SIZE') : invariant(false) : void 0; // short circuit first item add\n\n  if (items.length === 0) {\n    items.push(add);\n    return null;\n  } else {\n    var isFull = items.length === maxSize; // short circuit if full and the additional item does not come before the last item\n\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add;\n    }\n    var lo = 0,\n      hi = items.length;\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    items.splice(lo, 0, add);\n    return isFull ? items.pop() : null;\n  }\n}\n\n/**\r\n * A currency is any fungible financial instrument on Ethereum, including Ether and all ERC20 tokens.\r\n *\r\n * The only instance of the base class `Currency` is Ether.\r\n */\n\nvar Currency =\n/**\r\n * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.ETHER`.\r\n * @param decimals decimals of the currency\r\n * @param symbol symbol of the currency\r\n * @param name of the currency\r\n */\nfunction Currency(decimals, symbol, name) {\n  validateSolidityTypeInstance(JSBI.BigInt(decimals), SolidityType.uint8);\n  this.decimals = decimals;\n  this.symbol = symbol;\n  this.name = name;\n};\n/**\r\n * The only instance of the base class `Currency`.\r\n */\n\nCurrency.ETHER = /*#__PURE__*/new Currency(18, 'BNB', 'BNB');\nvar ETHER = Currency.ETHER;\nvar _WETH;\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\n\nvar Token = /*#__PURE__*/function (_Currency) {\n  _inheritsLoose(Token, _Currency);\n  function Token(chainId, address, decimals, symbol, name, projectLink) {\n    var _this;\n    _this = _Currency.call(this, decimals, symbol, name) || this;\n    _this.chainId = chainId;\n    _this.address = validateAndParseAddress(address);\n    _this.projectLink = projectLink;\n    return _this;\n  }\n  /**\r\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n   * @param other other token to compare\r\n   */\n\n  var _proto = Token.prototype;\n  _proto.equals = function equals(other) {\n    // short circuit on reference equality\n    if (this === other) {\n      return true;\n    }\n    return this.chainId === other.chainId && this.address === other.address;\n  }\n  /**\r\n   * Returns true if the address of this token sorts before the address of the other token\r\n   * @param other other token to compare\r\n   * @throws if the tokens have the same address\r\n   * @throws if the tokens are on different chains\r\n   */;\n\n  _proto.sortsBefore = function sortsBefore(other) {\n    !(this.chainId === other.chainId) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_IDS') : invariant(false) : void 0;\n    !(this.address !== other.address) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ADDRESSES') : invariant(false) : void 0;\n    return this.address.toLowerCase() < other.address.toLowerCase();\n  };\n  return Token;\n}(Currency);\n/**\r\n * Compares two currencies for equality\r\n */\n\nfunction currencyEquals(currencyA, currencyB) {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB);\n  } else if (currencyA instanceof Token) {\n    return false;\n  } else if (currencyB instanceof Token) {\n    return false;\n  } else {\n    return currencyA === currencyB;\n  }\n}\nvar WETH = (_WETH = {}, _WETH[ChainId.MAINNET] = /*#__PURE__*/new Token(ChainId.MAINNET, '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', 18, 'WBNB', 'Wrapped BNB', 'https://www.binance.org'), _WETH[ChainId.TESTNET] = /*#__PURE__*/new Token(ChainId.TESTNET, '0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd', 18, 'WBNB', 'Wrapped BNB', 'https://www.binance.org'), _WETH);\nvar _toSignificantRoundin, _toFixedRounding;\nvar Decimal = /*#__PURE__*/toFormat(_Decimal);\nvar Big = /*#__PURE__*/toFormat(_Big);\nvar toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);\nvar toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);\nvar Fraction = /*#__PURE__*/function () {\n  function Fraction(numerator, denominator) {\n    if (denominator === void 0) {\n      denominator = ONE;\n    }\n    this.numerator = parseBigintIsh(numerator);\n    this.denominator = parseBigintIsh(denominator);\n  } // performs floor division\n\n  var _proto = Fraction.prototype;\n  _proto.invert = function invert() {\n    return new Fraction(this.denominator, this.numerator);\n  };\n  _proto.add = function add(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);\n    }\n    return new Fraction(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));\n  };\n  _proto.subtract = function subtract(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);\n    }\n    return new Fraction(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));\n  };\n  _proto.lessThan = function lessThan(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));\n  };\n  _proto.equalTo = function equalTo(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));\n  };\n  _proto.greaterThan = function greaterThan(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));\n  };\n  _proto.multiply = function multiply(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    return new Fraction(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));\n  };\n  _proto.divide = function divide(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    return new Fraction(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));\n  };\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n    !Number.isInteger(significantDigits) ? process.env.NODE_ENV !== \"production\" ? invariant(false, significantDigits + \" is not an integer.\") : invariant(false) : void 0;\n    !(significantDigits > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, significantDigits + \" is not positive.\") : invariant(false) : void 0;\n    Decimal.set({\n      precision: significantDigits + 1,\n      rounding: toSignificantRounding[rounding]\n    });\n    var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);\n    return quotient.toFormat(quotient.decimalPlaces(), format);\n  };\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n    !Number.isInteger(decimalPlaces) ? process.env.NODE_ENV !== \"production\" ? invariant(false, decimalPlaces + \" is not an integer.\") : invariant(false) : void 0;\n    !(decimalPlaces >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, decimalPlaces + \" is negative.\") : invariant(false) : void 0;\n    Big.DP = decimalPlaces;\n    Big.RM = toFixedRounding[rounding];\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);\n  }\n  /**\r\n   * Helper method for converting any super class back to a fraction\r\n   */;\n\n  _createClass(Fraction, [{\n    key: \"quotient\",\n    get: function get() {\n      return JSBI.divide(this.numerator, this.denominator);\n    } // remainder after floor division\n  }, {\n    key: \"remainder\",\n    get: function get() {\n      return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator);\n    }\n  }, {\n    key: \"asFraction\",\n    get: function get() {\n      return new Fraction(this.numerator, this.denominator);\n    }\n  }]);\n  return Fraction;\n}();\nvar Big$1 = /*#__PURE__*/toFormat(_Big);\nvar CurrencyAmount = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(CurrencyAmount, _Fraction);\n\n  // amount _must_ be raw, i.e. in the native representation\n  function CurrencyAmount(currency, amount) {\n    var _this;\n    var parsedAmount = parseBigintIsh(amount);\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256);\n    _this = _Fraction.call(this, parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(currency.decimals))) || this;\n    _this.currency = currency;\n    return _this;\n  }\n  /**\r\n   * Helper that calls the constructor with the ETHER currency\r\n   * @param amount ether amount in wei\r\n   */\n\n  CurrencyAmount.ether = function ether(amount) {\n    return new CurrencyAmount(ETHER, amount);\n  };\n  var _proto = CurrencyAmount.prototype;\n  _proto.add = function add(other) {\n    !currencyEquals(this.currency, other.currency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return new CurrencyAmount(this.currency, JSBI.add(this.raw, other.raw));\n  };\n  _proto.subtract = function subtract(other) {\n    !currencyEquals(this.currency, other.currency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return new CurrencyAmount(this.currency, JSBI.subtract(this.raw, other.raw));\n  };\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n    return _Fraction.prototype.toSignificant.call(this, significantDigits, format, rounding);\n  };\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = this.currency.decimals;\n    }\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n    !(decimalPlaces <= this.currency.decimals) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DECIMALS') : invariant(false) : void 0;\n    return _Fraction.prototype.toFixed.call(this, decimalPlaces, format, rounding);\n  };\n  _proto.toExact = function toExact(format) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n    Big$1.DP = this.currency.decimals;\n    return new Big$1(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);\n  };\n  _createClass(CurrencyAmount, [{\n    key: \"raw\",\n    get: function get() {\n      return this.numerator;\n    }\n  }]);\n  return CurrencyAmount;\n}(Fraction);\nvar TokenAmount = /*#__PURE__*/function (_CurrencyAmount) {\n  _inheritsLoose(TokenAmount, _CurrencyAmount);\n\n  // amount _must_ be raw, i.e. in the native representation\n  function TokenAmount(token, amount) {\n    var _this;\n    _this = _CurrencyAmount.call(this, token, amount) || this;\n    _this.token = token;\n    return _this;\n  }\n  var _proto = TokenAmount.prototype;\n  _proto.add = function add(other) {\n    !this.token.equals(other.token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return new TokenAmount(this.token, JSBI.add(this.raw, other.raw));\n  };\n  _proto.subtract = function subtract(other) {\n    !this.token.equals(other.token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return new TokenAmount(this.token, JSBI.subtract(this.raw, other.raw));\n  };\n  return TokenAmount;\n}(CurrencyAmount);\nvar Price = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Price, _Fraction);\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  function Price(baseCurrency, quoteCurrency, denominator, numerator) {\n    var _this;\n    _this = _Fraction.call(this, numerator, denominator) || this;\n    _this.baseCurrency = baseCurrency;\n    _this.quoteCurrency = quoteCurrency;\n    _this.scalar = new Fraction(JSBI.exponentiate(TEN, JSBI.BigInt(baseCurrency.decimals)), JSBI.exponentiate(TEN, JSBI.BigInt(quoteCurrency.decimals)));\n    return _this;\n  }\n  Price.fromRoute = function fromRoute(route) {\n    var prices = [];\n    for (var _iterator = _createForOfIteratorHelperLoose(route.pairs.entries()), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n        i = _step$value[0],\n        pair = _step$value[1];\n      prices.push(route.path[i].equals(pair.token0) ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.raw, pair.reserve1.raw) : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.raw, pair.reserve0.raw));\n    }\n    return prices.slice(1).reduce(function (accumulator, currentValue) {\n      return accumulator.multiply(currentValue);\n    }, prices[0]);\n  };\n  var _proto = Price.prototype;\n  _proto.invert = function invert() {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);\n  };\n  _proto.multiply = function multiply(other) {\n    !currencyEquals(this.quoteCurrency, other.baseCurrency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    var fraction = _Fraction.prototype.multiply.call(this, other);\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);\n  } // performs floor division on overflow\n  ;\n\n  _proto.quote = function quote(currencyAmount) {\n    !currencyEquals(currencyAmount.currency, this.baseCurrency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    if (this.quoteCurrency instanceof Token) {\n      return new TokenAmount(this.quoteCurrency, _Fraction.prototype.multiply.call(this, currencyAmount.raw).quotient);\n    }\n    return CurrencyAmount.ether(_Fraction.prototype.multiply.call(this, currencyAmount.raw).quotient);\n  };\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n    return this.adjusted.toSignificant(significantDigits, format, rounding);\n  };\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 4;\n    }\n    return this.adjusted.toFixed(decimalPlaces, format, rounding);\n  };\n  _createClass(Price, [{\n    key: \"raw\",\n    get: function get() {\n      return new Fraction(this.numerator, this.denominator);\n    }\n  }, {\n    key: \"adjusted\",\n    get: function get() {\n      return _Fraction.prototype.multiply.call(this, this.scalar);\n    }\n  }]);\n  return Price;\n}(Fraction);\nvar PAIR_ADDRESS_CACHE = {};\nvar composeKey = function composeKey(token0, token1) {\n  return token0.chainId + \"-\" + token0.address + \"-\" + token1.address;\n};\nvar Pair = /*#__PURE__*/function () {\n  function Pair(tokenAmountA, tokenAmountB) {\n    var tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n    ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    this.liquidityToken = new Token(tokenAmounts[0].token.chainId, Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token), 18, 'Cake-LP', 'Pancake LPs');\n    this.tokenAmounts = tokenAmounts;\n  }\n  Pair.getAddress = function getAddress(tokenA, tokenB) {\n    var _PAIR_ADDRESS_CACHE;\n    var _ref = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA],\n      token0 = _ref[0],\n      token1 = _ref[1]; // does safety checks\n\n    var key = composeKey(token0, token1);\n    if (((_PAIR_ADDRESS_CACHE = PAIR_ADDRESS_CACHE) === null || _PAIR_ADDRESS_CACHE === void 0 ? void 0 : _PAIR_ADDRESS_CACHE[key]) === undefined) {\n      var _extends2;\n      PAIR_ADDRESS_CACHE = _extends({}, PAIR_ADDRESS_CACHE, (_extends2 = {}, _extends2[key] = getCreate2Address(FACTORY_ADDRESS_MAP[token0.chainId], keccak256(['bytes'], [pack(['address', 'address'], [token0.address, token1.address])]), INIT_CODE_HASH_MAP[token0.chainId]), _extends2));\n    }\n    return PAIR_ADDRESS_CACHE[key];\n  }\n  /**\r\n   * Returns true if the token is either token0 or token1\r\n   * @param token to check\r\n   */;\n\n  var _proto = Pair.prototype;\n  _proto.involvesToken = function involvesToken(token) {\n    return token.equals(this.token0) || token.equals(this.token1);\n  }\n  /**\r\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\r\n   */;\n\n  /**\r\n   * Return the price of the given token in terms of the other token in the pair.\r\n   * @param token token to return price of\r\n   */\n  _proto.priceOf = function priceOf(token) {\n    !this.involvesToken(token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return token.equals(this.token0) ? this.token0Price : this.token1Price;\n  }\n  /**\r\n   * Returns the chain ID of the tokens in the pair.\r\n   */;\n\n  _proto.reserveOf = function reserveOf(token) {\n    !this.involvesToken(token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1;\n  };\n  _proto.getOutputAmount = function getOutputAmount(inputAmount) {\n    !this.involvesToken(inputAmount.token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError();\n    }\n    var inputReserve = this.reserveOf(inputAmount.token);\n    var outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0);\n    var inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR);\n    var numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw);\n    var denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee);\n    var outputAmount = new TokenAmount(inputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.divide(numerator, denominator));\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  };\n  _proto.getInputAmount = function getInputAmount(outputAmount) {\n    !this.involvesToken(outputAmount.token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO) || JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)) {\n      throw new InsufficientReservesError();\n    }\n    var outputReserve = this.reserveOf(outputAmount.token);\n    var inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0);\n    var numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR);\n    var denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR);\n    var inputAmount = new TokenAmount(outputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.add(JSBI.divide(numerator, denominator), ONE));\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  };\n  _proto.getLiquidityMinted = function getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {\n    !totalSupply.token.equals(this.liquidityToken) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LIQUIDITY') : invariant(false) : void 0;\n    var tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n    ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    !(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    var liquidity;\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY);\n    } else {\n      var amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw);\n      var amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw);\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n    return new TokenAmount(this.liquidityToken, liquidity);\n  };\n  _proto.getLiquidityValue = function getLiquidityValue(token, totalSupply, liquidity, feeOn, kLast) {\n    if (feeOn === void 0) {\n      feeOn = false;\n    }\n    !this.involvesToken(token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    !totalSupply.token.equals(this.liquidityToken) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOTAL_SUPPLY') : invariant(false) : void 0;\n    !liquidity.token.equals(this.liquidityToken) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LIQUIDITY') : invariant(false) : void 0;\n    !JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LIQUIDITY') : invariant(false) : void 0;\n    var totalSupplyAdjusted;\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply;\n    } else {\n      !!!kLast ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'K_LAST') : invariant(false) : void 0;\n      var kLastParsed = parseBigintIsh(kLast);\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        var rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw));\n        var rootKLast = sqrt(kLastParsed);\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          var numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast));\n          var denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast);\n          var feeLiquidity = JSBI.divide(numerator, denominator);\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity));\n        } else {\n          totalSupplyAdjusted = totalSupply;\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply;\n      }\n    }\n    return new TokenAmount(token, JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw));\n  };\n  _createClass(Pair, [{\n    key: \"token0Price\",\n    get: function get() {\n      return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw);\n    }\n    /**\r\n     * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\r\n     */\n  }, {\n    key: \"token1Price\",\n    get: function get() {\n      return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw);\n    }\n  }, {\n    key: \"chainId\",\n    get: function get() {\n      return this.token0.chainId;\n    }\n  }, {\n    key: \"token0\",\n    get: function get() {\n      return this.tokenAmounts[0].token;\n    }\n  }, {\n    key: \"token1\",\n    get: function get() {\n      return this.tokenAmounts[1].token;\n    }\n  }, {\n    key: \"reserve0\",\n    get: function get() {\n      return this.tokenAmounts[0];\n    }\n  }, {\n    key: \"reserve1\",\n    get: function get() {\n      return this.tokenAmounts[1];\n    }\n  }]);\n  return Pair;\n}();\nvar Route = /*#__PURE__*/function () {\n  function Route(pairs, input, output) {\n    !(pairs.length > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'PAIRS') : invariant(false) : void 0;\n    !pairs.every(function (pair) {\n      return pair.chainId === pairs[0].chainId;\n    }) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_IDS') : invariant(false) : void 0;\n    !(input instanceof Token && pairs[0].involvesToken(input) || input === ETHER && pairs[0].involvesToken(WETH[pairs[0].chainId])) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INPUT') : invariant(false) : void 0;\n    !(typeof output === 'undefined' || output instanceof Token && pairs[pairs.length - 1].involvesToken(output) || output === ETHER && pairs[pairs.length - 1].involvesToken(WETH[pairs[0].chainId])) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OUTPUT') : invariant(false) : void 0;\n    var path = [input instanceof Token ? input : WETH[pairs[0].chainId]];\n    for (var _iterator = _createForOfIteratorHelperLoose(pairs.entries()), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n        i = _step$value[0],\n        pair = _step$value[1];\n      var currentInput = path[i];\n      !(currentInput.equals(pair.token0) || currentInput.equals(pair.token1)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'PATH') : invariant(false) : void 0;\n      var _output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;\n      path.push(_output);\n    }\n    this.pairs = pairs;\n    this.path = path;\n    this.midPrice = Price.fromRoute(this);\n    this.input = input;\n    this.output = output !== null && output !== void 0 ? output : path[path.length - 1];\n  }\n  _createClass(Route, [{\n    key: \"chainId\",\n    get: function get() {\n      return this.pairs[0].chainId;\n    }\n  }]);\n  return Route;\n}();\nvar _100_PERCENT = /*#__PURE__*/new Fraction(_100);\nvar Percent = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Percent, _Fraction);\n  function Percent() {\n    return _Fraction.apply(this, arguments) || this;\n  }\n  var _proto = Percent.prototype;\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 5;\n    }\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding);\n  };\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 2;\n    }\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding);\n  };\n  return Percent;\n}(Fraction);\n\n/**\r\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\r\n * @param midPrice mid price before the trade\r\n * @param inputAmount the input amount of the trade\r\n * @param outputAmount the output amount of the trade\r\n */\n\nfunction computePriceImpact(midPrice, inputAmount, outputAmount) {\n  var exactQuote = midPrice.raw.multiply(inputAmount.raw); // calculate slippage := (exactQuote - outputAmount) / exactQuote\n\n  var slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote);\n  return new Percent(slippage.numerator, slippage.denominator);\n} // comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\n\nfunction inputOutputComparator(a, b) {\n  // must have same input and output token for comparison\n  !currencyEquals(a.inputAmount.currency, b.inputAmount.currency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INPUT_CURRENCY') : invariant(false) : void 0;\n  !currencyEquals(a.outputAmount.currency, b.outputAmount.currency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OUTPUT_CURRENCY') : invariant(false) : void 0;\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0;\n    } // trade A requires less input than trade B, so A should come first\n\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n} // extension of the input output comparator that also considers other dimensions of the trade in ranking them\n\nfunction tradeComparator(a, b) {\n  var ioComp = inputOutputComparator(a, b);\n  if (ioComp !== 0) {\n    return ioComp;\n  } // consider lowest slippage next, since these are less likely to fail\n\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1;\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1;\n  } // finally consider the number of hops since each hop costs gas\n\n  return a.route.path.length - b.route.path.length;\n}\n/**\r\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\r\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\r\n * the input currency amount.\r\n */\n\nfunction wrappedAmount(currencyAmount, chainId) {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount;\n  if (currencyAmount.currency === ETHER) return new TokenAmount(WETH[chainId], currencyAmount.raw);\n  process.env.NODE_ENV !== \"production\" ? invariant(false, 'CURRENCY') : invariant(false);\n}\nfunction wrappedCurrency(currency, chainId) {\n  if (currency instanceof Token) return currency;\n  if (currency === ETHER) return WETH[chainId];\n  process.env.NODE_ENV !== \"production\" ? invariant(false, 'CURRENCY') : invariant(false);\n}\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\n\nvar Trade = /*#__PURE__*/function () {\n  function Trade(route, amount, tradeType) {\n    var amounts = new Array(route.path.length);\n    var nextPairs = new Array(route.pairs.length);\n    if (tradeType === TradeType.EXACT_INPUT) {\n      !currencyEquals(amount.currency, route.input) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INPUT') : invariant(false) : void 0;\n      amounts[0] = wrappedAmount(amount, route.chainId);\n      for (var i = 0; i < route.path.length - 1; i++) {\n        var pair = route.pairs[i];\n        var _pair$getOutputAmount = pair.getOutputAmount(amounts[i]),\n          outputAmount = _pair$getOutputAmount[0],\n          nextPair = _pair$getOutputAmount[1];\n        amounts[i + 1] = outputAmount;\n        nextPairs[i] = nextPair;\n      }\n    } else {\n      !currencyEquals(amount.currency, route.output) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OUTPUT') : invariant(false) : void 0;\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId);\n      for (var _i = route.path.length - 1; _i > 0; _i--) {\n        var _pair = route.pairs[_i - 1];\n        var _pair$getInputAmount = _pair.getInputAmount(amounts[_i]),\n          inputAmount = _pair$getInputAmount[0],\n          _nextPair = _pair$getInputAmount[1];\n        amounts[_i - 1] = inputAmount;\n        nextPairs[_i - 1] = _nextPair;\n      }\n    }\n    this.route = route;\n    this.tradeType = tradeType;\n    this.inputAmount = tradeType === TradeType.EXACT_INPUT ? amount : route.input === ETHER ? CurrencyAmount.ether(amounts[0].raw) : amounts[0];\n    this.outputAmount = tradeType === TradeType.EXACT_OUTPUT ? amount : route.output === ETHER ? CurrencyAmount.ether(amounts[amounts.length - 1].raw) : amounts[amounts.length - 1];\n    this.executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.raw, this.outputAmount.raw);\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input));\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);\n  }\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\n\n  Trade.exactIn = function exactIn(route, amountIn) {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT);\n  }\n  /**\r\n   * Constructs an exact out trade with the given amount out and route\r\n   * @param route route of the exact out trade\r\n   * @param amountOut the amount returned by the trade\r\n   */;\n\n  Trade.exactOut = function exactOut(route, amountOut) {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT);\n  }\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */;\n\n  var _proto = Trade.prototype;\n  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance) {\n    !!slippageTolerance.lessThan(ZERO) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'SLIPPAGE_TOLERANCE') : invariant(false) : void 0;\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount;\n    } else {\n      var slippageAdjustedAmountOut = new Fraction(ONE).add(slippageTolerance).invert().multiply(this.outputAmount.raw).quotient;\n      return this.outputAmount instanceof TokenAmount ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut) : CurrencyAmount.ether(slippageAdjustedAmountOut);\n    }\n  }\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */;\n\n  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance) {\n    !!slippageTolerance.lessThan(ZERO) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'SLIPPAGE_TOLERANCE') : invariant(false) : void 0;\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount;\n    } else {\n      var slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient;\n      return this.inputAmount instanceof TokenAmount ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn) : CurrencyAmount.ether(slippageAdjustedAmountIn);\n    }\n  }\n  /**\r\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n   * amount to an output token, making at most `maxHops` hops.\r\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyAmountIn exact amount of input currency to spend\r\n   * @param currencyOut the desired currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */;\n\n  Trade.bestTradeExactIn = function bestTradeExactIn(pairs, currencyAmountIn, currencyOut, _temp,\n  // used in recursion.\n  currentPairs, originalAmountIn, bestTrades) {\n    var _ref = _temp === void 0 ? {} : _temp,\n      _ref$maxNumResults = _ref.maxNumResults,\n      maxNumResults = _ref$maxNumResults === void 0 ? 3 : _ref$maxNumResults,\n      _ref$maxHops = _ref.maxHops,\n      maxHops = _ref$maxHops === void 0 ? 3 : _ref$maxHops;\n    if (currentPairs === void 0) {\n      currentPairs = [];\n    }\n    if (originalAmountIn === void 0) {\n      originalAmountIn = currencyAmountIn;\n    }\n    if (bestTrades === void 0) {\n      bestTrades = [];\n    }\n    !(pairs.length > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'PAIRS') : invariant(false) : void 0;\n    !(maxHops > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MAX_HOPS') : invariant(false) : void 0;\n    !(originalAmountIn === currencyAmountIn || currentPairs.length > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INVALID_RECURSION') : invariant(false) : void 0;\n    var chainId = currencyAmountIn instanceof TokenAmount ? currencyAmountIn.token.chainId : currencyOut instanceof Token ? currencyOut.chainId : undefined;\n    !(chainId !== undefined) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_ID') : invariant(false) : void 0;\n    var amountIn = wrappedAmount(currencyAmountIn, chainId);\n    var tokenOut = wrappedCurrency(currencyOut, chainId);\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i]; // pair irrelevant\n\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      var amountOut = void 0;\n      try {\n        ;\n        var _pair$getOutputAmount2 = pair.getOutputAmount(amountIn);\n        amountOut = _pair$getOutputAmount2[0];\n      } catch (error) {\n        // input too low\n        if (error.isInsufficientInputAmountError) {\n          continue;\n        }\n        throw error;\n      } // we have arrived at the output token, so this is the final trade of one of the paths\n\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(bestTrades, new Trade(new Route([].concat(currentPairs, [pair]), originalAmountIn.currency, currencyOut), originalAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length)); // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n\n        Trade.bestTradeExactIn(pairsExcludingThisPair, amountOut, currencyOut, {\n          maxNumResults: maxNumResults,\n          maxHops: maxHops - 1\n        }, [].concat(currentPairs, [pair]), originalAmountIn, bestTrades);\n      }\n    }\n    return bestTrades;\n  }\n  /**\r\n   * similar to the above method but instead targets a fixed output amount\r\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n   * to an output token amount, making at most `maxHops` hops\r\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyIn the currency to spend\r\n   * @param currencyAmountOut the exact amount of currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */;\n\n  Trade.bestTradeExactOut = function bestTradeExactOut(pairs, currencyIn, currencyAmountOut, _temp2,\n  // used in recursion.\n  currentPairs, originalAmountOut, bestTrades) {\n    var _ref2 = _temp2 === void 0 ? {} : _temp2,\n      _ref2$maxNumResults = _ref2.maxNumResults,\n      maxNumResults = _ref2$maxNumResults === void 0 ? 3 : _ref2$maxNumResults,\n      _ref2$maxHops = _ref2.maxHops,\n      maxHops = _ref2$maxHops === void 0 ? 3 : _ref2$maxHops;\n    if (currentPairs === void 0) {\n      currentPairs = [];\n    }\n    if (originalAmountOut === void 0) {\n      originalAmountOut = currencyAmountOut;\n    }\n    if (bestTrades === void 0) {\n      bestTrades = [];\n    }\n    !(pairs.length > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'PAIRS') : invariant(false) : void 0;\n    !(maxHops > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MAX_HOPS') : invariant(false) : void 0;\n    !(originalAmountOut === currencyAmountOut || currentPairs.length > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INVALID_RECURSION') : invariant(false) : void 0;\n    var chainId = currencyAmountOut instanceof TokenAmount ? currencyAmountOut.token.chainId : currencyIn instanceof Token ? currencyIn.chainId : undefined;\n    !(chainId !== undefined) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_ID') : invariant(false) : void 0;\n    var amountOut = wrappedAmount(currencyAmountOut, chainId);\n    var tokenIn = wrappedCurrency(currencyIn, chainId);\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i]; // pair irrelevant\n\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      var amountIn = void 0;\n      try {\n        ;\n        var _pair$getInputAmount2 = pair.getInputAmount(amountOut);\n        amountIn = _pair$getInputAmount2[0];\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (error.isInsufficientReservesError) {\n          continue;\n        }\n        throw error;\n      } // we have arrived at the input token, so this is the first trade of one of the paths\n\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(bestTrades, new Trade(new Route([pair].concat(currentPairs), currencyIn, originalAmountOut.currency), originalAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length)); // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n\n        Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, amountIn, {\n          maxNumResults: maxNumResults,\n          maxHops: maxHops - 1\n        }, [pair].concat(currentPairs), originalAmountOut, bestTrades);\n      }\n    }\n    return bestTrades;\n  };\n  return Trade;\n}();\nfunction toHex(currencyAmount) {\n  return \"0x\" + currencyAmount.raw.toString(16);\n}\nvar ZERO_HEX = '0x0';\n/**\r\n * Represents the Pancake Router, and has static methods for helping execute trades.\r\n */\n\nvar Router = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function Router() {}\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trade to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */\n\n  Router.swapCallParameters = function swapCallParameters(trade, options) {\n    var etherIn = trade.inputAmount.currency === ETHER;\n    var etherOut = trade.outputAmount.currency === ETHER; // the router does not support both ether in and out\n\n    !!(etherIn && etherOut) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ETHER_IN_OUT') : invariant(false) : void 0;\n    !(!('ttl' in options) || options.ttl > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TTL') : invariant(false) : void 0;\n    var to = validateAndParseAddress(options.recipient);\n    var amountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));\n    var amountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));\n    var path = trade.route.path.map(function (token) {\n      return token.address;\n    });\n    var deadline = 'ttl' in options ? \"0x\" + (Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16) : \"0x\" + options.deadline.toString(16);\n    var useFeeOnTransfer = Boolean(options.feeOnTransfer);\n    var methodName;\n    var args;\n    var value;\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'; // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'; // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens' : 'swapExactTokensForTokens'; // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        }\n        break;\n      case TradeType.EXACT_OUTPUT:\n        !!useFeeOnTransfer ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'EXACT_OUT_FOT') : invariant(false) : void 0;\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'; // (uint amountOut, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'; // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = 'swapTokensForExactTokens'; // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        }\n        break;\n    }\n    return {\n      methodName: methodName,\n      args: args,\n      value: value\n    };\n  };\n  return Router;\n}();\nvar IPancakePair = [{\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"Approval\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount0\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount1\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Burn\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount0\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount1\",\n    type: \"uint256\"\n  }],\n  name: \"Mint\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount0In\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount1In\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount0Out\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"amount1Out\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"Swap\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint112\",\n    name: \"reserve0\",\n    type: \"uint112\"\n  }, {\n    indexed: false,\n    internalType: \"uint112\",\n    name: \"reserve1\",\n    type: \"uint112\"\n  }],\n  name: \"Sync\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"Transfer\",\n  type: \"event\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"DOMAIN_SEPARATOR\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"MINIMUM_LIQUIDITY\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"pure\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"PERMIT_TYPEHASH\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  payable: false,\n  stateMutability: \"pure\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }],\n  name: \"allowance\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"approve\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"balanceOf\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"burn\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"amount0\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount1\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"decimals\",\n  outputs: [{\n    internalType: \"uint8\",\n    name: \"\",\n    type: \"uint8\"\n  }],\n  payable: false,\n  stateMutability: \"pure\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"factory\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"getReserves\",\n  outputs: [{\n    internalType: \"uint112\",\n    name: \"reserve0\",\n    type: \"uint112\"\n  }, {\n    internalType: \"uint112\",\n    name: \"reserve1\",\n    type: \"uint112\"\n  }, {\n    internalType: \"uint32\",\n    name: \"blockTimestampLast\",\n    type: \"uint32\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"initialize\",\n  outputs: [],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"kLast\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"mint\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"liquidity\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  payable: false,\n  stateMutability: \"pure\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"nonces\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"deadline\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint8\",\n    name: \"v\",\n    type: \"uint8\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"r\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"s\",\n    type: \"bytes32\"\n  }],\n  name: \"permit\",\n  outputs: [],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"price0CumulativeLast\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"price1CumulativeLast\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }],\n  name: \"skim\",\n  outputs: [],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"amount0Out\",\n    type: \"uint256\"\n  }, {\n    internalType: \"uint256\",\n    name: \"amount1Out\",\n    type: \"uint256\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"bytes\",\n    name: \"data\",\n    type: \"bytes\"\n  }],\n  name: \"swap\",\n  outputs: [],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"symbol\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  payable: false,\n  stateMutability: \"pure\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [],\n  name: \"sync\",\n  outputs: [],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"token0\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"token1\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"totalSupply\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"transfer\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"address\",\n    name: \"to\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"transferFrom\",\n  outputs: [{\n    internalType: \"bool\",\n    name: \"\",\n    type: \"bool\"\n  }],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}];\nvar ERC20 = [{\n  constant: true,\n  inputs: [],\n  name: \"decimals\",\n  outputs: [{\n    name: \"\",\n    type: \"uint8\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"balanceOf\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nvar _TOKEN_DECIMALS_CACHE;\nvar TOKEN_DECIMALS_CACHE = (_TOKEN_DECIMALS_CACHE = {}, _TOKEN_DECIMALS_CACHE[ChainId.MAINNET] = {\n  '0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A': 9 // DGD\n}, _TOKEN_DECIMALS_CACHE);\n/**\r\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\r\n */\n\nvar Fetcher = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function Fetcher() {}\n  /**\r\n   * Fetch information for a given token on the given chain, using the given ethers provider.\r\n   * @param chainId chain of the token\r\n   * @param address address of the token on the chain\r\n   * @param provider provider used to fetch the token\r\n   * @param symbol optional symbol of the token\r\n   * @param name optional name of the token\r\n   */\n\n  Fetcher.fetchTokenData = function fetchTokenData(chainId, address, provider, symbol, name) {\n    try {\n      var _TOKEN_DECIMALS_CACHE2, _TOKEN_DECIMALS_CACHE3;\n      var _temp3 = function _temp3(parsedDecimals) {\n        return new Token(chainId, address, parsedDecimals, symbol, name);\n      };\n      if (provider === undefined) provider = getDefaultProvider(getNetwork(chainId));\n      var _temp4 = typeof ((_TOKEN_DECIMALS_CACHE2 = TOKEN_DECIMALS_CACHE) === null || _TOKEN_DECIMALS_CACHE2 === void 0 ? void 0 : (_TOKEN_DECIMALS_CACHE3 = _TOKEN_DECIMALS_CACHE2[chainId]) === null || _TOKEN_DECIMALS_CACHE3 === void 0 ? void 0 : _TOKEN_DECIMALS_CACHE3[address]) === 'number';\n      return Promise.resolve(_temp4 ? _temp3(TOKEN_DECIMALS_CACHE[chainId][address]) : Promise.resolve(new Contract(address, ERC20, provider).decimals().then(function (decimals) {\n        var _TOKEN_DECIMALS_CACHE4, _extends2, _extends3;\n        TOKEN_DECIMALS_CACHE = _extends({}, TOKEN_DECIMALS_CACHE, (_extends3 = {}, _extends3[chainId] = _extends({}, (_TOKEN_DECIMALS_CACHE4 = TOKEN_DECIMALS_CACHE) === null || _TOKEN_DECIMALS_CACHE4 === void 0 ? void 0 : _TOKEN_DECIMALS_CACHE4[chainId], (_extends2 = {}, _extends2[address] = decimals, _extends2)), _extends3));\n        return decimals;\n      })).then(_temp3));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\r\n   * Fetches information about a pair and constructs a pair from the given two tokens.\r\n   * @param tokenA first token\r\n   * @param tokenB second token\r\n   * @param provider the provider to use to fetch the data\r\n   */;\n\n  Fetcher.fetchPairData = function fetchPairData(tokenA, tokenB, provider) {\n    try {\n      if (provider === undefined) provider = getDefaultProvider(getNetwork(tokenA.chainId));\n      !(tokenA.chainId === tokenB.chainId) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_ID') : invariant(false) : void 0;\n      var address = Pair.getAddress(tokenA, tokenB);\n      return Promise.resolve(new Contract(address, IPancakePair, provider).getReserves()).then(function (_ref) {\n        var reserves0 = _ref[0],\n          reserves1 = _ref[1];\n        var balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0];\n        return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]));\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  return Fetcher;\n}();\nexport { ChainId, Currency, CurrencyAmount, ETHER, FACTORY_ADDRESS, FACTORY_ADDRESS_MAP, Fetcher, Fraction, INIT_CODE_HASH, INIT_CODE_HASH_MAP, InsufficientInputAmountError, InsufficientReservesError, MINIMUM_LIQUIDITY, Pair, Percent, Price, Rounding, Route, Router, Token, TokenAmount, Trade, TradeType, WETH, currencyEquals, inputOutputComparator, tradeComparator };","map":{"version":3,"sources":["../src/constants.ts","../src/errors.ts","../src/utils.ts","../src/entities/currency.ts","../src/entities/token.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/currencyAmount.ts","../src/entities/fractions/tokenAmount.ts","../src/entities/fractions/price.ts","../src/entities/pair.ts","../src/entities/route.ts","../src/entities/fractions/percent.ts","../src/entities/trade.ts","../src/router.ts","../src/fetcher.ts"],"names":["ChainId","TradeType","Rounding","FACTORY_ADDRESS","FACTORY_ADDRESS_MAP","MAINNET","TESTNET","INIT_CODE_HASH","INIT_CODE_HASH_MAP","MINIMUM_LIQUIDITY","JSBI","BigInt","ZERO","ONE","TWO","THREE","FIVE","TEN","_100","FEES_NUMERATOR","FEES_DENOMINATOR","SolidityType","SOLIDITY_TYPE_MAXIMA","uint8","uint256","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","Error","name","constructor","setPrototypeOf","prototype","InsufficientInputAmountError","validateSolidityTypeInstance","value","solidityType","greaterThanOrEqual","lessThanOrEqual","validateAndParseAddress","address","checksummedAddress","getAddress","error","parseBigintIsh","bigintIsh","sqrt","y","z","x","greaterThan","add","divide","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop","Currency","decimals","symbol","ETHER","Token","chainId","projectLink","equals","other","sortsBefore","toLowerCase","currencyEquals","currencyA","currencyB","WETH","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","numerator","denominator","remainder","invert","otherParsed","equal","multiply","subtract","equalTo","toSignificant","significantDigits","format","groupSeparator","rounding","Number","isInteger","set","precision","quotient","toString","div","toSignificantDigits","decimalPlaces","toFixed","DP","RM","CurrencyAmount","ether","amount","currency","parsedAmount","exponentiate","raw","toExact","TokenAmount","token","Price","fromRoute","route","prices","i","pair","pairs","entries","path","token0","reserve0","reserve1","slice","reduce","accumulator","currentValue","baseCurrency","quoteCurrency","scalar","fraction","quote","currencyAmount","adjusted","PAIR_ADDRESS_CACHE","composeKey","token1","Pair","tokenA","tokenB","key","undefined","getCreate2Address","keccak256","pack","tokenAmountA","tokenAmountB","tokenAmounts","liquidityToken","involvesToken","priceOf","token0Price","token1Price","reserveOf","getOutputAmount","inputAmount","inputReserve","outputReserve","inputAmountWithFee","outputAmount","getInputAmount","getLiquidityMinted","totalSupply","liquidity","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","Route","input","output","every","currentInput","midPrice","_100_PERCENT","Percent","computePriceImpact","exactQuote","slippage","inputOutputComparator","a","b","tradeComparator","ioComp","priceImpact","wrappedAmount","wrappedCurrency","Trade","exactIn","amountIn","EXACT_INPUT","exactOut","amountOut","EXACT_OUTPUT","tradeType","amounts","Array","nextPairs","nextPair","executionPrice","nextMidPrice","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","maxNumResults","maxHops","currentPairs","originalAmountIn","bestTrades","tokenOut","isInsufficientInputAmountError","pairsExcludingThisPair","concat","bestTradeExactOut","currencyIn","currencyAmountOut","originalAmountOut","tokenIn","isInsufficientReservesError","toHex","ZERO_HEX","Router","swapCallParameters","trade","options","etherIn","etherOut","ttl","to","recipient","allowedSlippage","map","deadline","Math","floor","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer","methodName","args","TOKEN_DECIMALS_CACHE","Fetcher","fetchTokenData","provider","getDefaultProvider","getNetwork","parsedDecimals","Contract","ERC20","then","fetchPairData","reserves0","reserves1","IPancakePair","getReserves","balances"],"mappings":"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","sourcesContent":["import JSBI from 'jsbi'\n\n// exports for external consumption\nexport type BigintIsh = JSBI | number | string\n\nexport enum ChainId {\n  MAINNET = 56,\n  TESTNET = 97\n}\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nexport const FACTORY_ADDRESS = '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73'\n\nexport const FACTORY_ADDRESS_MAP = {\n  [ChainId.MAINNET]: FACTORY_ADDRESS,\n  [ChainId.TESTNET]: '0x6725f303b657a9451d8ba641348b6761a6cc7a17'\n}\n\nexport const INIT_CODE_HASH = '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5'\n\nexport const INIT_CODE_HASH_MAP = {\n  [ChainId.MAINNET]: INIT_CODE_HASH,\n  [ChainId.TESTNET]: '0xd0d4c4cd0848c93cb4fd1f498d7013ee6bfb25783ea21593d5834f5d250ece66'\n}\n\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\n\n// exports for internal consumption\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\nexport const TWO = JSBI.BigInt(2)\nexport const THREE = JSBI.BigInt(3)\nexport const FIVE = JSBI.BigInt(5)\nexport const TEN = JSBI.BigInt(10)\nexport const _100 = JSBI.BigInt(100)\nexport const FEES_NUMERATOR = JSBI.BigInt(9975)\nexport const FEES_DENOMINATOR = JSBI.BigInt(10000)\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: JSBI.BigInt('0xff'),\n  [SolidityType.uint256]: JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}\n","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport JSBI from 'jsbi'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\n\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\n  return bigintIsh instanceof JSBI ? bigintIsh : JSBI.BigInt(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: JSBI): JSBI {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: JSBI = ZERO\n  let x: JSBI\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\n    while (JSBI.lessThan(x, z)) {\n      z = x\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n","import JSBI from 'jsbi'\n\nimport { SolidityType } from '../constants'\nimport { validateSolidityTypeInstance } from '../utils'\n\n/**\n * A currency is any fungible financial instrument on Ethereum, including Ether and all ERC20 tokens.\n *\n * The only instance of the base class `Currency` is Ether.\n */\nexport class Currency {\n  public readonly decimals: number\n  public readonly symbol?: string\n  public readonly name?: string\n\n  /**\n   * The only instance of the base class `Currency`.\n   */\n  public static readonly ETHER: Currency = new Currency(18, 'BNB', 'BNB')\n\n  /**\n   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.ETHER`.\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  protected constructor(decimals: number, symbol?: string, name?: string) {\n    validateSolidityTypeInstance(JSBI.BigInt(decimals), SolidityType.uint8)\n\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n  }\n}\n\nconst ETHER = Currency.ETHER\nexport { ETHER }\n","import invariant from 'tiny-invariant'\nimport { ChainId } from '../constants'\nimport { validateAndParseAddress } from '../utils'\nimport { Currency } from './currency'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token extends Currency {\n  public readonly chainId: ChainId\n  public readonly address: string\n  public readonly projectLink?: string\n\n  public constructor(\n    chainId: ChainId,\n    address: string,\n    decimals: number,\n    symbol?: string,\n    name?: string,\n    projectLink?: string\n  ) {\n    super(decimals, symbol, name)\n    this.chainId = chainId\n    this.address = validateAndParseAddress(address)\n    this.projectLink = projectLink\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Token): boolean {\n    // short circuit on reference equality\n    if (this === other) {\n      return true\n    }\n    return this.chainId === other.chainId && this.address === other.address\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n}\n\n/**\n * Compares two currencies for equality\n */\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB)\n  } else if (currencyA instanceof Token) {\n    return false\n  } else if (currencyB instanceof Token) {\n    return false\n  } else {\n    return currencyA === currencyB\n  }\n}\n\nexport const WETH = {\n  [ChainId.MAINNET]: new Token(\n    ChainId.MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  ),\n  [ChainId.TESTNET]: new Token(\n    ChainId.TESTNET,\n    '0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd',\n    18,\n    'WBNB',\n    'Wrapped BNB',\n    'https://www.binance.org'\n  )\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Decimal from 'decimal.js-light'\nimport _Big, { RoundingMode } from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding } from '../../constants'\nimport { ONE } from '../../constants'\nimport { parseBigintIsh } from '../../utils'\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp\n}\n\nexport class Fraction {\n  public readonly numerator: JSBI\n  public readonly denominator: JSBI\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = ONE) {\n    this.numerator = parseBigintIsh(numerator)\n    this.denominator = parseBigintIsh(denominator)\n  }\n\n  // performs floor division\n  public get quotient(): JSBI {\n    return JSBI.divide(this.numerator, this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.add(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.subtract(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.lessThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.equal(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.greaterThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.numerator),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(this.denominator, otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n\n  /**\n   * Helper method for converting any super class back to a fraction\n   */\n  public get asFraction(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n}\n","import { currencyEquals } from '../token'\nimport { Currency, ETHER } from '../currency'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Big from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding, TEN, SolidityType } from '../../constants'\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../utils'\nimport { Fraction } from './fraction'\n\nconst Big = toFormat(_Big)\n\nexport class CurrencyAmount extends Fraction {\n  public readonly currency: Currency\n\n  /**\n   * Helper that calls the constructor with the ETHER currency\n   * @param amount ether amount in wei\n   */\n  public static ether(amount: BigintIsh): CurrencyAmount {\n    return new CurrencyAmount(ETHER, amount)\n  }\n\n  // amount _must_ be raw, i.e. in the native representation\n  protected constructor(currency: Currency, amount: BigintIsh) {\n    const parsedAmount = parseBigintIsh(amount)\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\n\n    super(parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(currency.decimals)))\n    this.currency = currency\n  }\n\n  public get raw(): JSBI {\n    return this.numerator\n  }\n\n  public add(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, JSBI.add(this.raw, other.raw))\n  }\n\n  public subtract(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, JSBI.subtract(this.raw, other.raw))\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\n  }\n}\n","import { CurrencyAmount } from './currencyAmount'\nimport { Token } from '../token'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\n\nimport { BigintIsh } from '../../constants'\n\nexport class TokenAmount extends CurrencyAmount {\n  public readonly token: Token\n\n  // amount _must_ be raw, i.e. in the native representation\n  public constructor(token: Token, amount: BigintIsh) {\n    super(token, amount)\n    this.token = token\n  }\n\n  public add(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.add(this.raw, other.raw))\n  }\n\n  public subtract(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.subtract(this.raw, other.raw))\n  }\n}\n","import { Token } from '../token'\nimport { TokenAmount } from './tokenAmount'\nimport { currencyEquals } from '../token'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\n\nimport { BigintIsh, Rounding, TEN } from '../../constants'\nimport { Currency } from '../currency'\nimport { Route } from '../route'\nimport { Fraction } from './fraction'\nimport { CurrencyAmount } from './currencyAmount'\n\nexport class Price extends Fraction {\n  public readonly baseCurrency: Currency // input i.e. denominator\n  public readonly quoteCurrency: Currency // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n  public static fromRoute(route: Route): Price {\n    const prices: Price[] = []\n    for (const [i, pair] of route.pairs.entries()) {\n      prices.push(\n        route.path[i].equals(pair.token0)\n          ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.raw, pair.reserve1.raw)\n          : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.raw, pair.reserve0.raw)\n      )\n    }\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n  }\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  public constructor(baseCurrency: Currency, quoteCurrency: Currency, denominator: BigintIsh, numerator: BigintIsh) {\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      JSBI.exponentiate(TEN, JSBI.BigInt(baseCurrency.decimals)),\n      JSBI.exponentiate(TEN, JSBI.BigInt(quoteCurrency.decimals))\n    )\n  }\n\n  public get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n\n  public get adjusted(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public invert(): Price {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  public multiply(other: Price): Price {\n    invariant(currencyEquals(this.quoteCurrency, other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  // performs floor division on overflow\n  public quote(currencyAmount: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(currencyAmount.currency, this.baseCurrency), 'TOKEN')\n    if (this.quoteCurrency instanceof Token) {\n      return new TokenAmount(this.quoteCurrency, super.multiply(currencyAmount.raw).quotient)\n    }\n    return CurrencyAmount.ether(super.multiply(currencyAmount.raw).quotient)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\n\nimport {\n  BigintIsh,\n  FACTORY_ADDRESS_MAP,\n  INIT_CODE_HASH_MAP,\n  MINIMUM_LIQUIDITY,\n  ZERO,\n  ONE,\n  FIVE,\n  FEES_NUMERATOR,\n  FEES_DENOMINATOR,\n  ChainId\n} from '../constants'\nimport { sqrt, parseBigintIsh } from '../utils'\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors'\nimport { Token } from './token'\n\nlet PAIR_ADDRESS_CACHE: { [key: string]: string } = {}\n\nconst composeKey = (token0: Token, token1: Token) => `${token0.chainId}-${token0.address}-${token1.address}`\n\nexport class Pair {\n  public readonly liquidityToken: Token\n  private readonly tokenAmounts: [TokenAmount, TokenAmount]\n\n  public static getAddress(tokenA: Token, tokenB: Token): string {\n    const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n\n    const key = composeKey(token0, token1)\n\n    if (PAIR_ADDRESS_CACHE?.[key] === undefined) {\n      PAIR_ADDRESS_CACHE = {\n        ...PAIR_ADDRESS_CACHE,\n        [key]: getCreate2Address(\n          FACTORY_ADDRESS_MAP[token0.chainId],\n          keccak256(['bytes'], [pack(['address', 'address'], [token0.address, token1.address])]),\n          INIT_CODE_HASH_MAP[token0.chainId]\n        )\n      }\n    }\n\n    return PAIR_ADDRESS_CACHE[key]\n  }\n\n  public constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount) {\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].token.chainId,\n      Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token),\n      18,\n      'Cake-LP',\n      'Pancake LPs'\n    )\n    this.tokenAmounts = tokenAmounts as [TokenAmount, TokenAmount]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price {\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price {\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].token\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].token\n  }\n\n  public get reserve0(): TokenAmount {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): TokenAmount {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): TokenAmount {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pair] {\n    invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.token)\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR)\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee)\n    const outputAmount = new TokenAmount(\n      inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\n    invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.raw, ZERO) ||\n      JSBI.equal(this.reserve1.raw, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.token)\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR)\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR)\n    const inputAmount = new TokenAmount(\n      outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getLiquidityMinted(\n    totalSupply: TokenAmount,\n    tokenAmountA: TokenAmount,\n    tokenAmountB: TokenAmount\n  ): TokenAmount {\n    invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return new TokenAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: TokenAmount,\n    liquidity: TokenAmount,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): TokenAmount {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: TokenAmount\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      invariant(!!kLast, 'K_LAST')\n      const kLastParsed = parseBigintIsh(kLast)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return new TokenAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n    )\n  }\n}\n","import { ChainId } from '../constants'\nimport invariant from 'tiny-invariant'\n\nimport { Currency, ETHER } from './currency'\nimport { Token, WETH } from './token'\nimport { Pair } from './pair'\nimport { Price } from './fractions/price'\n\nexport class Route {\n  public readonly pairs: Pair[]\n  public readonly path: Token[]\n  public readonly input: Currency\n  public readonly output: Currency\n  public readonly midPrice: Price\n\n  public constructor(pairs: Pair[], input: Currency, output?: Currency) {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(\n      pairs.every(pair => pair.chainId === pairs[0].chainId),\n      'CHAIN_IDS'\n    )\n    invariant(\n      (input instanceof Token && pairs[0].involvesToken(input)) ||\n        (input === ETHER && pairs[0].involvesToken(WETH[pairs[0].chainId])),\n      'INPUT'\n    )\n    invariant(\n      typeof output === 'undefined' ||\n        (output instanceof Token && pairs[pairs.length - 1].involvesToken(output)) ||\n        (output === ETHER && pairs[pairs.length - 1].involvesToken(WETH[pairs[0].chainId])),\n      'OUTPUT'\n    )\n\n    const path: Token[] = [input instanceof Token ? input : WETH[pairs[0].chainId]]\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\n      path.push(output)\n    }\n\n    this.pairs = pairs\n    this.path = path\n    this.midPrice = Price.fromRoute(this)\n    this.input = input\n    this.output = output ?? path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.pairs[0].chainId\n  }\n}\n","import { Rounding, _100 } from '../../constants'\nimport { Fraction } from './fraction'\n\nconst _100_PERCENT = new Fraction(_100)\n\nexport class Percent extends Fraction {\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { InsufficientInputAmountError, InsufficientReservesError } from '..'\n\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\nimport { sortedInsert } from '../utils'\nimport { Currency, ETHER } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport { Pair } from './pair'\nimport { Route } from './route'\nimport { currencyEquals, Token, WETH } from './token'\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nfunction computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n  return new Percent(slippage.numerator, slippage.denominator)\n}\n\n// minimal interface so the input output comparator may be shared across types\ninterface InputOutput {\n  readonly inputAmount: CurrencyAmount\n  readonly outputAmount: CurrencyAmount\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Trade, b: Trade) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === ETHER) return new TokenAmount(WETH[chainId], currencyAmount.raw)\n  invariant(false, 'CURRENCY')\n}\n\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n  if (currency instanceof Token) return currency\n  if (currency === ETHER) return WETH[chainId]\n  invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: Route\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The mid price after the trade executes assuming no slippage.\n   */\n  public readonly nextMidPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: Route, amountIn: CurrencyAmount): Trade {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: Route, amountOut: CurrencyAmount): Trade {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(route: Route, amount: CurrencyAmount, tradeType: TradeType) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    const nextPairs: Pair[] = new Array(route.pairs.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n        nextPairs[i] = nextPair\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i])\n        amounts[i - 1] = inputAmount\n        nextPairs[i - 1] = nextPair\n      }\n    }\n\n    this.route = route\n    this.tradeType = tradeType\n    this.inputAmount =\n      tradeType === TradeType.EXACT_INPUT\n        ? amount\n        : route.input === ETHER\n        ? CurrencyAmount.ether(amounts[0].raw)\n        : amounts[0]\n    this.outputAmount =\n      tradeType === TradeType.EXACT_OUTPUT\n        ? amount\n        : route.output === ETHER\n        ? CurrencyAmount.ether(amounts[amounts.length - 1].raw)\n        : amounts[amounts.length - 1]\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input))\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return this.outputAmount instanceof TokenAmount\n        ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n        : CurrencyAmount.ether(slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return this.inputAmount instanceof TokenAmount\n        ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n        : CurrencyAmount.ether(slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn(\n    pairs: Pair[],\n    currencyAmountIn: CurrencyAmount,\n    currencyOut: Currency,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountIn: CurrencyAmount = currencyAmountIn,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountIn instanceof TokenAmount\n        ? currencyAmountIn.token.chainId\n        : currencyOut instanceof Token\n        ? currencyOut.chainId\n        : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = wrappedAmount(currencyAmountIn, chainId)\n    const tokenOut = wrappedCurrency(currencyOut, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: TokenAmount\n      try {\n        ;[amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if ((error as InsufficientInputAmountError).isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut),\n            originalAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          amountOut,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentPairs, pair],\n          originalAmountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut(\n    pairs: Pair[],\n    currencyIn: Currency,\n    currencyAmountOut: CurrencyAmount,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountOut: CurrencyAmount = currencyAmountOut,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountOut instanceof TokenAmount\n        ? currencyAmountOut.token.chainId\n        : currencyIn instanceof Token\n        ? currencyIn.chainId\n        : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountOut = wrappedAmount(currencyAmountOut, chainId)\n    const tokenIn = wrappedCurrency(currencyIn, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: TokenAmount\n      try {\n        ;[amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if ((error as InsufficientReservesError).isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency),\n            originalAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          amountIn,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [pair, ...currentPairs],\n          originalAmountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","import { TradeType } from './constants'\nimport invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from './utils'\nimport { CurrencyAmount, ETHER, Percent, Trade } from './entities'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\nexport interface TradeOptionsDeadline extends Omit<TradeOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Pancake Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Pancake Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Pancake Router, and has static methods for helping execute trades.\n */\nexport abstract class Router {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(trade: Trade, options: TradeOptions | TradeOptionsDeadline): SwapParameters {\n    const etherIn = trade.inputAmount.currency === ETHER\n    const etherOut = trade.outputAmount.currency === ETHER\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map((token) => token.address)\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = useFeeOnTransfer\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n            : 'swapExactTokensForTokens'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n      case TradeType.EXACT_OUTPUT:\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = 'swapTokensForExactTokens'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n","import { Contract } from '@ethersproject/contracts'\nimport { getNetwork } from '@ethersproject/networks'\nimport { getDefaultProvider } from '@ethersproject/providers'\nimport { TokenAmount } from './entities/fractions/tokenAmount'\nimport { Pair } from './entities/pair'\nimport IPancakePair from './abis/IPancakePair.json'\nimport invariant from 'tiny-invariant'\nimport ERC20 from './abis/ERC20.json'\nimport { ChainId } from './constants'\nimport { Token } from './entities/token'\n\nlet TOKEN_DECIMALS_CACHE: { [chainId: number]: { [address: string]: number } } = {\n  [ChainId.MAINNET]: {\n    '0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A': 9 // DGD\n  }\n}\n\n/**\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\n */\nexport abstract class Fetcher {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * Fetch information for a given token on the given chain, using the given ethers provider.\n   * @param chainId chain of the token\n   * @param address address of the token on the chain\n   * @param provider provider used to fetch the token\n   * @param symbol optional symbol of the token\n   * @param name optional name of the token\n   */\n  public static async fetchTokenData(\n    chainId: ChainId,\n    address: string,\n    provider = getDefaultProvider(getNetwork(chainId)),\n    symbol?: string,\n    name?: string\n  ): Promise<Token> {\n    const parsedDecimals =\n      typeof TOKEN_DECIMALS_CACHE?.[chainId]?.[address] === 'number'\n        ? TOKEN_DECIMALS_CACHE[chainId][address]\n        : await new Contract(address, ERC20, provider).decimals().then((decimals: number): number => {\n            TOKEN_DECIMALS_CACHE = {\n              ...TOKEN_DECIMALS_CACHE,\n              [chainId]: {\n                ...TOKEN_DECIMALS_CACHE?.[chainId],\n                [address]: decimals\n              }\n            }\n            return decimals\n          })\n    return new Token(chainId, address, parsedDecimals, symbol, name)\n  }\n\n  /**\n   * Fetches information about a pair and constructs a pair from the given two tokens.\n   * @param tokenA first token\n   * @param tokenB second token\n   * @param provider the provider to use to fetch the data\n   */\n  public static async fetchPairData(\n    tokenA: Token,\n    tokenB: Token,\n    provider = getDefaultProvider(getNetwork(tokenA.chainId))\n  ): Promise<Pair> {\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID')\n    const address = Pair.getAddress(tokenA, tokenB)\n    const [reserves0, reserves1] = await new Contract(address, IPancakePair, provider).getReserves()\n    const balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0]\n    return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}