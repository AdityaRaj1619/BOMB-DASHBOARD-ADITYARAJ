{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Aditya Raj Awasthi\\\\Desktop\\\\bomb-dashboard-final-task\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\Aditya Raj Awasthi\\\\Desktop\\\\bomb-dashboard-final-task\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _get = require(\"C:\\\\Users\\\\Aditya Raj Awasthi\\\\Desktop\\\\bomb-dashboard-final-task\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Aditya Raj Awasthi\\\\Desktop\\\\bomb-dashboard-final-task\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\Aditya Raj Awasthi\\\\Desktop\\\\bomb-dashboard-final-task\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _createSuper = require(\"C:\\\\Users\\\\Aditya Raj Awasthi\\\\Desktop\\\\bomb-dashboard-final-task\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storeAsStream = void 0;\nvar stream_1 = require(\"stream\");\nvar ObservableStoreStream = /*#__PURE__*/function (_stream_1$Duplex) {\n  _inherits(ObservableStoreStream, _stream_1$Duplex);\n  var _super = _createSuper(ObservableStoreStream);\n  function ObservableStoreStream(obsStore) {\n    var _this;\n    _classCallCheck(this, ObservableStoreStream);\n    _this = _super.call(this, {\n      // pass values, not serializations\n      objectMode: true\n    });\n    // dont buffer outgoing updates\n    _this.resume();\n    // save handler so we can unsubscribe later\n    _this.handler = function (state) {\n      return _this.push(state);\n    };\n    // subscribe to obsStore changes\n    _this.obsStore = obsStore;\n    _this.obsStore.subscribe(_this.handler);\n    return _this;\n  }\n  // emit current state on new destination\n  _createClass(ObservableStoreStream, [{\n    key: \"pipe\",\n    value: function pipe(dest, options) {\n      var result = _get(_getPrototypeOf(ObservableStoreStream.prototype), \"pipe\", this).call(this, dest, options);\n      dest.write(this.obsStore.getState());\n      return result;\n    }\n    // write from incoming stream to state\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, _encoding, callback) {\n      this.obsStore.putState(chunk);\n      callback();\n    }\n    // noop - outgoing stream is asking us if we have data we arent giving it\n  }, {\n    key: \"_read\",\n    value: function _read(_size) {\n      return undefined;\n    }\n    // unsubscribe from event emitter\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(err, callback) {\n      this.obsStore.unsubscribe(this.handler);\n      _get(_getPrototypeOf(ObservableStoreStream.prototype), \"_destroy\", this).call(this, err, callback);\n    }\n  }]);\n  return ObservableStoreStream;\n}(stream_1.Duplex);\nfunction storeAsStream(obsStore) {\n  return new ObservableStoreStream(obsStore);\n}\nexports.storeAsStream = storeAsStream;","map":{"version":3,"sources":["../src/asStream.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAAgD,IAI1C,qBAAyB,0BAAA,gBAAA;EAAA,SAAA,CAAA,qBAAA,EAAA,gBAAA;EAAA,IAAA,MAAA,GAAA,YAAA,CAAA,qBAAA;EAK7B,SAAA,sBAAY,QAA4B,EAAA;IAAA,IAAA,KAAA;IAAA,eAAA,OAAA,qBAAA;IACtC,KAAA,GAAA,MAAA,CAAA,IAAA,OAAM;MACJ;MACA,UAAU,EAAE;KACb;IACD;IACA,KAAA,CAAK,MAAM,EAAE;IACb;IACA,KAAA,CAAK,OAAO,GAAG,UAAC,KAAQ;MAAA,OAAK,KAAA,CAAK,IAAI,CAAC,KAAK,CAAC;IAAA;IAC7C;IACA,KAAA,CAAK,QAAQ,GAAG,QAAQ;IACxB,KAAA,CAAK,QAAQ,CAAC,SAAS,CAAC,KAAA,CAAK,OAAO,CAAC;IAAC,OAAA,KAAA;EACxC;EAEA;EAAA,YAAA,CAAA,qBAAA;IAAA,GAAA;IAAA,KAAA,EACA,SAAA,KACE,IAAO,EACP,OAA2B,EAAA;MAE3B,IAAM,MAAM,GAAA,IAAA,CAAA,eAAA,CAAA,qBAAA,CAAA,SAAA,iBAAA,IAAA,OAAc,IAAI,EAAE,OAAO,CAAC;MACxC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAS,CAAC;MAC3C,OAAO,MAAM;IACf;IAEA;EAAA;IAAA,GAAA;IAAA,KAAA,EACA,SAAA,OACE,KAAU,EACV,SAAiB,EACjB,QAAwC,EAAA;MAExC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC;MAC7B,QAAQ,EAAE;IACZ;IAEA;EAAA;IAAA,GAAA;IAAA,KAAA,EACA,SAAA,MAAM,KAAa,EAAA;MACjB,OAAO,SAAS;IAClB;IAEA;EAAA;IAAA,GAAA;IAAA,KAAA,EACA,SAAA,SAAS,GAAiB,EAAE,QAAuC,EAAA;MACjE,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC;MACvC,IAAA,CAAA,eAAA,CAAA,qBAAA,CAAA,SAAA,qBAAA,IAAA,OAAe,GAAG,EAAE,QAAQ;IAC9B;EAAC;EAAA,OAAA,qBAAA;AAAA,EAhDoC,QAAA,CAAA,MAAY;AAmDnD,SAAgB,aAAa,CAC3B,QAA4B,EAAA;EAE5B,OAAO,IAAI,qBAAqB,CAAC,QAAQ,CAAC;AAC5C;AAJA,OAAA,CAAA,aAAA,GAAA,aAAA","sourcesContent":["import { Duplex as DuplexStream } from 'stream';\n\nimport { ObservableStore } from './ObservableStore';\n\nclass ObservableStoreStream<T> extends DuplexStream {\n  handler: (state: T) => void;\n\n  obsStore: ObservableStore<T>;\n\n  constructor(obsStore: ObservableStore<T>) {\n    super({\n      // pass values, not serializations\n      objectMode: true,\n    });\n    // dont buffer outgoing updates\n    this.resume();\n    // save handler so we can unsubscribe later\n    this.handler = (state: T) => this.push(state);\n    // subscribe to obsStore changes\n    this.obsStore = obsStore;\n    this.obsStore.subscribe(this.handler);\n  }\n\n  // emit current state on new destination\n  pipe<U extends NodeJS.WritableStream>(\n    dest: U,\n    options?: { end?: boolean },\n  ): U {\n    const result = super.pipe(dest, options);\n    dest.write(this.obsStore.getState() as any);\n    return result;\n  }\n\n  // write from incoming stream to state\n  _write(\n    chunk: any,\n    _encoding: string,\n    callback: (error?: Error | null) => void,\n  ): void {\n    this.obsStore.putState(chunk);\n    callback();\n  }\n\n  // noop - outgoing stream is asking us if we have data we arent giving it\n  _read(_size: number): void {\n    return undefined;\n  }\n\n  // unsubscribe from event emitter\n  _destroy(err: Error | null, callback: (error: Error | null) => void): void {\n    this.obsStore.unsubscribe(this.handler);\n    super._destroy(err, callback);\n  }\n}\n\nexport function storeAsStream<T>(\n  obsStore: ObservableStore<T>,\n): ObservableStoreStream<T> {\n  return new ObservableStoreStream(obsStore);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}