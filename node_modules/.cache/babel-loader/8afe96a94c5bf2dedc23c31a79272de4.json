{"ast":null,"code":"const EventEmitter = require('events');\nconst parse = require('../parse');\nconst dev = process.env.NODE_ENV === 'development';\nlet WebSocket;\nclass WebSocketConnection extends EventEmitter {\n  constructor(_WebSocket, url, options) {\n    super();\n    WebSocket = _WebSocket;\n    setTimeout(() => this.create(url, options), 0);\n  }\n  create(url, options) {\n    if (!WebSocket) this.emit('error', new Error('No WebSocket transport available'));\n    try {\n      this.socket = new WebSocket(url);\n    } catch (e) {\n      return this.emit('error', e);\n    }\n    this.socket.addEventListener('error', err => this.emit('error', err));\n    this.socket.addEventListener('open', () => {\n      this.emit('connect');\n      this.socket.addEventListener('message', message => {\n        const data = typeof message.data === 'string' ? message.data : '';\n        parse(data, (err, payloads) => {\n          if (err) return; //\n          payloads.forEach(load => {\n            if (Array.isArray(load)) {\n              load.forEach(payload => this.emit('payload', payload));\n            } else {\n              this.emit('payload', load);\n            }\n          });\n        });\n      });\n      this.socket.addEventListener('close', () => this.onClose());\n    });\n  }\n  onClose() {\n    this.socket = null;\n    this.closed = true;\n    if (dev) console.log('Closing WebSocket connection');\n    this.emit('close');\n    this.removeAllListeners();\n  }\n  close() {\n    if (this.socket) {\n      this.socket.close();\n    } else {\n      this.onClose();\n    }\n  }\n  error(payload, message) {\n    let code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    this.emit('payload', {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      error: {\n        message,\n        code\n      }\n    });\n  }\n  send(payload) {\n    if (this.socket && this.socket.readyState === this.socket.CONNECTING) {\n      setTimeout(_ => this.send(payload), 10);\n    } else if (!this.socket || this.socket.readyState > 1) {\n      this.connected = false;\n      this.error(payload, 'Not connected');\n    } else {\n      this.socket.send(JSON.stringify(payload));\n    }\n  }\n}\nmodule.exports = WebSocket => (url, cb) => new WebSocketConnection(WebSocket, url, cb);","map":{"version":3,"names":["EventEmitter","require","parse","dev","process","env","NODE_ENV","WebSocket","WebSocketConnection","constructor","_WebSocket","url","options","setTimeout","create","emit","Error","socket","e","addEventListener","err","message","data","payloads","forEach","load","Array","isArray","payload","onClose","closed","console","log","removeAllListeners","close","error","code","arguments","length","undefined","id","jsonrpc","send","readyState","CONNECTING","_","connected","JSON","stringify","module","exports","cb"],"sources":["C:/Users/Aditya Raj Awasthi/Desktop/bomb-dashboard-final-task/node_modules/eth-provider/connections/ws.js"],"sourcesContent":["const EventEmitter = require('events')\nconst parse = require('../parse')\nconst dev = process.env.NODE_ENV === 'development'\n\nlet WebSocket\n\nclass WebSocketConnection extends EventEmitter {\n  constructor (_WebSocket, url, options) {\n    super()\n    WebSocket = _WebSocket\n    setTimeout(() => this.create(url, options), 0)\n  }\n\n  create (url, options) {\n    if (!WebSocket) this.emit('error', new Error('No WebSocket transport available'))\n    try { this.socket = new WebSocket(url) } catch (e) { return this.emit('error', e) }\n    this.socket.addEventListener('error', err => this.emit('error', err))\n    this.socket.addEventListener('open', () => {\n      this.emit('connect')\n      this.socket.addEventListener('message', message => {\n        const data = typeof message.data === 'string' ? message.data : ''\n        parse(data, (err, payloads) => {\n          if (err) return //\n          payloads.forEach(load => {\n            if (Array.isArray(load)) {\n              load.forEach(payload => this.emit('payload', payload))\n            } else {\n              this.emit('payload', load)\n            }\n          })\n        })\n      })\n      this.socket.addEventListener('close', () => this.onClose())\n    })\n  }\n\n  onClose () {\n    this.socket = null\n    this.closed = true\n    if (dev) console.log('Closing WebSocket connection')\n    this.emit('close')\n    this.removeAllListeners()\n  }\n\n  close () {\n    if (this.socket) {\n      this.socket.close()\n    } else {\n      this.onClose()\n    }\n  }\n\n  error (payload, message, code = -1) {\n    this.emit('payload', { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } })\n  }\n\n  send (payload) {\n    if (this.socket && this.socket.readyState === this.socket.CONNECTING) {\n      setTimeout(_ => this.send(payload), 10)\n    } else if (!this.socket || this.socket.readyState > 1) {\n      this.connected = false\n      this.error(payload, 'Not connected')\n    } else {\n      this.socket.send(JSON.stringify(payload))\n    }\n  }\n}\n\nmodule.exports = WebSocket => (url, cb) => new WebSocketConnection(WebSocket, url, cb)\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}