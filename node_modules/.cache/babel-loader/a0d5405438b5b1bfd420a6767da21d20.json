{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar constants_1 = require(\"../utils/constants\");\nvar pointer_1 = require(\"./blocks/pointer\");\nvar set_1 = require(\"./blocks/set\");\nvar iterator_1 = require(\"./iterator\");\nvar Calldata = /** @class */function () {\n  function Calldata(rules) {\n    this._rules = rules;\n    this._selector = '';\n    this._root = undefined;\n  }\n  /**\n   * Sets the root calldata block. This block usually corresponds to a Method.\n   */\n  Calldata.prototype.setRoot = function (block) {\n    this._root = block;\n  };\n  /**\n   * Sets the selector to be prepended onto the calldata.\n   * If the root block was created by a Method then a selector will likely be set.\n   */\n  Calldata.prototype.setSelector = function (selector) {\n    if (!_.startsWith(selector, '0x')) {\n      throw new Error(\"Expected selector to be hex. Missing prefix '0x'\");\n    } else if (selector.length !== constants_1.constants.HEX_SELECTOR_LENGTH_IN_CHARS) {\n      throw new Error(\"Invalid selector '\" + selector + \"'\");\n    }\n    this._selector = selector;\n  };\n  /**\n   * Iterates through the calldata blocks, starting from the root block, to construct calldata as a hex string.\n   * If the `optimize` flag is set then this calldata will be condensed, to save gas.\n   * If the `annotate` flag is set then this will return human-readable calldata.\n   * If the `annotate` flag is *not* set then this will return EVM-compatible calldata.\n   */\n  Calldata.prototype.toString = function () {\n    var e_1, _a;\n    // Sanity check: root block must be set\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    }\n    // Optimize, if flag set\n    if (this._rules.shouldOptimize) {\n      this._optimize();\n    }\n    // Set offsets\n    var iterator = new iterator_1.CalldataIterator(this._root);\n    var offset = 0;\n    try {\n      for (var iterator_2 = __values(iterator), iterator_2_1 = iterator_2.next(); !iterator_2_1.done; iterator_2_1 = iterator_2.next()) {\n        var block = iterator_2_1.value;\n        block.setOffset(offset);\n        offset += block.getSizeInBytes();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterator_2_1 && !iterator_2_1.done && (_a = iterator_2.return)) _a.call(iterator_2);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    // Generate hex string\n    var hexString = this._rules.shouldAnnotate ? this._toHumanReadableCallData() : this._toEvmCompatibeCallDataHex();\n    return hexString;\n  };\n  /**\n   * There are three types of calldata blocks: Blob, Set and Pointer.\n   * Scenarios arise where distinct pointers resolve to identical values.\n   * We optimize by keeping only one such instance of the identical value, and redirecting all pointers here.\n   * We keep the last such duplicate value because pointers can only be positive (they cannot point backwards).\n   *\n   * Example #1:\n   *  function f(string[], string[])\n   *  f([\"foo\", \"bar\", \"blitz\"], [\"foo\", \"bar\", \"blitz\"])\n   *  The array [\"foo\", \"bar\", \"blitz\"] will only be included in the calldata once.\n   *\n   * Example #2:\n   *  function f(string[], string)\n   *  f([\"foo\", \"bar\", \"blitz\"], \"foo\")\n   *  The string \"foo\" will only be included in the calldata once.\n   *\n   * Example #3:\n   *  function f((string, uint, bytes), string, uint, bytes)\n   *  f((\"foo\", 5, \"0x05\"), \"foo\", 5, \"0x05\")\n   *  The string \"foo\" and bytes \"0x05\" will only be included in the calldata once.\n   *  The duplicate `uint 5` values cannot be optimized out because they are static values (no pointer points to them).\n   *\n   * @TODO #1:\n   *   This optimization strategy handles blocks that are exact duplicates of one another.\n   *   But what if some block is a combination of two other blocks? Or a subset of another block?\n   *   This optimization problem is not much different from the current implemetation.\n   *   Instead of tracking \"observed\" hashes, at each node we would simply do pattern-matching on the calldata.\n   *   This strategy would be applied after assigning offsets to the tree, rather than before (as in this strategy).\n   *   Note that one consequence of this strategy is pointers may resolve to offsets that are not word-aligned.\n   *   This shouldn't be a problem but further investigation should be done.\n   *\n   * @TODO #2:\n   *   To be done as a follow-up to @TODO #1.\n   *   Since we optimize from the bottom-up, we could be affecting the outcome of a later potential optimization.\n   *   For example, what if by removing one duplicate value we miss out on optimizing another block higher in the tree.\n   *   To handle this case, at each node we can store a candidate optimization in a priority queue (sorted by calldata size).\n   *   At the end of traversing the tree, the candidate at the front of the queue will be the most optimal output.\n   *\n   */\n  Calldata.prototype._optimize = function () {\n    var e_2, _a;\n    // Step 1/1 Create a reverse iterator (starts from the end of the calldata to the beginning)\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    }\n    var iterator = new iterator_1.ReverseCalldataIterator(this._root);\n    // Step 2/2 Iterate over each block, keeping track of which blocks have been seen and pruning redundant blocks.\n    var blocksByHash = {};\n    try {\n      for (var iterator_3 = __values(iterator), iterator_3_1 = iterator_3.next(); !iterator_3_1.done; iterator_3_1 = iterator_3.next()) {\n        var block = iterator_3_1.value;\n        // If a block is a pointer and its value has already been observed, then update\n        // the pointer to resolve to the existing value.\n        if (block instanceof pointer_1.PointerCalldataBlock) {\n          var dependencyBlockHashBuf = block.getDependency().computeHash();\n          var dependencyBlockHash = ethUtil.bufferToHex(dependencyBlockHashBuf);\n          if (dependencyBlockHash in blocksByHash) {\n            var blockWithSameHash = blocksByHash[dependencyBlockHash];\n            if (blockWithSameHash !== block.getDependency()) {\n              block.setAlias(blockWithSameHash);\n            }\n          }\n          continue;\n        }\n        // This block has not been seen. Record its hash.\n        var blockHashBuf = block.computeHash();\n        var blockHash = ethUtil.bufferToHex(blockHashBuf);\n        if (!(blockHash in blocksByHash)) {\n          blocksByHash[blockHash] = block;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (iterator_3_1 && !iterator_3_1.done && (_a = iterator_3.return)) _a.call(iterator_3);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n  Calldata.prototype._toEvmCompatibeCallDataHex = function () {\n    var e_3, _a;\n    // Sanity check: must have a root block.\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    }\n    // Construct an array of buffers (one buffer for each block).\n    var selectorBuffer = ethUtil.toBuffer(this._selector);\n    var valueBufs = [selectorBuffer];\n    var iterator = new iterator_1.CalldataIterator(this._root);\n    try {\n      for (var iterator_4 = __values(iterator), iterator_4_1 = iterator_4.next(); !iterator_4_1.done; iterator_4_1 = iterator_4.next()) {\n        var block = iterator_4_1.value;\n        valueBufs.push(block.toBuffer());\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (iterator_4_1 && !iterator_4_1.done && (_a = iterator_4.return)) _a.call(iterator_4);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    // Create hex from buffer array.\n    var combinedBuffers = Buffer.concat(valueBufs);\n    var hexValue = ethUtil.bufferToHex(combinedBuffers);\n    return hexValue;\n  };\n  /**\n   * Returns human-readable calldata.\n   *\n   * Example:\n   *   simpleFunction(string[], string[])\n   *   strings = [\"Hello\", \"World\"]\n   *   simpleFunction(strings, strings)\n   *\n   * Output:\n   *   0xbb4f12e3\n   *                                                                                      ### simpleFunction\n   *   0x0       0000000000000000000000000000000000000000000000000000000000000040              ptr<array1> (alias for array2)\n   *   0x20      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2>\n   *\n   *   0x40      0000000000000000000000000000000000000000000000000000000000000002          ### array2\n   *   0x60      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2[0]>\n   *   0x80      0000000000000000000000000000000000000000000000000000000000000080              ptr<array2[1]>\n   *   0xa0      0000000000000000000000000000000000000000000000000000000000000005              array2[0]\n   *   0xc0      48656c6c6f000000000000000000000000000000000000000000000000000000\n   *   0xe0      0000000000000000000000000000000000000000000000000000000000000005              array2[1]\n   *   0x100     576f726c64000000000000000000000000000000000000000000000000000000\n   */\n  Calldata.prototype._toHumanReadableCallData = function () {\n    var e_4, _a;\n    // Sanity check: must have a root block.\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    }\n    // Constants for constructing annotated string\n    var offsetPadding = 10;\n    var valuePadding = 74;\n    var namePadding = 80;\n    var evmWordStartIndex = 0;\n    var emptySize = 0;\n    // Construct annotated calldata\n    var hexValue = \"\" + this._selector;\n    var offset = 0;\n    var functionName = this._root.getName();\n    var iterator = new iterator_1.CalldataIterator(this._root);\n    try {\n      for (var iterator_5 = __values(iterator), iterator_5_1 = iterator_5.next(); !iterator_5_1.done; iterator_5_1 = iterator_5.next()) {\n        var block = iterator_5_1.value;\n        // Process each block 1 word at a time\n        var size = block.getSizeInBytes();\n        var name_1 = block.getName();\n        var parentName = block.getParentName();\n        var prettyName = name_1.replace(parentName + \".\", '').replace(functionName + \".\", '');\n        // Resulting line will be <offsetStr><valueStr><nameStr>\n        var offsetStr = '';\n        var valueStr = '';\n        var nameStr = '';\n        var lineStr = '';\n        if (size === emptySize) {\n          // This is a Set block with no header.\n          // For example, a tuple or an array with a defined length.\n          offsetStr = ' '.repeat(offsetPadding);\n          valueStr = ' '.repeat(valuePadding);\n          nameStr = \"### \" + prettyName.padEnd(namePadding);\n          lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n        } else {\n          // This block has at least one word of value.\n          offsetStr = (\"0x\" + offset.toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n          valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(evmWordStartIndex, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n          if (block instanceof set_1.SetCalldataBlock) {\n            nameStr = \"### \" + prettyName.padEnd(namePadding);\n            lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n          } else {\n            nameStr = \"    \" + prettyName.padEnd(namePadding);\n            lineStr = \"\" + offsetStr + valueStr + nameStr;\n          }\n        }\n        // This block has a value that is more than 1 word.\n        for (var j = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES; j < size; j += constants_1.constants.EVM_WORD_WIDTH_IN_BYTES) {\n          offsetStr = (\"0x\" + (offset + j).toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n          valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(j, j + constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n          nameStr = ' '.repeat(namePadding);\n          lineStr = lineStr + \"\\n\" + offsetStr + valueStr + nameStr;\n        }\n        // Append to hex value\n        hexValue = hexValue + \"\\n\" + lineStr;\n        offset += size;\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (iterator_5_1 && !iterator_5_1.done && (_a = iterator_5.return)) _a.call(iterator_5);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n    return hexValue;\n  };\n  return Calldata;\n}();\nexports.Calldata = Calldata;","map":{"version":3,"sources":["../../../../src/abi_encoder/calldata/calldata.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar constants_1 = require(\"../utils/constants\");\nvar pointer_1 = require(\"./blocks/pointer\");\nvar set_1 = require(\"./blocks/set\");\nvar iterator_1 = require(\"./iterator\");\nvar Calldata = /** @class */ (function () {\n    function Calldata(rules) {\n        this._rules = rules;\n        this._selector = '';\n        this._root = undefined;\n    }\n    /**\n     * Sets the root calldata block. This block usually corresponds to a Method.\n     */\n    Calldata.prototype.setRoot = function (block) {\n        this._root = block;\n    };\n    /**\n     * Sets the selector to be prepended onto the calldata.\n     * If the root block was created by a Method then a selector will likely be set.\n     */\n    Calldata.prototype.setSelector = function (selector) {\n        if (!_.startsWith(selector, '0x')) {\n            throw new Error(\"Expected selector to be hex. Missing prefix '0x'\");\n        }\n        else if (selector.length !== constants_1.constants.HEX_SELECTOR_LENGTH_IN_CHARS) {\n            throw new Error(\"Invalid selector '\" + selector + \"'\");\n        }\n        this._selector = selector;\n    };\n    /**\n     * Iterates through the calldata blocks, starting from the root block, to construct calldata as a hex string.\n     * If the `optimize` flag is set then this calldata will be condensed, to save gas.\n     * If the `annotate` flag is set then this will return human-readable calldata.\n     * If the `annotate` flag is *not* set then this will return EVM-compatible calldata.\n     */\n    Calldata.prototype.toString = function () {\n        var e_1, _a;\n        // Sanity check: root block must be set\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        // Optimize, if flag set\n        if (this._rules.shouldOptimize) {\n            this._optimize();\n        }\n        // Set offsets\n        var iterator = new iterator_1.CalldataIterator(this._root);\n        var offset = 0;\n        try {\n            for (var iterator_2 = __values(iterator), iterator_2_1 = iterator_2.next(); !iterator_2_1.done; iterator_2_1 = iterator_2.next()) {\n                var block = iterator_2_1.value;\n                block.setOffset(offset);\n                offset += block.getSizeInBytes();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterator_2_1 && !iterator_2_1.done && (_a = iterator_2.return)) _a.call(iterator_2);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        // Generate hex string\n        var hexString = this._rules.shouldAnnotate\n            ? this._toHumanReadableCallData()\n            : this._toEvmCompatibeCallDataHex();\n        return hexString;\n    };\n    /**\n     * There are three types of calldata blocks: Blob, Set and Pointer.\n     * Scenarios arise where distinct pointers resolve to identical values.\n     * We optimize by keeping only one such instance of the identical value, and redirecting all pointers here.\n     * We keep the last such duplicate value because pointers can only be positive (they cannot point backwards).\n     *\n     * Example #1:\n     *  function f(string[], string[])\n     *  f([\"foo\", \"bar\", \"blitz\"], [\"foo\", \"bar\", \"blitz\"])\n     *  The array [\"foo\", \"bar\", \"blitz\"] will only be included in the calldata once.\n     *\n     * Example #2:\n     *  function f(string[], string)\n     *  f([\"foo\", \"bar\", \"blitz\"], \"foo\")\n     *  The string \"foo\" will only be included in the calldata once.\n     *\n     * Example #3:\n     *  function f((string, uint, bytes), string, uint, bytes)\n     *  f((\"foo\", 5, \"0x05\"), \"foo\", 5, \"0x05\")\n     *  The string \"foo\" and bytes \"0x05\" will only be included in the calldata once.\n     *  The duplicate `uint 5` values cannot be optimized out because they are static values (no pointer points to them).\n     *\n     * @TODO #1:\n     *   This optimization strategy handles blocks that are exact duplicates of one another.\n     *   But what if some block is a combination of two other blocks? Or a subset of another block?\n     *   This optimization problem is not much different from the current implemetation.\n     *   Instead of tracking \"observed\" hashes, at each node we would simply do pattern-matching on the calldata.\n     *   This strategy would be applied after assigning offsets to the tree, rather than before (as in this strategy).\n     *   Note that one consequence of this strategy is pointers may resolve to offsets that are not word-aligned.\n     *   This shouldn't be a problem but further investigation should be done.\n     *\n     * @TODO #2:\n     *   To be done as a follow-up to @TODO #1.\n     *   Since we optimize from the bottom-up, we could be affecting the outcome of a later potential optimization.\n     *   For example, what if by removing one duplicate value we miss out on optimizing another block higher in the tree.\n     *   To handle this case, at each node we can store a candidate optimization in a priority queue (sorted by calldata size).\n     *   At the end of traversing the tree, the candidate at the front of the queue will be the most optimal output.\n     *\n     */\n    Calldata.prototype._optimize = function () {\n        var e_2, _a;\n        // Step 1/1 Create a reverse iterator (starts from the end of the calldata to the beginning)\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        var iterator = new iterator_1.ReverseCalldataIterator(this._root);\n        // Step 2/2 Iterate over each block, keeping track of which blocks have been seen and pruning redundant blocks.\n        var blocksByHash = {};\n        try {\n            for (var iterator_3 = __values(iterator), iterator_3_1 = iterator_3.next(); !iterator_3_1.done; iterator_3_1 = iterator_3.next()) {\n                var block = iterator_3_1.value;\n                // If a block is a pointer and its value has already been observed, then update\n                // the pointer to resolve to the existing value.\n                if (block instanceof pointer_1.PointerCalldataBlock) {\n                    var dependencyBlockHashBuf = block.getDependency().computeHash();\n                    var dependencyBlockHash = ethUtil.bufferToHex(dependencyBlockHashBuf);\n                    if (dependencyBlockHash in blocksByHash) {\n                        var blockWithSameHash = blocksByHash[dependencyBlockHash];\n                        if (blockWithSameHash !== block.getDependency()) {\n                            block.setAlias(blockWithSameHash);\n                        }\n                    }\n                    continue;\n                }\n                // This block has not been seen. Record its hash.\n                var blockHashBuf = block.computeHash();\n                var blockHash = ethUtil.bufferToHex(blockHashBuf);\n                if (!(blockHash in blocksByHash)) {\n                    blocksByHash[blockHash] = block;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (iterator_3_1 && !iterator_3_1.done && (_a = iterator_3.return)) _a.call(iterator_3);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    };\n    Calldata.prototype._toEvmCompatibeCallDataHex = function () {\n        var e_3, _a;\n        // Sanity check: must have a root block.\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        // Construct an array of buffers (one buffer for each block).\n        var selectorBuffer = ethUtil.toBuffer(this._selector);\n        var valueBufs = [selectorBuffer];\n        var iterator = new iterator_1.CalldataIterator(this._root);\n        try {\n            for (var iterator_4 = __values(iterator), iterator_4_1 = iterator_4.next(); !iterator_4_1.done; iterator_4_1 = iterator_4.next()) {\n                var block = iterator_4_1.value;\n                valueBufs.push(block.toBuffer());\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (iterator_4_1 && !iterator_4_1.done && (_a = iterator_4.return)) _a.call(iterator_4);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        // Create hex from buffer array.\n        var combinedBuffers = Buffer.concat(valueBufs);\n        var hexValue = ethUtil.bufferToHex(combinedBuffers);\n        return hexValue;\n    };\n    /**\n     * Returns human-readable calldata.\n     *\n     * Example:\n     *   simpleFunction(string[], string[])\n     *   strings = [\"Hello\", \"World\"]\n     *   simpleFunction(strings, strings)\n     *\n     * Output:\n     *   0xbb4f12e3\n     *                                                                                      ### simpleFunction\n     *   0x0       0000000000000000000000000000000000000000000000000000000000000040              ptr<array1> (alias for array2)\n     *   0x20      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2>\n     *\n     *   0x40      0000000000000000000000000000000000000000000000000000000000000002          ### array2\n     *   0x60      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2[0]>\n     *   0x80      0000000000000000000000000000000000000000000000000000000000000080              ptr<array2[1]>\n     *   0xa0      0000000000000000000000000000000000000000000000000000000000000005              array2[0]\n     *   0xc0      48656c6c6f000000000000000000000000000000000000000000000000000000\n     *   0xe0      0000000000000000000000000000000000000000000000000000000000000005              array2[1]\n     *   0x100     576f726c64000000000000000000000000000000000000000000000000000000\n     */\n    Calldata.prototype._toHumanReadableCallData = function () {\n        var e_4, _a;\n        // Sanity check: must have a root block.\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        // Constants for constructing annotated string\n        var offsetPadding = 10;\n        var valuePadding = 74;\n        var namePadding = 80;\n        var evmWordStartIndex = 0;\n        var emptySize = 0;\n        // Construct annotated calldata\n        var hexValue = \"\" + this._selector;\n        var offset = 0;\n        var functionName = this._root.getName();\n        var iterator = new iterator_1.CalldataIterator(this._root);\n        try {\n            for (var iterator_5 = __values(iterator), iterator_5_1 = iterator_5.next(); !iterator_5_1.done; iterator_5_1 = iterator_5.next()) {\n                var block = iterator_5_1.value;\n                // Process each block 1 word at a time\n                var size = block.getSizeInBytes();\n                var name_1 = block.getName();\n                var parentName = block.getParentName();\n                var prettyName = name_1.replace(parentName + \".\", '').replace(functionName + \".\", '');\n                // Resulting line will be <offsetStr><valueStr><nameStr>\n                var offsetStr = '';\n                var valueStr = '';\n                var nameStr = '';\n                var lineStr = '';\n                if (size === emptySize) {\n                    // This is a Set block with no header.\n                    // For example, a tuple or an array with a defined length.\n                    offsetStr = ' '.repeat(offsetPadding);\n                    valueStr = ' '.repeat(valuePadding);\n                    nameStr = \"### \" + prettyName.padEnd(namePadding);\n                    lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n                }\n                else {\n                    // This block has at least one word of value.\n                    offsetStr = (\"0x\" + offset.toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n                    valueStr = ethUtil\n                        .stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(evmWordStartIndex, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES)))\n                        .padEnd(valuePadding);\n                    if (block instanceof set_1.SetCalldataBlock) {\n                        nameStr = \"### \" + prettyName.padEnd(namePadding);\n                        lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n                    }\n                    else {\n                        nameStr = \"    \" + prettyName.padEnd(namePadding);\n                        lineStr = \"\" + offsetStr + valueStr + nameStr;\n                    }\n                }\n                // This block has a value that is more than 1 word.\n                for (var j = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES; j < size; j += constants_1.constants.EVM_WORD_WIDTH_IN_BYTES) {\n                    offsetStr = (\"0x\" + (offset + j).toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n                    valueStr = ethUtil\n                        .stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(j, j + constants_1.constants.EVM_WORD_WIDTH_IN_BYTES)))\n                        .padEnd(valuePadding);\n                    nameStr = ' '.repeat(namePadding);\n                    lineStr = lineStr + \"\\n\" + offsetStr + valueStr + nameStr;\n                }\n                // Append to hex value\n                hexValue = hexValue + \"\\n\" + lineStr;\n                offset += size;\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (iterator_5_1 && !iterator_5_1.done && (_a = iterator_5.return)) _a.call(iterator_5);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        return hexValue;\n    };\n    return Calldata;\n}());\nexports.Calldata = Calldata;\n//# sourceMappingURL=calldata.js.map"]},"metadata":{},"sourceType":"script"}