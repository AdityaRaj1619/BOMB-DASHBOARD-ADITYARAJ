{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar _ = require(\"lodash\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n// Note(albrow): This function is unexported in ethers.js. Copying it here for\n// now.\n// Source: https://github.com/ethers-io/ethers.js/blob/884593ab76004a808bf8097e9753fb5f8dcc3067/contracts/interface.js#L30\nfunction parseEthersParams(params) {\n  var names = [];\n  var types = [];\n  params.forEach(function (param) {\n    if (param.components != null) {\n      var suffix = '';\n      var arrayBracket = param.type.indexOf('[');\n      if (arrayBracket >= 0) {\n        suffix = param.type.substring(arrayBracket);\n      }\n      var result = parseEthersParams(param.components);\n      names.push({\n        name: param.name || null,\n        names: result.names\n      });\n      types.push(\"tuple(\" + result.types.join(',') + \")\" + suffix);\n    } else {\n      names.push(param.name || null);\n      types.push(param.type);\n    }\n  });\n  return {\n    names: names,\n    types: types\n  };\n}\n// returns true if x is equal to y and false otherwise. Performs some minimal\n// type conversion and data massaging for x and y, depending on type. name and\n// type should typically be derived from parseEthersParams.\nfunction isAbiDataEqual(name, type, x, y) {\n  if (x === undefined && y === undefined) {\n    return true;\n  } else if (x === undefined && y !== undefined) {\n    return false;\n  } else if (x !== undefined && y === undefined) {\n    return false;\n  }\n  if (_.endsWith(type, '[]')) {\n    // For array types, we iterate through the elements and check each one\n    // individually. Strangely, name does not need to be changed in this\n    // case.\n    if (x.length !== y.length) {\n      return false;\n    }\n    var newType = _.trimEnd(type, '[]');\n    for (var i = 0; i < x.length; i++) {\n      if (!isAbiDataEqual(name, newType, x[i], y[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (_.startsWith(type, 'tuple(')) {\n    if (_.isString(name)) {\n      throw new Error('Internal error: type was tuple but names was a string');\n    } else if (name === null) {\n      throw new Error('Internal error: type was tuple but names was null');\n    }\n    // For tuples, we iterate through the underlying values and check each\n    // one individually.\n    var types = splitTupleTypes(type);\n    if (types.length !== name.names.length) {\n      throw new Error(\"Internal error: parameter types/names length mismatch (\" + types.length + \" != \" + name.names.length + \")\");\n    }\n    for (var i = 0; i < types.length; i++) {\n      // For tuples, name is an object with a names property that is an\n      // array. As an example, for orders, name looks like:\n      //\n      //  {\n      //      name: 'orders',\n      //      names: [\n      //          'makerAddress',\n      //          // ...\n      //          'takerAssetData'\n      //      ]\n      //  }\n      //\n      var nestedName = _.isString(name.names[i]) ? name.names[i] : name.names[i].name;\n      if (!isAbiDataEqual(name.names[i], types[i], x[nestedName], y[nestedName])) {\n        return false;\n      }\n    }\n    return true;\n  } else if (type === 'address' || type === 'bytes') {\n    // HACK(albrow): ethers.js returns the checksummed address even when\n    // initially passed in a non-checksummed address. To account for that,\n    // we convert to lowercase before comparing.\n    return _.isEqual(_.toLower(x), _.toLower(y));\n  } else if (_.startsWith(type, 'uint') || _.startsWith(type, 'int')) {\n    return new configured_bignumber_1.BigNumber(x).eq(new configured_bignumber_1.BigNumber(y));\n  }\n  return _.isEqual(x, y);\n}\n// splitTupleTypes splits a tuple type string (of the form `tuple(X)` where X is\n// any other type or list of types) into its component types. It works with\n// nested tuples, so, e.g., `tuple(tuple(uint256,address),bytes32)` will yield:\n// `['tuple(uint256,address)', 'bytes32']`. It expects exactly one tuple type as\n// an argument (not an array).\nfunction splitTupleTypes(type) {\n  var e_1, _a;\n  if (_.endsWith(type, '[]')) {\n    throw new Error('Internal error: array types are not supported');\n  } else if (!_.startsWith(type, 'tuple(')) {\n    throw new Error(\"Internal error: expected tuple type but got non-tuple type: \" + type);\n  }\n  // Trim the outtermost tuple().\n  var trimmedType = type.substring('tuple('.length, type.length - 1);\n  var types = [];\n  var currToken = '';\n  var parenCount = 0;\n  try {\n    // Tokenize the type string while keeping track of parentheses.\n    for (var trimmedType_1 = __values(trimmedType), trimmedType_1_1 = trimmedType_1.next(); !trimmedType_1_1.done; trimmedType_1_1 = trimmedType_1.next()) {\n      var char = trimmedType_1_1.value;\n      switch (char) {\n        case '(':\n          parenCount += 1;\n          currToken += char;\n          break;\n        case ')':\n          parenCount -= 1;\n          currToken += char;\n          break;\n        case ',':\n          if (parenCount === 0) {\n            types.push(currToken);\n            currToken = '';\n            break;\n          } else {\n            currToken += char;\n            break;\n          }\n        default:\n          currToken += char;\n          break;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (trimmedType_1_1 && !trimmedType_1_1.done && (_a = trimmedType_1.return)) _a.call(trimmedType_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  types.push(currToken);\n  return types;\n}\nexports.abiUtils = {\n  parseEthersParams: parseEthersParams,\n  isAbiDataEqual: isAbiDataEqual,\n  splitTupleTypes: splitTupleTypes,\n  parseFunctionParam: function parseFunctionParam(param) {\n    if (param.type === 'tuple') {\n      // Parse out tuple types into {type_1, type_2, ..., type_N}\n      var tupleComponents = param.components;\n      var paramString = _.map(tupleComponents, function (component) {\n        return exports.abiUtils.parseFunctionParam(component);\n      });\n      var tupleParamString = \"{\" + paramString + \"}\";\n      return tupleParamString;\n    }\n    return param.type;\n  },\n  getFunctionSignature: function getFunctionSignature(methodAbi) {\n    var functionName = methodAbi.name;\n    var parameterTypeList = _.map(methodAbi.inputs, function (param) {\n      return exports.abiUtils.parseFunctionParam(param);\n    });\n    var functionSignature = functionName + \"(\" + parameterTypeList + \")\";\n    return functionSignature;\n  },\n  /**\n   * Solidity supports function overloading whereas TypeScript does not.\n   * See: https://solidity.readthedocs.io/en/v0.4.21/contracts.html?highlight=overload#function-overloading\n   * In order to support overloaded functions, we suffix overloaded function names with an index.\n   * This index should be deterministic, regardless of function ordering within the smart contract. To do so,\n   * we assign indexes based on the alphabetical order of function signatures.\n   *\n   * E.g\n   * ['f(uint)', 'f(uint,byte32)']\n   * Should always be renamed to:\n   * ['f1(uint)', 'f2(uint,byte32)']\n   * Regardless of the order in which these these overloaded functions are declared within the contract ABI.\n   */\n  renameOverloadedMethods: function renameOverloadedMethods(inputContractAbi) {\n    var contractAbi = _.cloneDeep(inputContractAbi);\n    var methodAbis = contractAbi.filter(function (abi) {\n      return abi.type === ethereum_types_1.AbiType.Function;\n    });\n    // Sort method Abis into alphabetical order, by function signature\n    var methodAbisOrdered = _.sortBy(methodAbis, [function (methodAbi) {\n      var functionSignature = exports.abiUtils.getFunctionSignature(methodAbi);\n      return functionSignature;\n    }]);\n    // Group method Abis by name (overloaded methods will be grouped together, in alphabetical order)\n    var methodAbisByName = {};\n    _.each(methodAbisOrdered, function (methodAbi) {\n      (methodAbisByName[methodAbi.name] || (methodAbisByName[methodAbi.name] = [])).push(methodAbi);\n    });\n    // Rename overloaded methods to overloadedMethodName1, overloadedMethodName2, ...\n    _.each(methodAbisByName, function (methodAbisWithSameName) {\n      _.each(methodAbisWithSameName, function (methodAbi, i) {\n        if (methodAbisWithSameName.length > 1) {\n          var overloadedMethodId = i + 1;\n          var sanitizedMethodName_1 = \"\" + methodAbi.name + overloadedMethodId;\n          var indexOfExistingAbiWithSanitizedMethodNameIfExists = _.findIndex(methodAbis, function (currentMethodAbi) {\n            return currentMethodAbi.name === sanitizedMethodName_1;\n          });\n          if (indexOfExistingAbiWithSanitizedMethodNameIfExists >= 0) {\n            var methodName = methodAbi.name;\n            throw new Error(\"Failed to rename overloaded method '\" + methodName + \"' to '\" + sanitizedMethodName_1 + \"'. A method with this name already exists.\");\n          }\n          methodAbi.name = sanitizedMethodName_1;\n        }\n      });\n    });\n    return contractAbi;\n  }\n};","map":{"version":3,"sources":["../../src/abi_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar _ = require(\"lodash\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n// Note(albrow): This function is unexported in ethers.js. Copying it here for\n// now.\n// Source: https://github.com/ethers-io/ethers.js/blob/884593ab76004a808bf8097e9753fb5f8dcc3067/contracts/interface.js#L30\nfunction parseEthersParams(params) {\n    var names = [];\n    var types = [];\n    params.forEach(function (param) {\n        if (param.components != null) {\n            var suffix = '';\n            var arrayBracket = param.type.indexOf('[');\n            if (arrayBracket >= 0) {\n                suffix = param.type.substring(arrayBracket);\n            }\n            var result = parseEthersParams(param.components);\n            names.push({ name: param.name || null, names: result.names });\n            types.push(\"tuple(\" + result.types.join(',') + \")\" + suffix);\n        }\n        else {\n            names.push(param.name || null);\n            types.push(param.type);\n        }\n    });\n    return {\n        names: names,\n        types: types,\n    };\n}\n// returns true if x is equal to y and false otherwise. Performs some minimal\n// type conversion and data massaging for x and y, depending on type. name and\n// type should typically be derived from parseEthersParams.\nfunction isAbiDataEqual(name, type, x, y) {\n    if (x === undefined && y === undefined) {\n        return true;\n    }\n    else if (x === undefined && y !== undefined) {\n        return false;\n    }\n    else if (x !== undefined && y === undefined) {\n        return false;\n    }\n    if (_.endsWith(type, '[]')) {\n        // For array types, we iterate through the elements and check each one\n        // individually. Strangely, name does not need to be changed in this\n        // case.\n        if (x.length !== y.length) {\n            return false;\n        }\n        var newType = _.trimEnd(type, '[]');\n        for (var i = 0; i < x.length; i++) {\n            if (!isAbiDataEqual(name, newType, x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (_.startsWith(type, 'tuple(')) {\n        if (_.isString(name)) {\n            throw new Error('Internal error: type was tuple but names was a string');\n        }\n        else if (name === null) {\n            throw new Error('Internal error: type was tuple but names was null');\n        }\n        // For tuples, we iterate through the underlying values and check each\n        // one individually.\n        var types = splitTupleTypes(type);\n        if (types.length !== name.names.length) {\n            throw new Error(\"Internal error: parameter types/names length mismatch (\" + types.length + \" != \" + name.names.length + \")\");\n        }\n        for (var i = 0; i < types.length; i++) {\n            // For tuples, name is an object with a names property that is an\n            // array. As an example, for orders, name looks like:\n            //\n            //  {\n            //      name: 'orders',\n            //      names: [\n            //          'makerAddress',\n            //          // ...\n            //          'takerAssetData'\n            //      ]\n            //  }\n            //\n            var nestedName = _.isString(name.names[i])\n                ? name.names[i]\n                : name.names[i].name;\n            if (!isAbiDataEqual(name.names[i], types[i], x[nestedName], y[nestedName])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (type === 'address' || type === 'bytes') {\n        // HACK(albrow): ethers.js returns the checksummed address even when\n        // initially passed in a non-checksummed address. To account for that,\n        // we convert to lowercase before comparing.\n        return _.isEqual(_.toLower(x), _.toLower(y));\n    }\n    else if (_.startsWith(type, 'uint') || _.startsWith(type, 'int')) {\n        return new configured_bignumber_1.BigNumber(x).eq(new configured_bignumber_1.BigNumber(y));\n    }\n    return _.isEqual(x, y);\n}\n// splitTupleTypes splits a tuple type string (of the form `tuple(X)` where X is\n// any other type or list of types) into its component types. It works with\n// nested tuples, so, e.g., `tuple(tuple(uint256,address),bytes32)` will yield:\n// `['tuple(uint256,address)', 'bytes32']`. It expects exactly one tuple type as\n// an argument (not an array).\nfunction splitTupleTypes(type) {\n    var e_1, _a;\n    if (_.endsWith(type, '[]')) {\n        throw new Error('Internal error: array types are not supported');\n    }\n    else if (!_.startsWith(type, 'tuple(')) {\n        throw new Error(\"Internal error: expected tuple type but got non-tuple type: \" + type);\n    }\n    // Trim the outtermost tuple().\n    var trimmedType = type.substring('tuple('.length, type.length - 1);\n    var types = [];\n    var currToken = '';\n    var parenCount = 0;\n    try {\n        // Tokenize the type string while keeping track of parentheses.\n        for (var trimmedType_1 = __values(trimmedType), trimmedType_1_1 = trimmedType_1.next(); !trimmedType_1_1.done; trimmedType_1_1 = trimmedType_1.next()) {\n            var char = trimmedType_1_1.value;\n            switch (char) {\n                case '(':\n                    parenCount += 1;\n                    currToken += char;\n                    break;\n                case ')':\n                    parenCount -= 1;\n                    currToken += char;\n                    break;\n                case ',':\n                    if (parenCount === 0) {\n                        types.push(currToken);\n                        currToken = '';\n                        break;\n                    }\n                    else {\n                        currToken += char;\n                        break;\n                    }\n                default:\n                    currToken += char;\n                    break;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (trimmedType_1_1 && !trimmedType_1_1.done && (_a = trimmedType_1.return)) _a.call(trimmedType_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    types.push(currToken);\n    return types;\n}\nexports.abiUtils = {\n    parseEthersParams: parseEthersParams,\n    isAbiDataEqual: isAbiDataEqual,\n    splitTupleTypes: splitTupleTypes,\n    parseFunctionParam: function (param) {\n        if (param.type === 'tuple') {\n            // Parse out tuple types into {type_1, type_2, ..., type_N}\n            var tupleComponents = param.components;\n            var paramString = _.map(tupleComponents, function (component) { return exports.abiUtils.parseFunctionParam(component); });\n            var tupleParamString = \"{\" + paramString + \"}\";\n            return tupleParamString;\n        }\n        return param.type;\n    },\n    getFunctionSignature: function (methodAbi) {\n        var functionName = methodAbi.name;\n        var parameterTypeList = _.map(methodAbi.inputs, function (param) { return exports.abiUtils.parseFunctionParam(param); });\n        var functionSignature = functionName + \"(\" + parameterTypeList + \")\";\n        return functionSignature;\n    },\n    /**\n     * Solidity supports function overloading whereas TypeScript does not.\n     * See: https://solidity.readthedocs.io/en/v0.4.21/contracts.html?highlight=overload#function-overloading\n     * In order to support overloaded functions, we suffix overloaded function names with an index.\n     * This index should be deterministic, regardless of function ordering within the smart contract. To do so,\n     * we assign indexes based on the alphabetical order of function signatures.\n     *\n     * E.g\n     * ['f(uint)', 'f(uint,byte32)']\n     * Should always be renamed to:\n     * ['f1(uint)', 'f2(uint,byte32)']\n     * Regardless of the order in which these these overloaded functions are declared within the contract ABI.\n     */\n    renameOverloadedMethods: function (inputContractAbi) {\n        var contractAbi = _.cloneDeep(inputContractAbi);\n        var methodAbis = contractAbi.filter(function (abi) { return abi.type === ethereum_types_1.AbiType.Function; });\n        // Sort method Abis into alphabetical order, by function signature\n        var methodAbisOrdered = _.sortBy(methodAbis, [\n            function (methodAbi) {\n                var functionSignature = exports.abiUtils.getFunctionSignature(methodAbi);\n                return functionSignature;\n            },\n        ]);\n        // Group method Abis by name (overloaded methods will be grouped together, in alphabetical order)\n        var methodAbisByName = {};\n        _.each(methodAbisOrdered, function (methodAbi) {\n            (methodAbisByName[methodAbi.name] || (methodAbisByName[methodAbi.name] = [])).push(methodAbi);\n        });\n        // Rename overloaded methods to overloadedMethodName1, overloadedMethodName2, ...\n        _.each(methodAbisByName, function (methodAbisWithSameName) {\n            _.each(methodAbisWithSameName, function (methodAbi, i) {\n                if (methodAbisWithSameName.length > 1) {\n                    var overloadedMethodId = i + 1;\n                    var sanitizedMethodName_1 = \"\" + methodAbi.name + overloadedMethodId;\n                    var indexOfExistingAbiWithSanitizedMethodNameIfExists = _.findIndex(methodAbis, function (currentMethodAbi) { return currentMethodAbi.name === sanitizedMethodName_1; });\n                    if (indexOfExistingAbiWithSanitizedMethodNameIfExists >= 0) {\n                        var methodName = methodAbi.name;\n                        throw new Error(\"Failed to rename overloaded method '\" + methodName + \"' to '\" + sanitizedMethodName_1 + \"'. A method with this name already exists.\");\n                    }\n                    methodAbi.name = sanitizedMethodName_1;\n                }\n            });\n        });\n        return contractAbi;\n    },\n};\n//# sourceMappingURL=abi_utils.js.map"]},"metadata":{},"sourceType":"script"}