{"ast":null,"code":"import { BigNumber, ethers } from 'ethers';\nimport { useCallback, useMemo } from 'react';\nimport { useHasPendingApproval, useTransactionAdder } from '../state/transactions/hooks';\nimport useAllowance from './useAllowance';\nimport { BNB_TICKER, BOMB_TICKER, BSHARE_TICKER, BTC_TICKER, ZAPPER_ROUTER_ADDR } from '../utils/constants';\nimport useBombFinance from './useBombFinance';\nconst APPROVE_AMOUNT = ethers.constants.MaxUint256;\nconst APPROVE_BASE_AMOUNT = BigNumber.from('1000000000000000000000000');\nexport let ApprovalState = /*#__PURE__*/function (ApprovalState) {\n  ApprovalState[ApprovalState[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ApprovalState[ApprovalState[\"NOT_APPROVED\"] = 1] = \"NOT_APPROVED\";\n  ApprovalState[ApprovalState[\"PENDING\"] = 2] = \"PENDING\";\n  ApprovalState[ApprovalState[\"APPROVED\"] = 3] = \"APPROVED\";\n  return ApprovalState;\n}({});\n\n// returns a variable indicating the state of the approval and a function which approves if necessary or early returns\nfunction useApproveZapper(zappingToken) {\n  const bombFinance = useBombFinance();\n  let token;\n  if (zappingToken === BNB_TICKER) token = bombFinance.BNB;else if (zappingToken === BOMB_TICKER) token = bombFinance.BOMB;else if (zappingToken === BSHARE_TICKER) token = bombFinance.BSHARE;else if (zappingToken === BTC_TICKER) token = bombFinance.externalTokens[BTC_TICKER];\n  const pendingApproval = useHasPendingApproval(token.address, ZAPPER_ROUTER_ADDR);\n  const currentAllowance = useAllowance(token, ZAPPER_ROUTER_ADDR, pendingApproval);\n\n  // check the current approval status\n  const approvalState = useMemo(() => {\n    // we might not have enough data to know whether or not we need to approve\n    if (token === bombFinance.BNB) return ApprovalState.APPROVED;\n    if (!currentAllowance) return ApprovalState.UNKNOWN;\n\n    // amountToApprove will be defined if currentAllowance is\n    return currentAllowance.lt(APPROVE_BASE_AMOUNT) ? pendingApproval ? ApprovalState.PENDING : ApprovalState.NOT_APPROVED : ApprovalState.APPROVED;\n  }, [currentAllowance, pendingApproval, token, bombFinance]);\n  const addTransaction = useTransactionAdder();\n  const approve = useCallback(async () => {\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily');\n      return;\n    }\n    const response = await token.approve(ZAPPER_ROUTER_ADDR, APPROVE_AMOUNT);\n    addTransaction(response, {\n      summary: `Approve ${token.symbol}`,\n      approval: {\n        tokenAddress: token.address,\n        spender: ZAPPER_ROUTER_ADDR\n      }\n    });\n  }, [approvalState, token, addTransaction]);\n  return [approvalState, approve];\n}\nexport default useApproveZapper;","map":{"version":3,"names":["BigNumber","ethers","useCallback","useMemo","useHasPendingApproval","useTransactionAdder","useAllowance","BNB_TICKER","BOMB_TICKER","BSHARE_TICKER","BTC_TICKER","ZAPPER_ROUTER_ADDR","useBombFinance","APPROVE_AMOUNT","constants","MaxUint256","APPROVE_BASE_AMOUNT","from","ApprovalState","useApproveZapper","zappingToken","bombFinance","token","BNB","BOMB","BSHARE","externalTokens","pendingApproval","address","currentAllowance","approvalState","APPROVED","UNKNOWN","lt","PENDING","NOT_APPROVED","addTransaction","approve","console","error","response","summary","symbol","approval","tokenAddress","spender"],"sources":["C:/Users/Aditya Raj Awasthi/Desktop/bomb-dashboard-final-task/src/hooks/useApproveZapper.ts"],"sourcesContent":["import {BigNumber, ethers} from 'ethers';\nimport {useCallback, useMemo} from 'react';\nimport {useHasPendingApproval, useTransactionAdder} from '../state/transactions/hooks';\nimport useAllowance from './useAllowance';\nimport ERC20 from '../bomb-finance/ERC20';\nimport {BNB_TICKER, BOMB_TICKER, BSHARE_TICKER, BTC_TICKER, ZAPPER_ROUTER_ADDR} from '../utils/constants';\nimport useBombFinance from './useBombFinance';\n\nconst APPROVE_AMOUNT = ethers.constants.MaxUint256;\nconst APPROVE_BASE_AMOUNT = BigNumber.from('1000000000000000000000000');\n\nexport enum ApprovalState {\n  UNKNOWN,\n  NOT_APPROVED,\n  PENDING,\n  APPROVED,\n}\n\n// returns a variable indicating the state of the approval and a function which approves if necessary or early returns\nfunction useApproveZapper(zappingToken: string): [ApprovalState, () => Promise<void>] {\n  const bombFinance = useBombFinance();\n  let token: ERC20;\n  if (zappingToken === BNB_TICKER) token = bombFinance.BNB;\n  else if (zappingToken === BOMB_TICKER) token = bombFinance.BOMB;\n  else if (zappingToken === BSHARE_TICKER) token = bombFinance.BSHARE;\n  else if (zappingToken === BTC_TICKER) token = bombFinance.externalTokens[BTC_TICKER];\n  const pendingApproval = useHasPendingApproval(token.address, ZAPPER_ROUTER_ADDR);\n  const currentAllowance = useAllowance(token, ZAPPER_ROUTER_ADDR, pendingApproval);\n\n  // check the current approval status\n  const approvalState: ApprovalState = useMemo(() => {\n    // we might not have enough data to know whether or not we need to approve\n    if (token === bombFinance.BNB) return ApprovalState.APPROVED;\n    if (!currentAllowance) return ApprovalState.UNKNOWN;\n\n    // amountToApprove will be defined if currentAllowance is\n    return currentAllowance.lt(APPROVE_BASE_AMOUNT)\n      ? pendingApproval\n        ? ApprovalState.PENDING\n        : ApprovalState.NOT_APPROVED\n      : ApprovalState.APPROVED;\n  }, [currentAllowance, pendingApproval, token, bombFinance]);\n\n  const addTransaction = useTransactionAdder();\n\n  const approve = useCallback(async (): Promise<void> => {\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily');\n      return;\n    }\n\n    const response = await token.approve(ZAPPER_ROUTER_ADDR, APPROVE_AMOUNT);\n    addTransaction(response, {\n      summary: `Approve ${token.symbol}`,\n      approval: {\n        tokenAddress: token.address,\n        spender: ZAPPER_ROUTER_ADDR,\n      },\n    });\n  }, [approvalState, token, addTransaction]);\n\n  return [approvalState, approve];\n}\n\nexport default useApproveZapper;\n"],"mappings":"AAAA,SAAQA,SAAS,EAAEC,MAAM,QAAO,QAAQ;AACxC,SAAQC,WAAW,EAAEC,OAAO,QAAO,OAAO;AAC1C,SAAQC,qBAAqB,EAAEC,mBAAmB,QAAO,6BAA6B;AACtF,OAAOC,YAAY,MAAM,gBAAgB;AAEzC,SAAQC,UAAU,EAAEC,WAAW,EAAEC,aAAa,EAAEC,UAAU,EAAEC,kBAAkB,QAAO,oBAAoB;AACzG,OAAOC,cAAc,MAAM,kBAAkB;AAE7C,MAAMC,cAAc,GAAGZ,MAAM,CAACa,SAAS,CAACC,UAAU;AAClD,MAAMC,mBAAmB,GAAGhB,SAAS,CAACiB,IAAI,CAAC,2BAA2B,CAAC;AAEvE,WAAYC,aAAa,0BAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAA,OAAbA,aAAa;AAAA;;AAOzB;AACA,SAASC,gBAAgBA,CAACC,YAAoB,EAAwC;EACpF,MAAMC,WAAW,GAAGT,cAAc,EAAE;EACpC,IAAIU,KAAY;EAChB,IAAIF,YAAY,KAAKb,UAAU,EAAEe,KAAK,GAAGD,WAAW,CAACE,GAAG,CAAC,KACpD,IAAIH,YAAY,KAAKZ,WAAW,EAAEc,KAAK,GAAGD,WAAW,CAACG,IAAI,CAAC,KAC3D,IAAIJ,YAAY,KAAKX,aAAa,EAAEa,KAAK,GAAGD,WAAW,CAACI,MAAM,CAAC,KAC/D,IAAIL,YAAY,KAAKV,UAAU,EAAEY,KAAK,GAAGD,WAAW,CAACK,cAAc,CAAChB,UAAU,CAAC;EACpF,MAAMiB,eAAe,GAAGvB,qBAAqB,CAACkB,KAAK,CAACM,OAAO,EAAEjB,kBAAkB,CAAC;EAChF,MAAMkB,gBAAgB,GAAGvB,YAAY,CAACgB,KAAK,EAAEX,kBAAkB,EAAEgB,eAAe,CAAC;;EAEjF;EACA,MAAMG,aAA4B,GAAG3B,OAAO,CAAC,MAAM;IACjD;IACA,IAAImB,KAAK,KAAKD,WAAW,CAACE,GAAG,EAAE,OAAOL,aAAa,CAACa,QAAQ;IAC5D,IAAI,CAACF,gBAAgB,EAAE,OAAOX,aAAa,CAACc,OAAO;;IAEnD;IACA,OAAOH,gBAAgB,CAACI,EAAE,CAACjB,mBAAmB,CAAC,GAC3CW,eAAe,GACbT,aAAa,CAACgB,OAAO,GACrBhB,aAAa,CAACiB,YAAY,GAC5BjB,aAAa,CAACa,QAAQ;EAC5B,CAAC,EAAE,CAACF,gBAAgB,EAAEF,eAAe,EAAEL,KAAK,EAAED,WAAW,CAAC,CAAC;EAE3D,MAAMe,cAAc,GAAG/B,mBAAmB,EAAE;EAE5C,MAAMgC,OAAO,GAAGnC,WAAW,CAAC,YAA2B;IACrD,IAAI4B,aAAa,KAAKZ,aAAa,CAACiB,YAAY,EAAE;MAChDG,OAAO,CAACC,KAAK,CAAC,kCAAkC,CAAC;MACjD;IACF;IAEA,MAAMC,QAAQ,GAAG,MAAMlB,KAAK,CAACe,OAAO,CAAC1B,kBAAkB,EAAEE,cAAc,CAAC;IACxEuB,cAAc,CAACI,QAAQ,EAAE;MACvBC,OAAO,EAAG,WAAUnB,KAAK,CAACoB,MAAO,EAAC;MAClCC,QAAQ,EAAE;QACRC,YAAY,EAAEtB,KAAK,CAACM,OAAO;QAC3BiB,OAAO,EAAElC;MACX;IACF,CAAC,CAAC;EACJ,CAAC,EAAE,CAACmB,aAAa,EAAER,KAAK,EAAEc,cAAc,CAAC,CAAC;EAE1C,OAAO,CAACN,aAAa,EAAEO,OAAO,CAAC;AACjC;AAEA,eAAelB,gBAAgB"},"metadata":{},"sourceType":"module"}