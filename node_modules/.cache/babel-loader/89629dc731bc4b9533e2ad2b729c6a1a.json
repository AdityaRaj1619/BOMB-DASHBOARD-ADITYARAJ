{"ast":null,"code":"const inherits = require('util').inherits;\nconst ethUtil = require('ethereumjs-util');\nconst BN = ethUtil.BN;\nconst clone = require('clone');\nconst cacheUtils = require('../util/rpc-cache-utils.js');\nconst Stoplight = require('../util/stoplight.js');\nconst Subprovider = require('./subprovider.js');\nmodule.exports = BlockCacheProvider;\ninherits(BlockCacheProvider, Subprovider);\nfunction BlockCacheProvider(opts) {\n  const self = this;\n  opts = opts || {};\n  // set initialization blocker\n  self._ready = new Stoplight();\n  self.strategies = {\n    perma: new ConditionalPermaCacheStrategy({\n      eth_getTransactionByHash: containsBlockhash,\n      eth_getTransactionReceipt: containsBlockhash\n    }),\n    block: new BlockCacheStrategy(self),\n    fork: new BlockCacheStrategy(self)\n  };\n}\n\n// setup a block listener on 'setEngine'\nBlockCacheProvider.prototype.setEngine = function (engine) {\n  const self = this;\n  self.engine = engine;\n  // unblock initialization after first block\n  engine.once('block', function (block) {\n    self.currentBlock = block;\n    self._ready.go();\n    // from now on, empty old cache every block\n    engine.on('block', clearOldCache);\n  });\n  function clearOldCache(newBlock) {\n    var previousBlock = self.currentBlock;\n    self.currentBlock = newBlock;\n    if (!previousBlock) return;\n    self.strategies.block.cacheRollOff(previousBlock);\n    self.strategies.fork.cacheRollOff(previousBlock);\n  }\n};\nBlockCacheProvider.prototype.handleRequest = function (payload, next, end) {\n  const self = this;\n\n  // skip cache if told to do so\n  if (payload.skipCache) {\n    // console.log('CACHE SKIP - skip cache if told to do so')\n    return next();\n  }\n\n  // Ignore block polling requests.\n  if (payload.method === 'eth_getBlockByNumber' && payload.params[0] === 'latest') {\n    // console.log('CACHE SKIP - Ignore block polling requests.')\n    return next();\n  }\n\n  // wait for first block\n  self._ready.await(function () {\n    // actually handle the request\n    self._handleRequest(payload, next, end);\n  });\n};\nBlockCacheProvider.prototype._handleRequest = function (payload, next, end) {\n  const self = this;\n  var type = cacheUtils.cacheTypeForPayload(payload);\n  var strategy = this.strategies[type];\n\n  // If there's no strategy in place, pass it down the chain.\n  if (!strategy) {\n    return next();\n  }\n\n  // If the strategy can't cache this request, ignore it.\n  if (!strategy.canCache(payload)) {\n    return next();\n  }\n  var blockTag = cacheUtils.blockTagForPayload(payload);\n  if (!blockTag) blockTag = 'latest';\n  var requestedBlockNumber;\n  if (blockTag === 'earliest') {\n    requestedBlockNumber = '0x00';\n  } else if (blockTag === 'latest') {\n    requestedBlockNumber = ethUtil.bufferToHex(self.currentBlock.number);\n  } else {\n    // We have a hex number\n    requestedBlockNumber = blockTag;\n  }\n\n  //console.log('REQUEST at block 0x' + requestedBlockNumber.toString('hex'))\n\n  // end on a hit, continue on a miss\n  strategy.hitCheck(payload, requestedBlockNumber, end, function () {\n    // miss fallthrough to provider chain, caching the result on the way back up.\n    next(function (err, result, cb) {\n      // err is already handled by engine\n      if (err) return cb();\n      strategy.cacheResult(payload, result, requestedBlockNumber, cb);\n    });\n  });\n};\n\n//\n// Cache Strategies\n//\n\nfunction PermaCacheStrategy() {\n  var self = this;\n  self.cache = {};\n  // clear cache every ten minutes\n  var timeout = setInterval(function () {\n    self.cache = {};\n  }, 10 * 60 * 1e3);\n  // do not require the Node.js event loop to remain active\n  if (timeout.unref) timeout.unref();\n}\nPermaCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n  var cached = this.cache[identifier];\n  if (!cached) return miss();\n\n  // If the block number we're requesting at is greater than or\n  // equal to the block where we cached a previous response,\n  // the cache is valid. If it's from earlier than the cache,\n  // send it back down to the client (where it will be recached.)\n  var cacheIsEarlyEnough = compareHex(requestedBlockNumber, cached.blockNumber) >= 0;\n  if (cacheIsEarlyEnough) {\n    var clonedValue = clone(cached.result);\n    return hit(null, clonedValue);\n  } else {\n    return miss();\n  }\n};\nPermaCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n  if (result) {\n    var clonedValue = clone(result);\n    this.cache[identifier] = {\n      blockNumber: requestedBlockNumber,\n      result: clonedValue\n    };\n  }\n  callback();\n};\nPermaCacheStrategy.prototype.canCache = function (payload) {\n  return cacheUtils.canCache(payload);\n};\n\n//\n// ConditionalPermaCacheStrategy\n//\n\nfunction ConditionalPermaCacheStrategy(conditionals) {\n  this.strategy = new PermaCacheStrategy();\n  this.conditionals = conditionals;\n}\nConditionalPermaCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {\n  return this.strategy.hitCheck(payload, requestedBlockNumber, hit, miss);\n};\nConditionalPermaCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {\n  var conditional = this.conditionals[payload.method];\n  if (conditional) {\n    if (conditional(result)) {\n      this.strategy.cacheResult(payload, result, requestedBlockNumber, callback);\n    } else {\n      callback();\n    }\n  } else {\n    // Cache all requests that don't have a conditional\n    this.strategy.cacheResult(payload, result, requestedBlockNumber, callback);\n  }\n};\nConditionalPermaCacheStrategy.prototype.canCache = function (payload) {\n  return this.strategy.canCache(payload);\n};\n\n//\n// BlockCacheStrategy\n//\n\nfunction BlockCacheStrategy() {\n  this.cache = {};\n}\nBlockCacheStrategy.prototype.getBlockCacheForPayload = function (payload, blockNumberHex) {\n  const blockNumber = Number.parseInt(blockNumberHex, 16);\n  let blockCache = this.cache[blockNumber];\n  // create new cache if necesary\n  if (!blockCache) {\n    const newCache = {};\n    this.cache[blockNumber] = newCache;\n    blockCache = newCache;\n  }\n  return blockCache;\n};\nBlockCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {\n  var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n  if (!blockCache) {\n    return miss();\n  }\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n  var cached = blockCache[identifier];\n  if (cached) {\n    return hit(null, cached);\n  } else {\n    return miss();\n  }\n};\nBlockCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {\n  if (result) {\n    var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n    var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n    blockCache[identifier] = result;\n  }\n  callback();\n};\nBlockCacheStrategy.prototype.canCache = function (payload) {\n  if (!cacheUtils.canCache(payload)) {\n    return false;\n  }\n  var blockTag = cacheUtils.blockTagForPayload(payload);\n  return blockTag !== 'pending';\n};\n\n// naively removes older block caches\nBlockCacheStrategy.prototype.cacheRollOff = function (previousBlock) {\n  const self = this;\n  const previousHex = ethUtil.bufferToHex(previousBlock.number);\n  const oldBlockNumber = Number.parseInt(previousHex, 16);\n  // clear old caches\n  Object.keys(self.cache).map(Number).filter(num => num <= oldBlockNumber).forEach(num => delete self.cache[num]);\n};\n\n// util\n\nfunction compareHex(hexA, hexB) {\n  var numA = parseInt(hexA, 16);\n  var numB = parseInt(hexB, 16);\n  return numA === numB ? 0 : numA > numB ? 1 : -1;\n}\nfunction hexToBN(hex) {\n  return new BN(ethUtil.toBuffer(hex));\n}\nfunction containsBlockhash(result) {\n  if (!result) return false;\n  if (!result.blockHash) return false;\n  const hasNonZeroHash = hexToBN(result.blockHash).gt(new BN(0));\n  return hasNonZeroHash;\n}","map":{"version":3,"names":["inherits","require","ethUtil","BN","clone","cacheUtils","Stoplight","Subprovider","module","exports","BlockCacheProvider","opts","self","_ready","strategies","perma","ConditionalPermaCacheStrategy","eth_getTransactionByHash","containsBlockhash","eth_getTransactionReceipt","block","BlockCacheStrategy","fork","prototype","setEngine","engine","once","currentBlock","go","on","clearOldCache","newBlock","previousBlock","cacheRollOff","handleRequest","payload","next","end","skipCache","method","params","await","_handleRequest","type","cacheTypeForPayload","strategy","canCache","blockTag","blockTagForPayload","requestedBlockNumber","bufferToHex","number","hitCheck","err","result","cb","cacheResult","PermaCacheStrategy","cache","timeout","setInterval","unref","hit","miss","identifier","cacheIdentifierForPayload","cached","cacheIsEarlyEnough","compareHex","blockNumber","clonedValue","callback","conditionals","conditional","getBlockCacheForPayload","blockNumberHex","Number","parseInt","blockCache","newCache","previousHex","oldBlockNumber","Object","keys","map","filter","num","forEach","hexA","hexB","numA","numB","hexToBN","hex","toBuffer","blockHash","hasNonZeroHash","gt"],"sources":["C:/Users/Aditya Raj Awasthi/Desktop/bomb-dashboard-final-task/node_modules/web3-provider-engine/subproviders/cache.js"],"sourcesContent":["const inherits = require('util').inherits\nconst ethUtil = require('ethereumjs-util')\nconst BN = ethUtil.BN\nconst clone = require('clone')\nconst cacheUtils = require('../util/rpc-cache-utils.js')\nconst Stoplight = require('../util/stoplight.js')\nconst Subprovider = require('./subprovider.js')\n\nmodule.exports = BlockCacheProvider\n\ninherits(BlockCacheProvider, Subprovider)\n\nfunction BlockCacheProvider(opts) {\n  const self = this\n  opts = opts || {}\n  // set initialization blocker\n  self._ready = new Stoplight()\n  self.strategies = {\n    perma: new ConditionalPermaCacheStrategy({\n      eth_getTransactionByHash: containsBlockhash,\n      eth_getTransactionReceipt: containsBlockhash,\n    }),\n    block: new BlockCacheStrategy(self),\n    fork: new BlockCacheStrategy(self),\n  }\n}\n\n// setup a block listener on 'setEngine'\nBlockCacheProvider.prototype.setEngine = function(engine) {\n  const self = this\n  self.engine = engine\n  // unblock initialization after first block\n  engine.once('block', function(block) {\n    self.currentBlock = block\n    self._ready.go()\n    // from now on, empty old cache every block\n    engine.on('block', clearOldCache)\n  })\n\n  function clearOldCache(newBlock) {\n    var previousBlock = self.currentBlock\n    self.currentBlock = newBlock\n    if (!previousBlock) return\n    self.strategies.block.cacheRollOff(previousBlock)\n    self.strategies.fork.cacheRollOff(previousBlock)\n  }\n}\n\nBlockCacheProvider.prototype.handleRequest = function(payload, next, end){\n  const self = this\n\n  // skip cache if told to do so\n  if (payload.skipCache) {\n    // console.log('CACHE SKIP - skip cache if told to do so')\n    return next()\n  }\n\n  // Ignore block polling requests.\n  if (payload.method === 'eth_getBlockByNumber' && payload.params[0] === 'latest') {\n    // console.log('CACHE SKIP - Ignore block polling requests.')\n    return next()\n  }\n\n  // wait for first block\n  self._ready.await(function(){\n    // actually handle the request\n    self._handleRequest(payload, next, end)\n  })\n}\n\nBlockCacheProvider.prototype._handleRequest = function(payload, next, end){\n  const self = this\n\n  var type = cacheUtils.cacheTypeForPayload(payload)\n  var strategy = this.strategies[type]\n\n  // If there's no strategy in place, pass it down the chain.\n  if (!strategy) {\n    return next()\n  }\n\n  // If the strategy can't cache this request, ignore it.\n  if (!strategy.canCache(payload)) {\n    return next()\n  }\n\n  var blockTag = cacheUtils.blockTagForPayload(payload)\n  if (!blockTag) blockTag = 'latest'\n  var requestedBlockNumber\n\n  if (blockTag === 'earliest') {\n    requestedBlockNumber = '0x00'\n  } else if (blockTag === 'latest') {\n    requestedBlockNumber = ethUtil.bufferToHex(self.currentBlock.number)\n  } else {\n    // We have a hex number\n    requestedBlockNumber = blockTag\n  }\n\n  //console.log('REQUEST at block 0x' + requestedBlockNumber.toString('hex'))\n\n  // end on a hit, continue on a miss\n  strategy.hitCheck(payload, requestedBlockNumber, end, function() {\n    // miss fallthrough to provider chain, caching the result on the way back up.\n    next(function(err, result, cb) {\n      // err is already handled by engine\n      if (err) return cb()\n      strategy.cacheResult(payload, result, requestedBlockNumber, cb)\n    })\n  })\n}\n\n//\n// Cache Strategies\n//\n\nfunction PermaCacheStrategy() {\n  var self = this\n  self.cache = {}\n  // clear cache every ten minutes\n  var timeout = setInterval(function(){\n    self.cache = {}\n  }, 10 * 60 * 1e3)\n  // do not require the Node.js event loop to remain active\n  if (timeout.unref) timeout.unref()\n}\n\nPermaCacheStrategy.prototype.hitCheck = function(payload, requestedBlockNumber, hit, miss) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n  var cached = this.cache[identifier]\n\n  if (!cached) return miss()\n\n  // If the block number we're requesting at is greater than or\n  // equal to the block where we cached a previous response,\n  // the cache is valid. If it's from earlier than the cache,\n  // send it back down to the client (where it will be recached.)\n  var cacheIsEarlyEnough = compareHex(requestedBlockNumber, cached.blockNumber) >= 0\n  if (cacheIsEarlyEnough) {\n    var clonedValue = clone(cached.result)\n    return hit(null, clonedValue)\n  } else {\n    return miss()\n  }\n}\n\nPermaCacheStrategy.prototype.cacheResult = function(payload, result, requestedBlockNumber, callback) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n\n  if (result) {\n    var clonedValue = clone(result)\n    this.cache[identifier] = {\n      blockNumber: requestedBlockNumber,\n      result: clonedValue,\n    }\n  }\n\n  callback()\n}\n\nPermaCacheStrategy.prototype.canCache = function(payload) {\n  return cacheUtils.canCache(payload)\n}\n\n//\n// ConditionalPermaCacheStrategy\n//\n\nfunction ConditionalPermaCacheStrategy(conditionals) {\n  this.strategy = new PermaCacheStrategy()\n  this.conditionals = conditionals\n}\n\nConditionalPermaCacheStrategy.prototype.hitCheck = function(payload, requestedBlockNumber, hit, miss) {\n  return this.strategy.hitCheck(payload, requestedBlockNumber, hit, miss)\n}\n\nConditionalPermaCacheStrategy.prototype.cacheResult = function(payload, result, requestedBlockNumber, callback) {\n  var conditional = this.conditionals[payload.method]\n\n  if (conditional) {\n    if (conditional(result)) {\n      this.strategy.cacheResult(payload, result, requestedBlockNumber, callback)\n    } else {\n      callback()\n    }\n  } else {\n    // Cache all requests that don't have a conditional\n    this.strategy.cacheResult(payload, result, requestedBlockNumber, callback)\n  }\n}\n\nConditionalPermaCacheStrategy.prototype.canCache = function(payload) {\n  return this.strategy.canCache(payload)\n}\n\n//\n// BlockCacheStrategy\n//\n\nfunction BlockCacheStrategy() {\n  this.cache = {}\n}\n\nBlockCacheStrategy.prototype.getBlockCacheForPayload = function(payload, blockNumberHex) {\n  const blockNumber = Number.parseInt(blockNumberHex, 16)\n  let blockCache = this.cache[blockNumber]\n  // create new cache if necesary\n  if (!blockCache) {\n    const newCache = {}\n    this.cache[blockNumber] = newCache\n    blockCache = newCache\n  }\n  return blockCache\n}\n\nBlockCacheStrategy.prototype.hitCheck = function(payload, requestedBlockNumber, hit, miss) {\n  var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n\n  if (!blockCache) {\n    return miss()\n  }\n\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n  var cached = blockCache[identifier]\n\n  if (cached) {\n    return hit(null, cached)\n  } else {\n    return miss()\n  }\n}\n\nBlockCacheStrategy.prototype.cacheResult = function(payload, result, requestedBlockNumber, callback) {\n  if (result) {\n    var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n    blockCache[identifier] = result\n  }\n  callback()\n}\n\nBlockCacheStrategy.prototype.canCache = function(payload) {\n  if (!cacheUtils.canCache(payload)) {\n    return false\n  }\n\n  var blockTag = cacheUtils.blockTagForPayload(payload)\n\n  return (blockTag !== 'pending')\n}\n\n// naively removes older block caches\nBlockCacheStrategy.prototype.cacheRollOff = function(previousBlock){\n  const self = this\n  const previousHex = ethUtil.bufferToHex(previousBlock.number)\n  const oldBlockNumber = Number.parseInt(previousHex, 16)\n  // clear old caches\n  Object.keys(self.cache)\n    .map(Number)\n    .filter(num => num <= oldBlockNumber)\n    .forEach(num => delete self.cache[num])\n}\n\n\n// util\n\nfunction compareHex(hexA, hexB){\n  var numA = parseInt(hexA, 16)\n  var numB = parseInt(hexB, 16)\n  return numA === numB ? 0 : (numA > numB ? 1 : -1 )\n}\n\nfunction hexToBN(hex){\n  return new BN(ethUtil.toBuffer(hex))\n}\n\nfunction containsBlockhash(result) {\n  if (!result) return false\n  if (!result.blockHash) return false\n  const hasNonZeroHash = hexToBN(result.blockHash).gt(new BN(0))\n  return hasNonZeroHash\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}