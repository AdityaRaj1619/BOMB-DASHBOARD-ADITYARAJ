{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _ = require(\"lodash\");\nfunction parseNode(node) {\n  var components = [];\n  _.each(node.children, function (child) {\n    var component = parseNode(child);\n    components.push(component);\n  });\n  var dataItem = {\n    name: node.name,\n    type: node.value\n  };\n  if (!_.isEmpty(components)) {\n    dataItem.components = components;\n  }\n  return dataItem;\n}\n/**\n * Returns a DataItem corresponding to the input signature.\n * A signature can be in two forms: `type` or `(type_1,type_2,...,type_n)`\n * An example of the first form would be 'address' or 'uint256[]' or 'bytes[5][]'\n * An example of the second form would be '(address,uint256)' or '(address,uint256)[]'\n * @param signature of input DataItem.\n * @return DataItem derived from input signature.\n */\nfunction generateDataItemFromSignature(signature) {\n  var e_1, _a;\n  // No data item corresponds to an empty signature\n  if (_.isEmpty(signature)) {\n    throw new Error(\"Cannot parse data item from empty signature, ''\");\n  }\n  // Create a parse tree for data item\n  var node = {\n    name: '',\n    value: '',\n    children: []\n  };\n  try {\n    for (var signature_1 = __values(signature), signature_1_1 = signature_1.next(); !signature_1_1.done; signature_1_1 = signature_1.next()) {\n      var char = signature_1_1.value;\n      switch (char) {\n        case '(':\n          var child = {\n            name: '',\n            value: '',\n            children: [],\n            parent: node\n          };\n          node.value = 'tuple';\n          node.children.push(child);\n          node = child;\n          break;\n        case ')':\n          node = node.parent;\n          break;\n        case ',':\n          var sibling = {\n            name: '',\n            value: '',\n            children: [],\n            parent: node.parent\n          };\n          node.parent.children.push(sibling);\n          node = sibling;\n          break;\n        case ' ':\n          node.name = node.value;\n          node.value = '';\n          break;\n        default:\n          node.value += char;\n          break;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (signature_1_1 && !signature_1_1.done && (_a = signature_1.return)) _a.call(signature_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  // Interpret data item from parse tree\n  var dataItem = parseNode(node);\n  return dataItem;\n}\nexports.generateDataItemFromSignature = generateDataItemFromSignature;","map":{"version":3,"sources":["../../../../src/abi_encoder/utils/signature_parser.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AACA,IAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AASA,SAAS,SAAS,CAAC,IAAU,EAAA;EACzB,IAAM,UAAU,GAAe,EAAE;EACjC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAC,KAAW,EAAA;IAC9B,IAAM,SAAS,GAAG,SAAS,CAAC,KAAK,CAAC;IAClC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC;EAC9B,CAAC,CAAC;EACF,IAAM,QAAQ,GAAa;IACvB,IAAI,EAAE,IAAI,CAAC,IAAI;IACf,IAAI,EAAE,IAAI,CAAC;GACd;EACD,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;IACxB,QAAQ,CAAC,UAAU,GAAG,UAAU;EACnC;EACD,OAAO,QAAQ;AACnB;AAEA;;;;;;;AAOG;AACH,SAAgB,6BAA6B,CAAC,SAAiB,EAAA;;EAC3D;EACA,IAAI,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;IACtB,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC;EACrE;EACD;EACA,IAAI,IAAI,GAAS;IACb,IAAI,EAAE,EAAE;IACR,KAAK,EAAE,EAAE;IACT,QAAQ,EAAE;GACb;;IACD,KAAmB,IAAA,WAAA,GAAA,QAAA,CAAA,SAAS,CAAA,EAAA,aAAA,GAAA,WAAA,CAAA,IAAA,EAAA,EAAA,CAAA,aAAA,CAAA,IAAA,EAAA,aAAA,GAAA,WAAA,CAAA,IAAA,EAAA,EAAE;MAAzB,IAAM,IAAI,GAAA,aAAA,CAAA,KAAA;MACX,QAAQ,IAAI;QACR,KAAK,GAAG;UACJ,IAAM,KAAK,GAAG;YACV,IAAI,EAAE,EAAE;YACR,KAAK,EAAE,EAAE;YACT,QAAQ,EAAE,EAAE;YACZ,MAAM,EAAE;WACX;UACD,IAAI,CAAC,KAAK,GAAG,OAAO;UACpB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;UACzB,IAAI,GAAG,KAAK;UACZ;QAEJ,KAAK,GAAG;UACJ,IAAI,GAAG,IAAI,CAAC,MAAc;UAC1B;QAEJ,KAAK,GAAG;UACJ,IAAM,OAAO,GAAG;YACZ,IAAI,EAAE,EAAE;YACR,KAAK,EAAE,EAAE;YACT,QAAQ,EAAE,EAAE;YACZ,MAAM,EAAE,IAAI,CAAC;WAChB;UACA,IAAI,CAAC,MAAe,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC;UAC5C,IAAI,GAAG,OAAO;UACd;QAEJ,KAAK,GAAG;UACJ,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK;UACtB,IAAI,CAAC,KAAK,GAAG,EAAE;UACf;QAEJ;UACI,IAAI,CAAC,KAAK,IAAI,IAAI;UAClB;MAAM;IAEjB;;;;;;;;;;;;EACD;EACA,IAAM,QAAQ,GAAG,SAAS,CAAC,IAAI,CAAC;EAChC,OAAO,QAAQ;AACnB;AArDA,OAAA,CAAA,6BAAA,GAAA,6BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = require(\"lodash\");\nfunction parseNode(node) {\n    var components = [];\n    _.each(node.children, function (child) {\n        var component = parseNode(child);\n        components.push(component);\n    });\n    var dataItem = {\n        name: node.name,\n        type: node.value,\n    };\n    if (!_.isEmpty(components)) {\n        dataItem.components = components;\n    }\n    return dataItem;\n}\n/**\n * Returns a DataItem corresponding to the input signature.\n * A signature can be in two forms: `type` or `(type_1,type_2,...,type_n)`\n * An example of the first form would be 'address' or 'uint256[]' or 'bytes[5][]'\n * An example of the second form would be '(address,uint256)' or '(address,uint256)[]'\n * @param signature of input DataItem.\n * @return DataItem derived from input signature.\n */\nfunction generateDataItemFromSignature(signature) {\n    var e_1, _a;\n    // No data item corresponds to an empty signature\n    if (_.isEmpty(signature)) {\n        throw new Error(\"Cannot parse data item from empty signature, ''\");\n    }\n    // Create a parse tree for data item\n    var node = {\n        name: '',\n        value: '',\n        children: [],\n    };\n    try {\n        for (var signature_1 = __values(signature), signature_1_1 = signature_1.next(); !signature_1_1.done; signature_1_1 = signature_1.next()) {\n            var char = signature_1_1.value;\n            switch (char) {\n                case '(':\n                    var child = {\n                        name: '',\n                        value: '',\n                        children: [],\n                        parent: node,\n                    };\n                    node.value = 'tuple';\n                    node.children.push(child);\n                    node = child;\n                    break;\n                case ')':\n                    node = node.parent;\n                    break;\n                case ',':\n                    var sibling = {\n                        name: '',\n                        value: '',\n                        children: [],\n                        parent: node.parent,\n                    };\n                    node.parent.children.push(sibling);\n                    node = sibling;\n                    break;\n                case ' ':\n                    node.name = node.value;\n                    node.value = '';\n                    break;\n                default:\n                    node.value += char;\n                    break;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (signature_1_1 && !signature_1_1.done && (_a = signature_1.return)) _a.call(signature_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // Interpret data item from parse tree\n    var dataItem = parseNode(node);\n    return dataItem;\n}\nexports.generateDataItemFromSignature = generateDataItemFromSignature;\n//# sourceMappingURL=signature_parser.js.map"]},"metadata":{},"sourceType":"script"}