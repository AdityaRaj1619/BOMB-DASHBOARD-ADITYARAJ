{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _ = require(\"lodash\");\nexports.providerUtils = {\n  /**\n   * Starts the Web3ProviderEngine without excess block polling\n   * @param providerEngine The Web3ProviderEngine\n   */\n  startProviderEngine: function (providerEngine) {\n    if (providerEngine.start === undefined) {\n      throw new Error(\"Invalid Web3ProviderEngine\");\n    }\n    // HACK: When calling start() Web3ProviderEngine starts a block polling service\n    // this continuously pulls data from the network and can result in high data usage\n    // for long running services. If used in a front end application this can cause\n    // a high amount of load on a node (one request per user per block).\n    providerEngine._ready.go();\n    providerEngine._running = true;\n  },\n  /**\n   * Standardize the supported provider types into our internal provider interface\n   * or throw if unsupported provider supplied.\n   * @param supportedProvider Potentially supported provider instance\n   * @return Provider that conforms of our internal provider interface\n   */\n  standardizeOrThrow: function (supportedProvider) {\n    if (supportedProvider === undefined) {\n      throw new Error(\"supportedProvider cannot be 'undefined'\");\n    }\n    var provider = {\n      isStandardizedProvider: true,\n      isMetaMask: supportedProvider.isMetaMask,\n      isParity: supportedProvider.isParity,\n      stop: supportedProvider.stop,\n      enable: supportedProvider.enable,\n      sendAsync: _.noop.bind(_)\n    };\n    // Case 1: We've already converted to our ZeroExProvider so noop.\n    if (supportedProvider.isStandardizedProvider) {\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n      return supportedProvider;\n      // Case 2: It's a compliant EIP 1193 Provider\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n    } else if (supportedProvider.isEIP1193) {\n      provider.sendAsync = function (payload, callback) {\n        var method = payload.method;\n        var params = payload.params;\n        supportedProvider.send(method, params).then(function (result) {\n          callback(null, result);\n        }).catch(function (err) {\n          callback(err);\n        });\n      };\n      return provider;\n      // Case 3: The provider has a `sendAsync` method, so we use it.\n    } else if (supportedProvider.sendAsync !== undefined) {\n      provider.sendAsync = supportedProvider.sendAsync.bind(supportedProvider);\n      return provider;\n      // Case 4: The provider does not have a `sendAsync` method but does have a `send` method\n    } else if (supportedProvider.send !== undefined) {\n      // HACK(fabio): Detect if the `send` method has the old interface `send(payload, cb)` such\n      // as in versions < Web3.js@1.0.0-beta.37. If so, do a simple re-mapping\n      if (_.includes(supportedProvider.send.toString(), 'function (payload, callback)')) {\n        provider.sendAsync = supportedProvider.send.bind(supportedProvider);\n        return provider;\n      } else {\n        // If doesn't have old interface, we assume it has new interface `send(method, payload)`\n        // such as in versions > Web3.js@1.0.0-beta.38 and convert it to `sendAsync`\n        provider.sendAsync = function (payload, callback) {\n          var method = payload.method;\n          var params = payload.params;\n          supportedProvider.send(method, params).then(function (result) {\n            callback(null, result);\n          }).catch(function (err) {\n            callback(err);\n          });\n        };\n        return provider;\n      }\n    }\n    throw new Error(\"Unsupported provider found. Please make sure it conforms to one of the supported providers. See 'Provider' type in 'ethereum-types' package.\");\n  }\n};","map":{"version":3,"sources":["../../src/provider_utils.ts"],"names":[],"mappings":";;;;;AAOA,IAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAEa,OAAA,CAAA,aAAa,GAAG;EACzB;;;AAGG;EACH,mBAAmB,EAAnB,SAAA,CAAoB,cAAmB,EAAA;IACnC,IAAI,cAAc,CAAC,KAAK,KAAK,SAAS,EAAE;MACpC,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC;IAChD;IACD;IACA;IACA;IACA;IACA,cAAc,CAAC,MAAM,CAAC,EAAE,EAAE;IAC1B,cAAc,CAAC,QAAQ,GAAG,IAAI;EAClC,CAAC;EACD;;;;;AAKG;EACH,kBAAkB,EAAlB,SAAA,CAAmB,iBAAoC,EAAA;IACnD,IAAI,iBAAiB,KAAK,SAAS,EAAE;MACjC,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC;IAC7D;IACD,IAAM,QAAQ,GAAG;MACb,sBAAsB,EAAE,IAAI;MAC5B,UAAU,EAAG,iBAAyB,CAAC,UAAU;MACjD,QAAQ,EAAG,iBAAyB,CAAC,QAAQ;MAC7C,IAAI,EAAG,iBAAyB,CAAC,IAAI;MACrC,MAAM,EAAG,iBAAyB,CAAC,MAAM;MACzC,SAAS,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAC3B;IACD;IACA,IAAK,iBAAyB,CAAC,sBAAsB,EAAE;MACnD;MACA,OAAO,iBAAmC;MAC1C;MACA;KACH,MAAM,IAAK,iBAAqC,CAAC,SAAS,EAAE;MACzD,QAAQ,CAAC,SAAS,GAAG,UAAC,OAA8B,EAAE,QAA8B,EAAA;QAChF,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM;QAC7B,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM;QAC5B,iBAAyB,CACrB,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CACpB,IAAI,CAAC,UAAC,MAAW,EAAA;UACd,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;QAC1B,CAAC,CAAC,CACD,KAAK,CAAC,UAAC,GAAU,EAAA;UACd,QAAQ,CAAC,GAAG,CAAC;QACjB,CAAC,CAAC;MACV,CAAC;MACD,OAAO,QAAQ;MACf;KACH,MAAM,IAAK,iBAAyB,CAAC,SAAS,KAAK,SAAS,EAAE;MAC3D,QAAQ,CAAC,SAAS,GAAI,iBAAyB,CAAC,SAAS,CAAC,IAAI,CAAC,iBAAiB,CAAC;MACjF,OAAO,QAAQ;MACf;KACH,MAAM,IAAK,iBAAyB,CAAC,IAAI,KAAK,SAAS,EAAE;MACtD;MACA;MACA,IAAI,CAAC,CAAC,QAAQ,CAAE,iBAAyB,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,8BAA8B,CAAC,EAAE;QACxF,QAAQ,CAAC,SAAS,GAAI,iBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC;QAC5E,OAAO,QAAQ;OAClB,MAAM;QACH;QACA;QACA,QAAQ,CAAC,SAAS,GAAG,UAAC,OAA8B,EAAE,QAA8B,EAAA;UAChF,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM;UAC7B,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM;UAC5B,iBAAyB,CACrB,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CACpB,IAAI,CAAC,UAAC,MAAW,EAAA;YACd,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;UAC1B,CAAC,CAAC,CACD,KAAK,CAAC,UAAC,GAAU,EAAA;YACd,QAAQ,CAAC,GAAG,CAAC;UACjB,CAAC,CAAC;QACV,CAAC;QACD,OAAO,QAAQ;MAClB;IACJ;IACD,MAAM,IAAI,KAAK,CACX,8IAA8I,CACjJ;EACL;CACH","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = require(\"lodash\");\nexports.providerUtils = {\n    /**\n     * Starts the Web3ProviderEngine without excess block polling\n     * @param providerEngine The Web3ProviderEngine\n     */\n    startProviderEngine: function (providerEngine) {\n        if (providerEngine.start === undefined) {\n            throw new Error(\"Invalid Web3ProviderEngine\");\n        }\n        // HACK: When calling start() Web3ProviderEngine starts a block polling service\n        // this continuously pulls data from the network and can result in high data usage\n        // for long running services. If used in a front end application this can cause\n        // a high amount of load on a node (one request per user per block).\n        providerEngine._ready.go();\n        providerEngine._running = true;\n    },\n    /**\n     * Standardize the supported provider types into our internal provider interface\n     * or throw if unsupported provider supplied.\n     * @param supportedProvider Potentially supported provider instance\n     * @return Provider that conforms of our internal provider interface\n     */\n    standardizeOrThrow: function (supportedProvider) {\n        if (supportedProvider === undefined) {\n            throw new Error(\"supportedProvider cannot be 'undefined'\");\n        }\n        var provider = {\n            isStandardizedProvider: true,\n            isMetaMask: supportedProvider.isMetaMask,\n            isParity: supportedProvider.isParity,\n            stop: supportedProvider.stop,\n            enable: supportedProvider.enable,\n            sendAsync: _.noop.bind(_),\n        };\n        // Case 1: We've already converted to our ZeroExProvider so noop.\n        if (supportedProvider.isStandardizedProvider) {\n            // tslint:disable-next-line:no-unnecessary-type-assertion\n            return supportedProvider;\n            // Case 2: It's a compliant EIP 1193 Provider\n            // tslint:disable-next-line:no-unnecessary-type-assertion\n        }\n        else if (supportedProvider.isEIP1193) {\n            provider.sendAsync = function (payload, callback) {\n                var method = payload.method;\n                var params = payload.params;\n                supportedProvider\n                    .send(method, params)\n                    .then(function (result) {\n                    callback(null, result);\n                })\n                    .catch(function (err) {\n                    callback(err);\n                });\n            };\n            return provider;\n            // Case 3: The provider has a `sendAsync` method, so we use it.\n        }\n        else if (supportedProvider.sendAsync !== undefined) {\n            provider.sendAsync = supportedProvider.sendAsync.bind(supportedProvider);\n            return provider;\n            // Case 4: The provider does not have a `sendAsync` method but does have a `send` method\n        }\n        else if (supportedProvider.send !== undefined) {\n            // HACK(fabio): Detect if the `send` method has the old interface `send(payload, cb)` such\n            // as in versions < Web3.js@1.0.0-beta.37. If so, do a simple re-mapping\n            if (_.includes(supportedProvider.send.toString(), 'function (payload, callback)')) {\n                provider.sendAsync = supportedProvider.send.bind(supportedProvider);\n                return provider;\n            }\n            else {\n                // If doesn't have old interface, we assume it has new interface `send(method, payload)`\n                // such as in versions > Web3.js@1.0.0-beta.38 and convert it to `sendAsync`\n                provider.sendAsync = function (payload, callback) {\n                    var method = payload.method;\n                    var params = payload.params;\n                    supportedProvider\n                        .send(method, params)\n                        .then(function (result) {\n                        callback(null, result);\n                    })\n                        .catch(function (err) {\n                        callback(err);\n                    });\n                };\n                return provider;\n            }\n        }\n        throw new Error(\"Unsupported provider found. Please make sure it conforms to one of the supported providers. See 'Provider' type in 'ethereum-types' package.\");\n    },\n};\n//# sourceMappingURL=provider_utils.js.map"]},"metadata":{},"sourceType":"script"}