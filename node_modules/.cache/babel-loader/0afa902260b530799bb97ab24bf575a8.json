{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar assert_1 = require(\"@0x/assert\");\nvar json_schemas_1 = require(\"@0x/json-schemas\");\nvar utils_1 = require(\"@0x/utils\");\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar _ = require(\"lodash\");\nvar marshaller_1 = require(\"./marshaller\");\nvar types_1 = require(\"./types\");\nvar utils_2 = require(\"./utils\");\nvar BASE_TEN = 10;\n// These are unique identifiers contained in the response of the\n// web3_clientVersion call.\nvar uniqueVersionIds = {\n  geth: 'Geth',\n  ganache: 'EthereumJS TestRPC'\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\nvar Web3Wrapper = /** @class */function () {\n  /**\n   * Instantiates a new Web3Wrapper.\n   * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n   *                      the backing Ethereum node.\n   * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n   * @return  An instance of the Web3Wrapper class.\n   */\n  function Web3Wrapper(supportedProvider, callAndTxnDefaults) {\n    if (callAndTxnDefaults === void 0) {\n      callAndTxnDefaults = {};\n    }\n    /**\n     * Flag to check if this instance is of type Web3Wrapper\n     */\n    this.isZeroExWeb3Wrapper = true;\n    this.abiDecoder = new utils_1.AbiDecoder([]);\n    this._supportedProvider = supportedProvider;\n    this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._callAndTxnDefaults = callAndTxnDefaults;\n    this._jsonRpcRequestId = 1;\n  }\n  /**\n   * Check if an address is a valid Ethereum address\n   * @param address Address to check\n   * @returns Whether the address is a valid Ethereum address\n   */\n  Web3Wrapper.isAddress = function (address) {\n    return utils_1.addressUtils.isAddress(address);\n  };\n  /**\n   * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n   * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n   * to 1 unit.\n   * @param   amount      The amount in baseUnits that you would like converted to units.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in units.\n   */\n  Web3Wrapper.toUnitAmount = function (amount, decimals) {\n    assert_1.assert.isValidBaseUnitAmount('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    var unit = amount.div(aUnit);\n    return unit;\n  };\n  /**\n   * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n   * is the amount expressed in the smallest denomination.\n   * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n   * @param   amount      The amount of units that you would like converted to baseUnits.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in baseUnits.\n   */\n  Web3Wrapper.toBaseUnitAmount = function (amount, decimals) {\n    assert_1.assert.isBigNumber('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    var baseUnitAmount = amount.times(unit);\n    var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n    if (hasDecimals) {\n      throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n    }\n    return baseUnitAmount;\n  };\n  /**\n   * Convert an Ether amount from ETH to Wei\n   * @param ethAmount Amount of Ether to convert to wei\n   * @returns Amount in wei\n   */\n  Web3Wrapper.toWei = function (ethAmount) {\n    assert_1.assert.isBigNumber('ethAmount', ethAmount);\n    var ETH_DECIMALS = 18;\n    var balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n    return balanceWei;\n  };\n  Web3Wrapper._assertBlockParam = function (blockParam) {\n    if (_.isNumber(blockParam)) {\n      return;\n    } else if (_.isString(blockParam)) {\n      assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n    }\n  };\n  Web3Wrapper._assertBlockParamOrString = function (blockParam) {\n    try {\n      Web3Wrapper._assertBlockParam(blockParam);\n    } catch (err) {\n      try {\n        assert_1.assert.isHexString('blockParam', blockParam);\n        return;\n      } catch (err) {\n        throw new Error(\"Expected blockParam to be of type \\\"string | BlockParam\\\", encountered \" + blockParam);\n      }\n    }\n  };\n  Web3Wrapper._normalizeTxReceiptStatus = function (status) {\n    // Transaction status might have four values\n    // undefined - Testrpc and other old clients\n    // null - New clients on old transactions\n    // number - Parity\n    // hex - Geth\n    if (_.isString(status)) {\n      return utils_2.utils.convertHexToNumber(status);\n    } else if (status === undefined) {\n      return null;\n    } else {\n      return status;\n    }\n  };\n  /**\n   * Get the contract defaults set to the Web3Wrapper instance\n   * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n   */\n  Web3Wrapper.prototype.getContractDefaults = function () {\n    return this._callAndTxnDefaults;\n  };\n  /**\n   * Retrieve the Web3 provider\n   * @return  Web3 provider instance\n   */\n  Web3Wrapper.prototype.getProvider = function () {\n    return this._supportedProvider;\n  };\n  /**\n   * Update the used Web3 provider\n   * @param provider The new Web3 provider to be set\n   */\n  Web3Wrapper.prototype.setProvider = function (supportedProvider) {\n    var provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._provider = provider;\n  };\n  /**\n   * Check whether an address is available through the backing provider. This can be\n   * useful if you want to know whether a user can sign messages or transactions from\n   * a given Ethereum address.\n   * @param senderAddress Address to check availability for\n   * @returns Whether the address is available through the provider.\n   */\n  Web3Wrapper.prototype.isSenderAddressAvailableAsync = function (senderAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var addresses, normalizedAddress;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n            return [4 /*yield*/, this.getAvailableAddressesAsync()];\n          case 1:\n            addresses = _a.sent();\n            normalizedAddress = senderAddress.toLowerCase();\n            return [2 /*return*/, _.includes(addresses, normalizedAddress)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n   * @returns Ethereum node's version string\n   */\n  Web3Wrapper.prototype.getNodeVersionAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var nodeVersion;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'web3_clientVersion'\n            })];\n          case 1:\n            nodeVersion = _a.sent();\n            return [2 /*return*/, nodeVersion];\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the networkId of the backing Ethereum node\n   * @returns The network id\n   */\n  Web3Wrapper.prototype.getNetworkIdAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var networkIdStr, networkId;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'net_version'\n            })];\n          case 1:\n            networkIdStr = _a.sent();\n            networkId = _.parseInt(networkIdStr);\n            return [2 /*return*/, networkId];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the transaction receipt for a given transaction hash if found\n   * @param txHash Transaction hash\n   * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n   */\n  Web3Wrapper.prototype.getTransactionReceiptIfExistsAsync = function (txHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionReceiptRpc, transactionReceipt;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_getTransactionReceipt',\n              params: [txHash]\n            })];\n          case 1:\n            transactionReceiptRpc = _a.sent();\n            // HACK Parity can return a pending transaction receipt. We check for a non null\n            // block number before continuing with returning a fully realised receipt.\n            // ref: https://github.com/paritytech/parity-ethereum/issues/1180\n            if (transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null) {\n              transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n              transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n              return [2 /*return*/, transactionReceipt];\n            } else {\n              return [2 /*return*/, undefined];\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the transaction data for a given transaction\n   * @param txHash Transaction hash\n   * @returns The raw transaction data\n   */\n  Web3Wrapper.prototype.getTransactionByHashAsync = function (txHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionRpc, transaction;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_getTransactionByHash',\n              params: [txHash]\n            })];\n          case 1:\n            transactionRpc = _a.sent();\n            transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n            return [2 /*return*/, transaction];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves an accounts Ether balance in wei\n   * @param owner Account whose balance you wish to check\n   * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n   * @returns Balance in wei\n   */\n  Web3Wrapper.prototype.getBalanceInWeiAsync = function (owner, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, encodedOwner, balanceInWei;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('owner', owner);\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_getBalance',\n              params: [encodedOwner, marshalledDefaultBlock]\n            })];\n          case 1:\n            balanceInWei = _a.sent();\n            // Rewrap in a new BigNumber\n            return [2 /*return*/, new utils_1.BigNumber(balanceInWei)];\n        }\n      });\n    });\n  };\n  /**\n   * Check if a contract exists at a given address\n   * @param address Address to which to check\n   * @returns Whether or not contract code was found at the supplied address\n   */\n  Web3Wrapper.prototype.doesContractExistAtAddressAsync = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var code, isCodeEmpty;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            return [4 /*yield*/, this.getContractCodeAsync(address)];\n          case 1:\n            code = _a.sent();\n            isCodeEmpty = /^0x0{0,40}$/i.test(code);\n            return [2 /*return*/, !isCodeEmpty];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the contract code by address\n   * @param  address Address of the contract\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @return Code of the contract\n   */\n  Web3Wrapper.prototype.getContractCodeAsync = function (address, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, encodedAddress, code;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_getCode',\n              params: [encodedAddress, marshalledDefaultBlock]\n            })];\n          case 1:\n            code = _a.sent();\n            return [2 /*return*/, code];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the debug trace of a transaction\n   * @param  txHash Hash of the transactuon to get a trace for\n   * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n   * @return Transaction trace\n   */\n  Web3Wrapper.prototype.getTransactionTraceAsync = function (txHash, traceParams) {\n    return __awaiter(this, void 0, void 0, function () {\n      var trace;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'debug_traceTransaction',\n              params: [txHash, traceParams]\n            })];\n          case 1:\n            trace = _a.sent();\n            return [2 /*return*/, trace];\n        }\n      });\n    });\n  };\n  /**\n   * Sign a message with a specific address's private key (`eth_sign`)\n   * @param address Address of signer\n   * @param message Message to sign\n   * @returns Signature string (might be VRS or RSV depending on the Signer)\n   */\n  Web3Wrapper.prototype.signMessageAsync = function (address, message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_sign',\n              params: [address, message]\n            })];\n          case 1:\n            signData = _a.sent();\n            return [2 /*return*/, signData];\n        }\n      });\n    });\n  };\n  /**\n   * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n   * @param address Address of signer\n   * @param typedData Typed data message to sign\n   * @returns Signature string (as RSV)\n   */\n  Web3Wrapper.prototype.signTypedDataAsync = function (address, typedData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_signTypedData',\n              params: [address, typedData]\n            })];\n          case 1:\n            signData = _a.sent();\n            return [2 /*return*/, signData];\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the latest block number\n   * @returns Block number\n   */\n  Web3Wrapper.prototype.getBlockNumberAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex, blockNumber;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_blockNumber',\n              params: []\n            })];\n          case 1:\n            blockNumberHex = _a.sent();\n            blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n            return [2 /*return*/, blockNumber];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a specific Ethereum block without transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block without transaction data, or undefined if block was not found\n   * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n   */\n  Web3Wrapper.prototype.getBlockIfExistsAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedBlockParam, method, shouldIncludeTransactionData, blockWithoutTransactionDataWithHexValuesOrNull, blockWithoutTransactionDataIfExists;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n            encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n            method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            shouldIncludeTransactionData = false;\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: method,\n              params: [encodedBlockParam, shouldIncludeTransactionData]\n            })];\n          case 1:\n            blockWithoutTransactionDataWithHexValuesOrNull = _a.sent();\n            if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n              blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n            }\n            return [2 /*return*/, blockWithoutTransactionDataIfExists];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a specific Ethereum block with transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block with transaction data\n   */\n  Web3Wrapper.prototype.getBlockWithTransactionDataAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedBlockParam, method, shouldIncludeTransactionData, blockWithTransactionDataWithHexValues, blockWithoutTransactionData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n            encodedBlockParam = blockParam;\n            if (_.isNumber(blockParam)) {\n              encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n            }\n            method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            shouldIncludeTransactionData = true;\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: method,\n              params: [encodedBlockParam, shouldIncludeTransactionData]\n            })];\n          case 1:\n            blockWithTransactionDataWithHexValues = _a.sent();\n            blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n            return [2 /*return*/, blockWithoutTransactionData];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a block's timestamp\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The block's timestamp\n   */\n  Web3Wrapper.prototype.getBlockTimestampAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockIfExists;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n            return [4 /*yield*/, this.getBlockIfExistsAsync(blockParam)];\n          case 1:\n            blockIfExists = _a.sent();\n            if (blockIfExists === undefined) {\n              throw new Error(\"Failed to fetch block with blockParam: \" + JSON.stringify(blockParam));\n            }\n            return [2 /*return*/, blockIfExists.timestamp];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve the user addresses available through the backing provider\n   * @returns Available user addresses\n   */\n  Web3Wrapper.prototype.getAvailableAddressesAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var addresses, normalizedAddresses;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_accounts',\n              params: []\n            })];\n          case 1:\n            addresses = _a.sent();\n            normalizedAddresses = _.map(addresses, function (address) {\n              return address.toLowerCase();\n            });\n            return [2 /*return*/, normalizedAddresses];\n        }\n      });\n    });\n  };\n  /**\n   * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n   * @returns The snapshot id. This can be used to revert to this snapshot\n   */\n  Web3Wrapper.prototype.takeSnapshotAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var snapshotId, _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = Number;\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'evm_snapshot',\n              params: []\n            })];\n          case 1:\n            snapshotId = _a.apply(void 0, [_b.sent()]);\n            return [2 /*return*/, snapshotId];\n        }\n      });\n    });\n  };\n  /**\n   * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n   * @param snapshotId snapshot id to revert to\n   * @returns Whether the revert was successful\n   */\n  Web3Wrapper.prototype.revertSnapshotAsync = function (snapshotId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var didRevert;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('snapshotId', snapshotId);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'evm_revert',\n              params: [snapshotId]\n            })];\n          case 1:\n            didRevert = _a.sent();\n            return [2 /*return*/, didRevert];\n        }\n      });\n    });\n  };\n  /**\n   * Mine a block on a TestRPC/Ganache local node\n   */\n  Web3Wrapper.prototype.mineBlockAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'evm_mine',\n              params: []\n            })];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n   * Will throw if provider is neither TestRPC/Ganache or Geth.\n   * @param timeDelta Amount of time to add in seconds\n   */\n  Web3Wrapper.prototype.increaseTimeAsync = function (timeDelta) {\n    return __awaiter(this, void 0, void 0, function () {\n      var version;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('timeDelta', timeDelta);\n            return [4 /*yield*/, this.getNodeVersionAsync()];\n          case 1:\n            version = _a.sent();\n            if (_.includes(version, uniqueVersionIds.geth)) {\n              return [2 /*return*/, this.sendRawPayloadAsync({\n                method: 'debug_increaseTime',\n                params: [timeDelta]\n              })];\n            } else if (_.includes(version, uniqueVersionIds.ganache)) {\n              return [2 /*return*/, this.sendRawPayloadAsync({\n                method: 'evm_increaseTime',\n                params: [timeDelta]\n              })];\n            } else {\n              throw new Error(\"Unknown client version: \" + version);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve smart contract logs for a given filter\n   * @param filter Parameters by which to filter which logs to retrieve\n   * @returns The corresponding log entries\n   */\n  Web3Wrapper.prototype.getLogsAsync = function (filter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fromBlock, toBlock, serializedFilter, payload, rawLogs, formattedLogs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined)) {\n              throw new Error(\"Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'\");\n            }\n            fromBlock = filter.fromBlock;\n            if (_.isNumber(fromBlock)) {\n              fromBlock = utils_2.utils.numberToHex(fromBlock);\n            }\n            toBlock = filter.toBlock;\n            if (_.isNumber(toBlock)) {\n              toBlock = utils_2.utils.numberToHex(toBlock);\n            }\n            serializedFilter = __assign({}, filter, {\n              fromBlock: fromBlock,\n              toBlock: toBlock\n            });\n            payload = {\n              method: 'eth_getLogs',\n              params: [serializedFilter]\n            };\n            return [4 /*yield*/, this.sendRawPayloadAsync(payload)];\n          case 1:\n            rawLogs = _a.sent();\n            formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n            return [2 /*return*/, formattedLogs];\n        }\n      });\n    });\n  };\n  /**\n   * Calculate the estimated gas cost for a given transaction\n   * @param txData Transaction data\n   * @returns Estimated gas cost\n   */\n  Web3Wrapper.prototype.estimateGasAsync = function (txData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txDataHex, gasHex, gas;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_estimateGas',\n              params: [txDataHex]\n            })];\n          case 1:\n            gasHex = _a.sent();\n            gas = utils_2.utils.convertHexToNumber(gasHex);\n            return [2 /*return*/, gas];\n        }\n      });\n    });\n  };\n  /**\n   * Call a smart contract method at a given block height\n   * @param callData Call data\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @returns The raw call result\n   */\n  Web3Wrapper.prototype.callAsync = function (callData, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, callDataHex, rawCallResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_call',\n              params: [callDataHex, marshalledDefaultBlock]\n            })];\n          case 1:\n            rawCallResult = _a.sent();\n            return [2 /*return*/, rawCallResult];\n        }\n      });\n    });\n  };\n  /**\n   * Send a transaction\n   * @param txData Transaction data\n   * @returns Transaction hash\n   */\n  Web3Wrapper.prototype.sendTransactionAsync = function (txData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txDataHex, txHash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'eth_sendTransaction',\n              params: [txDataHex]\n            })];\n          case 1:\n            txHash = _a.sent();\n            return [2 /*return*/, txHash];\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Note that just because a transaction was mined does not mean it was\n   * successful. You need to check the status code of the transaction receipt\n   * to find out if it was successful, or use the helper method\n   * awaitTransactionSuccessAsync.\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n  Web3Wrapper.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs, wasTimeoutExceeded, txReceiptPromise, txReceipt;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n            if (timeoutMs !== undefined) {\n              assert_1.assert.isNumber('timeoutMs', timeoutMs);\n            }\n            return [4 /*yield*/, this.getTransactionReceiptIfExistsAsync(txHash)];\n          case 1:\n            transactionReceipt = _a.sent();\n            if (transactionReceipt !== undefined) {\n              logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n              transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                logs: logsWithDecodedArgs\n              });\n              return [2 /*return*/, transactionReceiptWithDecodedLogArgs];\n            }\n            wasTimeoutExceeded = false;\n            if (timeoutMs) {\n              setTimeout(function () {\n                return wasTimeoutExceeded = true;\n              }, timeoutMs);\n            }\n            txReceiptPromise = new Promise(function (resolve, reject) {\n              var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        if (wasTimeoutExceeded) {\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          return [2 /*return*/, reject(types_1.Web3WrapperErrors.TransactionMiningTimeout)];\n                        }\n                        return [4 /*yield*/, this.getTransactionReceiptIfExistsAsync(txHash)];\n                      case 1:\n                        transactionReceipt = _a.sent();\n                        if (transactionReceipt !== undefined) {\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                          transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                            logs: logsWithDecodedArgs\n                          });\n                          resolve(transactionReceiptWithDecodedLogArgs);\n                        }\n                        return [2 /*return*/];\n                    }\n                  });\n                });\n              }, pollingIntervalMs, function (err) {\n                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                reject(err);\n              });\n            });\n            return [4 /*yield*/, txReceiptPromise];\n          case 2:\n            txReceipt = _a.sent();\n            return [2 /*return*/, txReceipt];\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n   * status that is not equal to 1. A status of 0 or null indicates that the\n   * transaction was mined, but failed. See:\n   * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n  Web3Wrapper.prototype.awaitTransactionSuccessAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var receipt;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs)];\n          case 1:\n            receipt = _a.sent();\n            if (receipt.status !== 1) {\n              throw new Error(\"Transaction failed: \" + txHash);\n            }\n            return [2 /*return*/, receipt];\n        }\n      });\n    });\n  };\n  /**\n   * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n   * the local chain by block number. Note, this is a destructive action and\n   * may severely damage your chain. Use with extreme caution. As of now, this\n   * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n   * not supported.\n   * @param  blockNumber The block number to reset to.\n   */\n  Web3Wrapper.prototype.setHeadAsync = function (blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('blockNumber', blockNumber);\n            return [4 /*yield*/, this.sendRawPayloadAsync({\n              method: 'debug_setHead',\n              params: [utils_2.utils.numberToHex(blockNumber)]\n            })];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n   * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n   * @return The contents nested under the result key of the response body\n   */\n  Web3Wrapper.prototype.sendRawPayloadAsync = function (payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var sendAsync, payloadWithDefaults, response, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            sendAsync = this._provider.sendAsync.bind(this._provider);\n            payloadWithDefaults = __assign({\n              id: this._jsonRpcRequestId++,\n              params: [],\n              jsonrpc: '2.0'\n            }, payload);\n            return [4 /*yield*/, utils_1.promisify(sendAsync)(payloadWithDefaults)];\n          case 1:\n            response = _a.sent();\n            if (response.error) {\n              throw new Error(response.error.message);\n            }\n            result = response.result;\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  /**\n   * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n   * the backing Ethereum node. Throws for any other type of node.\n   */\n  Web3Wrapper.prototype.getNodeTypeAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var version;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getNodeVersionAsync()];\n          case 1:\n            version = _a.sent();\n            if (_.includes(version, uniqueVersionIds.geth)) {\n              return [2 /*return*/, types_1.NodeType.Geth];\n            } else if (_.includes(version, uniqueVersionIds.ganache)) {\n              return [2 /*return*/, types_1.NodeType.Ganache];\n            } else {\n              throw new Error(\"Unknown client version: \" + version);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return Web3Wrapper;\n}(); // tslint:disable-line:max-file-line-count\nexports.Web3Wrapper = Web3Wrapper;","map":{"version":3,"sources":["../../src/web3_wrapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"@0x/assert\");\nvar json_schemas_1 = require(\"@0x/json-schemas\");\nvar utils_1 = require(\"@0x/utils\");\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar _ = require(\"lodash\");\nvar marshaller_1 = require(\"./marshaller\");\nvar types_1 = require(\"./types\");\nvar utils_2 = require(\"./utils\");\nvar BASE_TEN = 10;\n// These are unique identifiers contained in the response of the\n// web3_clientVersion call.\nvar uniqueVersionIds = {\n    geth: 'Geth',\n    ganache: 'EthereumJS TestRPC',\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\nvar Web3Wrapper = /** @class */ (function () {\n    /**\n     * Instantiates a new Web3Wrapper.\n     * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n     *                      the backing Ethereum node.\n     * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n     * @return  An instance of the Web3Wrapper class.\n     */\n    function Web3Wrapper(supportedProvider, callAndTxnDefaults) {\n        if (callAndTxnDefaults === void 0) { callAndTxnDefaults = {}; }\n        /**\n         * Flag to check if this instance is of type Web3Wrapper\n         */\n        this.isZeroExWeb3Wrapper = true;\n        this.abiDecoder = new utils_1.AbiDecoder([]);\n        this._supportedProvider = supportedProvider;\n        this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n        this._callAndTxnDefaults = callAndTxnDefaults;\n        this._jsonRpcRequestId = 1;\n    }\n    /**\n     * Check if an address is a valid Ethereum address\n     * @param address Address to check\n     * @returns Whether the address is a valid Ethereum address\n     */\n    Web3Wrapper.isAddress = function (address) {\n        return utils_1.addressUtils.isAddress(address);\n    };\n    /**\n     * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n     * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n     * to 1 unit.\n     * @param   amount      The amount in baseUnits that you would like converted to units.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in units.\n     */\n    Web3Wrapper.toUnitAmount = function (amount, decimals) {\n        assert_1.assert.isValidBaseUnitAmount('amount', amount);\n        assert_1.assert.isNumber('decimals', decimals);\n        var aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n        var unit = amount.div(aUnit);\n        return unit;\n    };\n    /**\n     * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n     * is the amount expressed in the smallest denomination.\n     * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n     * @param   amount      The amount of units that you would like converted to baseUnits.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in baseUnits.\n     */\n    Web3Wrapper.toBaseUnitAmount = function (amount, decimals) {\n        assert_1.assert.isBigNumber('amount', amount);\n        assert_1.assert.isNumber('decimals', decimals);\n        var unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n        var baseUnitAmount = amount.times(unit);\n        var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n        if (hasDecimals) {\n            throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n        }\n        return baseUnitAmount;\n    };\n    /**\n     * Convert an Ether amount from ETH to Wei\n     * @param ethAmount Amount of Ether to convert to wei\n     * @returns Amount in wei\n     */\n    Web3Wrapper.toWei = function (ethAmount) {\n        assert_1.assert.isBigNumber('ethAmount', ethAmount);\n        var ETH_DECIMALS = 18;\n        var balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n        return balanceWei;\n    };\n    Web3Wrapper._assertBlockParam = function (blockParam) {\n        if (_.isNumber(blockParam)) {\n            return;\n        }\n        else if (_.isString(blockParam)) {\n            assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n        }\n    };\n    Web3Wrapper._assertBlockParamOrString = function (blockParam) {\n        try {\n            Web3Wrapper._assertBlockParam(blockParam);\n        }\n        catch (err) {\n            try {\n                assert_1.assert.isHexString('blockParam', blockParam);\n                return;\n            }\n            catch (err) {\n                throw new Error(\"Expected blockParam to be of type \\\"string | BlockParam\\\", encountered \" + blockParam);\n            }\n        }\n    };\n    Web3Wrapper._normalizeTxReceiptStatus = function (status) {\n        // Transaction status might have four values\n        // undefined - Testrpc and other old clients\n        // null - New clients on old transactions\n        // number - Parity\n        // hex - Geth\n        if (_.isString(status)) {\n            return utils_2.utils.convertHexToNumber(status);\n        }\n        else if (status === undefined) {\n            return null;\n        }\n        else {\n            return status;\n        }\n    };\n    /**\n     * Get the contract defaults set to the Web3Wrapper instance\n     * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n     */\n    Web3Wrapper.prototype.getContractDefaults = function () {\n        return this._callAndTxnDefaults;\n    };\n    /**\n     * Retrieve the Web3 provider\n     * @return  Web3 provider instance\n     */\n    Web3Wrapper.prototype.getProvider = function () {\n        return this._supportedProvider;\n    };\n    /**\n     * Update the used Web3 provider\n     * @param provider The new Web3 provider to be set\n     */\n    Web3Wrapper.prototype.setProvider = function (supportedProvider) {\n        var provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n        this._provider = provider;\n    };\n    /**\n     * Check whether an address is available through the backing provider. This can be\n     * useful if you want to know whether a user can sign messages or transactions from\n     * a given Ethereum address.\n     * @param senderAddress Address to check availability for\n     * @returns Whether the address is available through the provider.\n     */\n    Web3Wrapper.prototype.isSenderAddressAvailableAsync = function (senderAddress) {\n        return __awaiter(this, void 0, void 0, function () {\n            var addresses, normalizedAddress;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n                        return [4 /*yield*/, this.getAvailableAddressesAsync()];\n                    case 1:\n                        addresses = _a.sent();\n                        normalizedAddress = senderAddress.toLowerCase();\n                        return [2 /*return*/, _.includes(addresses, normalizedAddress)];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n     * @returns Ethereum node's version string\n     */\n    Web3Wrapper.prototype.getNodeVersionAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var nodeVersion;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'web3_clientVersion' })];\n                    case 1:\n                        nodeVersion = _a.sent();\n                        return [2 /*return*/, nodeVersion];\n                }\n            });\n        });\n    };\n    /**\n     * Fetches the networkId of the backing Ethereum node\n     * @returns The network id\n     */\n    Web3Wrapper.prototype.getNetworkIdAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var networkIdStr, networkId;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'net_version' })];\n                    case 1:\n                        networkIdStr = _a.sent();\n                        networkId = _.parseInt(networkIdStr);\n                        return [2 /*return*/, networkId];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieves the transaction receipt for a given transaction hash if found\n     * @param txHash Transaction hash\n     * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n     */\n    Web3Wrapper.prototype.getTransactionReceiptIfExistsAsync = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var transactionReceiptRpc, transactionReceipt;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getTransactionReceipt',\n                                params: [txHash],\n                            })];\n                    case 1:\n                        transactionReceiptRpc = _a.sent();\n                        // HACK Parity can return a pending transaction receipt. We check for a non null\n                        // block number before continuing with returning a fully realised receipt.\n                        // ref: https://github.com/paritytech/parity-ethereum/issues/1180\n                        if (transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null) {\n                            transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n                            transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n                            return [2 /*return*/, transactionReceipt];\n                        }\n                        else {\n                            return [2 /*return*/, undefined];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieves the transaction data for a given transaction\n     * @param txHash Transaction hash\n     * @returns The raw transaction data\n     */\n    Web3Wrapper.prototype.getTransactionByHashAsync = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var transactionRpc, transaction;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getTransactionByHash',\n                                params: [txHash],\n                            })];\n                    case 1:\n                        transactionRpc = _a.sent();\n                        transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n                        return [2 /*return*/, transaction];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieves an accounts Ether balance in wei\n     * @param owner Account whose balance you wish to check\n     * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n     * @returns Balance in wei\n     */\n    Web3Wrapper.prototype.getBalanceInWeiAsync = function (owner, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var marshalledDefaultBlock, encodedOwner, balanceInWei;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('owner', owner);\n                        if (defaultBlock !== undefined) {\n                            Web3Wrapper._assertBlockParam(defaultBlock);\n                        }\n                        marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n                        encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getBalance',\n                                params: [encodedOwner, marshalledDefaultBlock],\n                            })];\n                    case 1:\n                        balanceInWei = _a.sent();\n                        // Rewrap in a new BigNumber\n                        return [2 /*return*/, new utils_1.BigNumber(balanceInWei)];\n                }\n            });\n        });\n    };\n    /**\n     * Check if a contract exists at a given address\n     * @param address Address to which to check\n     * @returns Whether or not contract code was found at the supplied address\n     */\n    Web3Wrapper.prototype.doesContractExistAtAddressAsync = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var code, isCodeEmpty;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        return [4 /*yield*/, this.getContractCodeAsync(address)];\n                    case 1:\n                        code = _a.sent();\n                        isCodeEmpty = /^0x0{0,40}$/i.test(code);\n                        return [2 /*return*/, !isCodeEmpty];\n                }\n            });\n        });\n    };\n    /**\n     * Gets the contract code by address\n     * @param  address Address of the contract\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @return Code of the contract\n     */\n    Web3Wrapper.prototype.getContractCodeAsync = function (address, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var marshalledDefaultBlock, encodedAddress, code;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        if (defaultBlock !== undefined) {\n                            Web3Wrapper._assertBlockParam(defaultBlock);\n                        }\n                        marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n                        encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getCode',\n                                params: [encodedAddress, marshalledDefaultBlock],\n                            })];\n                    case 1:\n                        code = _a.sent();\n                        return [2 /*return*/, code];\n                }\n            });\n        });\n    };\n    /**\n     * Gets the debug trace of a transaction\n     * @param  txHash Hash of the transactuon to get a trace for\n     * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n     * @return Transaction trace\n     */\n    Web3Wrapper.prototype.getTransactionTraceAsync = function (txHash, traceParams) {\n        return __awaiter(this, void 0, void 0, function () {\n            var trace;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'debug_traceTransaction',\n                                params: [txHash, traceParams],\n                            })];\n                    case 1:\n                        trace = _a.sent();\n                        return [2 /*return*/, trace];\n                }\n            });\n        });\n    };\n    /**\n     * Sign a message with a specific address's private key (`eth_sign`)\n     * @param address Address of signer\n     * @param message Message to sign\n     * @returns Signature string (might be VRS or RSV depending on the Signer)\n     */\n    Web3Wrapper.prototype.signMessageAsync = function (address, message) {\n        return __awaiter(this, void 0, void 0, function () {\n            var signData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_sign',\n                                params: [address, message],\n                            })];\n                    case 1:\n                        signData = _a.sent();\n                        return [2 /*return*/, signData];\n                }\n            });\n        });\n    };\n    /**\n     * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n     * @param address Address of signer\n     * @param typedData Typed data message to sign\n     * @returns Signature string (as RSV)\n     */\n    Web3Wrapper.prototype.signTypedDataAsync = function (address, typedData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var signData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_signTypedData',\n                                params: [address, typedData],\n                            })];\n                    case 1:\n                        signData = _a.sent();\n                        return [2 /*return*/, signData];\n                }\n            });\n        });\n    };\n    /**\n     * Fetches the latest block number\n     * @returns Block number\n     */\n    Web3Wrapper.prototype.getBlockNumberAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockNumberHex, blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({\n                            method: 'eth_blockNumber',\n                            params: [],\n                        })];\n                    case 1:\n                        blockNumberHex = _a.sent();\n                        blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n                        return [2 /*return*/, blockNumber];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a specific Ethereum block without transaction data\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The requested block without transaction data, or undefined if block was not found\n     * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n     */\n    Web3Wrapper.prototype.getBlockIfExistsAsync = function (blockParam) {\n        return __awaiter(this, void 0, void 0, function () {\n            var encodedBlockParam, method, shouldIncludeTransactionData, blockWithoutTransactionDataWithHexValuesOrNull, blockWithoutTransactionDataIfExists;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        Web3Wrapper._assertBlockParamOrString(blockParam);\n                        encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n                        method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n                        shouldIncludeTransactionData = false;\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: method,\n                                params: [encodedBlockParam, shouldIncludeTransactionData],\n                            })];\n                    case 1:\n                        blockWithoutTransactionDataWithHexValuesOrNull = _a.sent();\n                        if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n                            blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n                        }\n                        return [2 /*return*/, blockWithoutTransactionDataIfExists];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a specific Ethereum block with transaction data\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The requested block with transaction data\n     */\n    Web3Wrapper.prototype.getBlockWithTransactionDataAsync = function (blockParam) {\n        return __awaiter(this, void 0, void 0, function () {\n            var encodedBlockParam, method, shouldIncludeTransactionData, blockWithTransactionDataWithHexValues, blockWithoutTransactionData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        Web3Wrapper._assertBlockParamOrString(blockParam);\n                        encodedBlockParam = blockParam;\n                        if (_.isNumber(blockParam)) {\n                            encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n                        }\n                        method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n                        shouldIncludeTransactionData = true;\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: method,\n                                params: [encodedBlockParam, shouldIncludeTransactionData],\n                            })];\n                    case 1:\n                        blockWithTransactionDataWithHexValues = _a.sent();\n                        blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n                        return [2 /*return*/, blockWithoutTransactionData];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a block's timestamp\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The block's timestamp\n     */\n    Web3Wrapper.prototype.getBlockTimestampAsync = function (blockParam) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockIfExists;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        Web3Wrapper._assertBlockParamOrString(blockParam);\n                        return [4 /*yield*/, this.getBlockIfExistsAsync(blockParam)];\n                    case 1:\n                        blockIfExists = _a.sent();\n                        if (blockIfExists === undefined) {\n                            throw new Error(\"Failed to fetch block with blockParam: \" + JSON.stringify(blockParam));\n                        }\n                        return [2 /*return*/, blockIfExists.timestamp];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieve the user addresses available through the backing provider\n     * @returns Available user addresses\n     */\n    Web3Wrapper.prototype.getAvailableAddressesAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var addresses, normalizedAddresses;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({\n                            method: 'eth_accounts',\n                            params: [],\n                        })];\n                    case 1:\n                        addresses = _a.sent();\n                        normalizedAddresses = _.map(addresses, function (address) { return address.toLowerCase(); });\n                        return [2 /*return*/, normalizedAddresses];\n                }\n            });\n        });\n    };\n    /**\n     * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n     * @returns The snapshot id. This can be used to revert to this snapshot\n     */\n    Web3Wrapper.prototype.takeSnapshotAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var snapshotId, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = Number;\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'evm_snapshot', params: [] })];\n                    case 1:\n                        snapshotId = _a.apply(void 0, [_b.sent()]);\n                        return [2 /*return*/, snapshotId];\n                }\n            });\n        });\n    };\n    /**\n     * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n     * @param snapshotId snapshot id to revert to\n     * @returns Whether the revert was successful\n     */\n    Web3Wrapper.prototype.revertSnapshotAsync = function (snapshotId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var didRevert;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isNumber('snapshotId', snapshotId);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'evm_revert', params: [snapshotId] })];\n                    case 1:\n                        didRevert = _a.sent();\n                        return [2 /*return*/, didRevert];\n                }\n            });\n        });\n    };\n    /**\n     * Mine a block on a TestRPC/Ganache local node\n     */\n    Web3Wrapper.prototype.mineBlockAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'evm_mine', params: [] })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n     * Will throw if provider is neither TestRPC/Ganache or Geth.\n     * @param timeDelta Amount of time to add in seconds\n     */\n    Web3Wrapper.prototype.increaseTimeAsync = function (timeDelta) {\n        return __awaiter(this, void 0, void 0, function () {\n            var version;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isNumber('timeDelta', timeDelta);\n                        return [4 /*yield*/, this.getNodeVersionAsync()];\n                    case 1:\n                        version = _a.sent();\n                        if (_.includes(version, uniqueVersionIds.geth)) {\n                            return [2 /*return*/, this.sendRawPayloadAsync({ method: 'debug_increaseTime', params: [timeDelta] })];\n                        }\n                        else if (_.includes(version, uniqueVersionIds.ganache)) {\n                            return [2 /*return*/, this.sendRawPayloadAsync({ method: 'evm_increaseTime', params: [timeDelta] })];\n                        }\n                        else {\n                            throw new Error(\"Unknown client version: \" + version);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieve smart contract logs for a given filter\n     * @param filter Parameters by which to filter which logs to retrieve\n     * @returns The corresponding log entries\n     */\n    Web3Wrapper.prototype.getLogsAsync = function (filter) {\n        return __awaiter(this, void 0, void 0, function () {\n            var fromBlock, toBlock, serializedFilter, payload, rawLogs, formattedLogs;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined)) {\n                            throw new Error(\"Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'\");\n                        }\n                        fromBlock = filter.fromBlock;\n                        if (_.isNumber(fromBlock)) {\n                            fromBlock = utils_2.utils.numberToHex(fromBlock);\n                        }\n                        toBlock = filter.toBlock;\n                        if (_.isNumber(toBlock)) {\n                            toBlock = utils_2.utils.numberToHex(toBlock);\n                        }\n                        serializedFilter = __assign({}, filter, { fromBlock: fromBlock,\n                            toBlock: toBlock });\n                        payload = {\n                            method: 'eth_getLogs',\n                            params: [serializedFilter],\n                        };\n                        return [4 /*yield*/, this.sendRawPayloadAsync(payload)];\n                    case 1:\n                        rawLogs = _a.sent();\n                        formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n                        return [2 /*return*/, formattedLogs];\n                }\n            });\n        });\n    };\n    /**\n     * Calculate the estimated gas cost for a given transaction\n     * @param txData Transaction data\n     * @returns Estimated gas cost\n     */\n    Web3Wrapper.prototype.estimateGasAsync = function (txData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var txDataHex, gasHex, gas;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [\n                            json_schemas_1.schemas.addressSchema,\n                            json_schemas_1.schemas.numberSchema,\n                            json_schemas_1.schemas.jsNumber,\n                        ]);\n                        txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'eth_estimateGas', params: [txDataHex] })];\n                    case 1:\n                        gasHex = _a.sent();\n                        gas = utils_2.utils.convertHexToNumber(gasHex);\n                        return [2 /*return*/, gas];\n                }\n            });\n        });\n    };\n    /**\n     * Call a smart contract method at a given block height\n     * @param callData Call data\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @returns The raw call result\n     */\n    Web3Wrapper.prototype.callAsync = function (callData, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var marshalledDefaultBlock, callDataHex, rawCallResult;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [\n                            json_schemas_1.schemas.addressSchema,\n                            json_schemas_1.schemas.numberSchema,\n                            json_schemas_1.schemas.jsNumber,\n                        ]);\n                        if (defaultBlock !== undefined) {\n                            Web3Wrapper._assertBlockParam(defaultBlock);\n                        }\n                        marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n                        callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_call',\n                                params: [callDataHex, marshalledDefaultBlock],\n                            })];\n                    case 1:\n                        rawCallResult = _a.sent();\n                        return [2 /*return*/, rawCallResult];\n                }\n            });\n        });\n    };\n    /**\n     * Send a transaction\n     * @param txData Transaction data\n     * @returns Transaction hash\n     */\n    Web3Wrapper.prototype.sendTransactionAsync = function (txData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var txDataHex, txHash;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [\n                            json_schemas_1.schemas.addressSchema,\n                            json_schemas_1.schemas.numberSchema,\n                            json_schemas_1.schemas.jsNumber,\n                        ]);\n                        txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'eth_sendTransaction', params: [txDataHex] })];\n                    case 1:\n                        txHash = _a.sent();\n                        return [2 /*return*/, txHash];\n                }\n            });\n        });\n    };\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * Note that just because a transaction was mined does not mean it was\n     * successful. You need to check the status code of the transaction receipt\n     * to find out if it was successful, or use the helper method\n     * awaitTransactionSuccessAsync.\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n    Web3Wrapper.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n        if (pollingIntervalMs === void 0) { pollingIntervalMs = 1000; }\n        return __awaiter(this, void 0, void 0, function () {\n            var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs, wasTimeoutExceeded, txReceiptPromise, txReceipt;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n                        if (timeoutMs !== undefined) {\n                            assert_1.assert.isNumber('timeoutMs', timeoutMs);\n                        }\n                        return [4 /*yield*/, this.getTransactionReceiptIfExistsAsync(txHash)];\n                    case 1:\n                        transactionReceipt = _a.sent();\n                        if (transactionReceipt !== undefined) {\n                            logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                            transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, { logs: logsWithDecodedArgs });\n                            return [2 /*return*/, transactionReceiptWithDecodedLogArgs];\n                        }\n                        wasTimeoutExceeded = false;\n                        if (timeoutMs) {\n                            setTimeout(function () { return (wasTimeoutExceeded = true); }, timeoutMs);\n                        }\n                        txReceiptPromise = new Promise(function (resolve, reject) {\n                            var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () { return __awaiter(_this, void 0, void 0, function () {\n                                var logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0:\n                                            if (wasTimeoutExceeded) {\n                                                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                                return [2 /*return*/, reject(types_1.Web3WrapperErrors.TransactionMiningTimeout)];\n                                            }\n                                            return [4 /*yield*/, this.getTransactionReceiptIfExistsAsync(txHash)];\n                                        case 1:\n                                            transactionReceipt = _a.sent();\n                                            if (transactionReceipt !== undefined) {\n                                                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                                logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                                                transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, { logs: logsWithDecodedArgs });\n                                                resolve(transactionReceiptWithDecodedLogArgs);\n                                            }\n                                            return [2 /*return*/];\n                                    }\n                                });\n                            }); }, pollingIntervalMs, function (err) {\n                                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                reject(err);\n                            });\n                        });\n                        return [4 /*yield*/, txReceiptPromise];\n                    case 2:\n                        txReceipt = _a.sent();\n                        return [2 /*return*/, txReceipt];\n                }\n            });\n        });\n    };\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n     * status that is not equal to 1. A status of 0 or null indicates that the\n     * transaction was mined, but failed. See:\n     * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n    Web3Wrapper.prototype.awaitTransactionSuccessAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n        if (pollingIntervalMs === void 0) { pollingIntervalMs = 1000; }\n        return __awaiter(this, void 0, void 0, function () {\n            var receipt;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs)];\n                    case 1:\n                        receipt = _a.sent();\n                        if (receipt.status !== 1) {\n                            throw new Error(\"Transaction failed: \" + txHash);\n                        }\n                        return [2 /*return*/, receipt];\n                }\n            });\n        });\n    };\n    /**\n     * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n     * the local chain by block number. Note, this is a destructive action and\n     * may severely damage your chain. Use with extreme caution. As of now, this\n     * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n     * not supported.\n     * @param  blockNumber The block number to reset to.\n     */\n    Web3Wrapper.prototype.setHeadAsync = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isNumber('blockNumber', blockNumber);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'debug_setHead', params: [utils_2.utils.numberToHex(blockNumber)] })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n     * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n     * @return The contents nested under the result key of the response body\n     */\n    Web3Wrapper.prototype.sendRawPayloadAsync = function (payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var sendAsync, payloadWithDefaults, response, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        sendAsync = this._provider.sendAsync.bind(this._provider);\n                        payloadWithDefaults = __assign({ id: this._jsonRpcRequestId++, params: [], jsonrpc: '2.0' }, payload);\n                        return [4 /*yield*/, utils_1.promisify(sendAsync)(payloadWithDefaults)];\n                    case 1:\n                        response = _a.sent();\n                        if (response.error) {\n                            throw new Error(response.error.message);\n                        }\n                        result = response.result;\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    /**\n     * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n     * the backing Ethereum node. Throws for any other type of node.\n     */\n    Web3Wrapper.prototype.getNodeTypeAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var version;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNodeVersionAsync()];\n                    case 1:\n                        version = _a.sent();\n                        if (_.includes(version, uniqueVersionIds.geth)) {\n                            return [2 /*return*/, types_1.NodeType.Geth];\n                        }\n                        else if (_.includes(version, uniqueVersionIds.ganache)) {\n                            return [2 /*return*/, types_1.NodeType.Ganache];\n                        }\n                        else {\n                            throw new Error(\"Unknown client version: \" + version);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Web3Wrapper;\n}()); // tslint:disable-line:max-file-line-count\nexports.Web3Wrapper = Web3Wrapper;\n//# sourceMappingURL=web3_wrapper.js.map"]},"metadata":{},"sourceType":"script"}