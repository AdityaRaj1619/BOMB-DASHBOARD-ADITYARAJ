{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _promise = require(\"babel-runtime/core-js/promise\");\nvar _promise2 = _interopRequireDefault(_promise);\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");\nvar _typeof3 = _interopRequireDefault(_typeof2);\nvar _getPrototypeOf = require(\"babel-runtime/core-js/object/get-prototype-of\");\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\nvar _regenerator = require(\"babel-runtime/regenerator\");\nvar _regenerator2 = _interopRequireDefault(_regenerator);\nvar _asyncToGenerator2 = require(\"babel-runtime/helpers/asyncToGenerator\");\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\nvar _createClass3 = _interopRequireDefault(_createClass2);\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\nvar _inherits3 = _interopRequireDefault(_inherits2);\nvar _u2fApi = require(\"u2f-api\");\nvar _hwTransport = require(\"@ledgerhq/hw-transport\");\nvar _hwTransport2 = _interopRequireDefault(_hwTransport);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction wrapU2FTransportError(originalError, message, id) {\n  var err = new _hwTransport.TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\nfunction wrapApdu(apdu, key) {\n  var result = Buffer.alloc(apdu.length);\n  for (var i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nvar webSafe64 = function webSafe64(base64) {\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n};\n\n// Convert from web-safe to normal, add trailing \"=\"s\nvar normal64 = function normal64(base64) {\n  return base64.replace(/-/g, \"+\").replace(/_/g, \"/\") + \"==\".substring(0, 3 * base64.length % 4);\n};\nfunction attemptExchange(apdu, timeoutMillis, debug, scrambleKey) {\n  var keyHandle = wrapApdu(apdu, scrambleKey);\n  var challenge = Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n  var signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  if (debug) {\n    debug(\"=> \" + apdu.toString(\"hex\"));\n  }\n  return (0, _u2fApi.sign)(signRequest, timeoutMillis / 1000).then(function (response) {\n    var signatureData = response.signatureData;\n    if (typeof signatureData === \"string\") {\n      var data = Buffer.from(normal64(signatureData), \"base64\");\n      var result = data.slice(5);\n      if (debug) {\n        debug(\"<= \" + result.toString(\"hex\"));\n      }\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\nvar transportInstances = [];\nfunction emitDisconnect() {\n  transportInstances.forEach(function (t) {\n    return t.emit(\"disconnect\");\n  });\n  transportInstances = [];\n}\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\n\nvar TransportU2F = function (_Transport) {\n  (0, _inherits3.default)(TransportU2F, _Transport);\n  (0, _createClass3.default)(TransportU2F, null, [{\n    key: \"open\",\n    /**\n     * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n     */\n    value: function () {\n      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_) {\n        var _openTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new TransportU2F());\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function open(_x) {\n        return _ref.apply(this, arguments);\n      }\n      return open;\n    }()\n\n    // this transport is not discoverable but we are going to guess if it is here with isSupported()\n  }]);\n\n  function TransportU2F() {\n    (0, _classCallCheck3.default)(this, TransportU2F);\n    var _this = (0, _possibleConstructorReturn3.default)(this, (TransportU2F.__proto__ || (0, _getPrototypeOf2.default)(TransportU2F)).call(this));\n    transportInstances.push(_this);\n    return _this;\n  }\n  (0, _createClass3.default)(TransportU2F, [{\n    key: \"exchange\",\n    value: function () {\n      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(apdu) {\n        var isU2FError;\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return attemptExchange(apdu, this.exchangeTimeout, this.debug, this.scrambleKey);\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](0);\n                isU2FError = (0, _typeof3.default)(_context2.t0.metaData) === \"object\";\n                if (!isU2FError) {\n                  _context2.next = 14;\n                  break;\n                }\n                if (isTimeoutU2FError(_context2.t0)) {\n                  emitDisconnect();\n                }\n                // the wrapping make error more usable and \"printable\" to the end user.\n                throw wrapU2FTransportError(_context2.t0, \"Failed to sign with Ledger device: U2F \" + _context2.t0.metaData.type, \"U2F_\" + _context2.t0.metaData.code);\n              case 14:\n                throw _context2.t0;\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 6]]);\n      }));\n      function exchange(_x3) {\n        return _ref2.apply(this, arguments);\n      }\n      return exchange;\n    }()\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey(scrambleKey) {\n      this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      var i = transportInstances.indexOf(this);\n      if (i === -1) {\n        throw new Error(\"invalid transport instance\");\n      }\n      transportInstances.splice(i, 1);\n      return _promise2.default.resolve();\n    }\n  }]);\n  return TransportU2F;\n}(_hwTransport2.default);\nTransportU2F.isSupported = _u2fApi.isSupported;\nTransportU2F.list = function () {\n  return (0, _u2fApi.isSupported)().then(function (supported) {\n    return supported ? [null] : [];\n  });\n};\nTransportU2F.listen = function (observer) {\n  var unsubscribed = false;\n  (0, _u2fApi.isSupported)().then(function (supported) {\n    if (unsubscribed) return;\n    if (supported) {\n      observer.next({\n        type: \"add\",\n        descriptor: null\n      });\n      observer.complete();\n    } else {\n      observer.error(new _hwTransport.TransportError(\"U2F browser support is needed for Ledger. \" + \"Please use Chrome, Opera or Firefox with a U2F extension. \" + \"Also make sure you're on an HTTPS connection\", \"U2FNotSupported\"));\n    }\n  });\n  return {\n    unsubscribe: function unsubscribe() {\n      unsubscribed = true;\n    }\n  };\n};\nexports.default = TransportU2F;","map":{"version":3,"sources":["../src/TransportU2F.js"],"names":["wrapU2FTransportError","originalError","message","id","err","wrapApdu","apdu","key","result","Buffer","alloc","length","i","webSafe64","base64","replace","normal64","substring","attemptExchange","timeoutMillis","debug","scrambleKey","keyHandle","challenge","from","signRequest","version","toString","appId","location","origin","then","signatureData","response","data","slice","transportInstances","emitDisconnect","forEach","t","emit","isTimeoutU2FError","u2fError","metaData","code","TransportU2F","isSupported","list","supported","listen","observer","unsubscribed","next","type","descriptor","complete","error","unsubscribe","_","_openTimeout","push","exchangeTimeout","isU2FError","indexOf","Error","splice","resolve"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;;;;;;AAEA,SAASA,qBAAT,CAA+BC,aAA/B,EAA8CC,OAA9C,EAAuDC,EAAvD,EAA2D;EACzD,IAAMC,GAAAA,GAAM,IAAA,YAAA,CAAA,cAAA,CAAmBF,OAAnB,EAA4BC,EAA5B,CAAZ;EACA;EACAC,GAAAA,CAAIH,aAAJG,GAAoBH,aAApBG;EACA,OAAOA,GAAP;AACD;AAED,SAASC,QAAT,CAAkBC,IAAlB,EAAgCC,GAAhC,EAA6C;EAC3C,IAAMC,MAAAA,GAASC,MAAAA,CAAOC,KAAPD,CAAaH,IAAAA,CAAKK,MAAlBF,CAAf;EACA,KAAK,IAAIG,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAIN,IAAAA,CAAKK,MAAzB,EAAiCC,CAAAA,EAAjC,EAAsC;IACpCJ,MAAAA,CAAOI,CAAPJ,CAAAA,GAAYF,IAAAA,CAAKM,CAALN,CAAAA,GAAUC,GAAAA,CAAIK,CAAAA,GAAIL,GAAAA,CAAII,MAAZJ,CAAtBC;EACD;EACD,OAAOA,MAAP;AACD;;AAED;AACA,IAAMK,SAAAA,GAAY,SAAZA,SAAY,CAACC,MAAD,EAAA;EAAA,OAChBA,MAAAA,CACGC,OADHD,CACW,KADXA,EACkB,GADlBA,CAAAA,CAEGC,OAFHD,CAEW,KAFXA,EAEkB,GAFlBA,CAAAA,CAGGC,OAHHD,CAGW,KAHXA,EAGkB,EAHlBA,CADgB;AAAA,CAAlB;;AAMA;AACA,IAAME,QAAAA,GAAW,SAAXA,QAAW,CAACF,MAAD,EAAA;EAAA,OACfA,MAAAA,CAAOC,OAAPD,CAAe,IAAfA,EAAqB,GAArBA,CAAAA,CAA0BC,OAA1BD,CAAkC,IAAlCA,EAAwC,GAAxCA,CAAAA,GACA,IAAA,CAAKG,SAAL,CAAe,CAAf,EAAmB,CAAA,GAAIH,MAAAA,CAAOH,MAAZ,GAAsB,CAAxC,CAFe;AAAA,CAAjB;AAIA,SAASO,eAAT,CACEZ,IADF,EAEEa,aAFF,EAGEC,KAHF,EAIEC,WAJF,EAKmB;EACjB,IAAMC,SAAAA,GAAYjB,QAAAA,CAASC,IAATD,EAAegB,WAAfhB,CAAlB;EACA,IAAMkB,SAAAA,GAAYd,MAAAA,CAAOe,IAAPf,CAChB,kEADgBA,EAEhB,KAFgBA,CAAlB;EAIA,IAAMgB,WAAAA,GAAc;IAClBC,OAAAA,EAAS,QADS;IAElBJ,SAAAA,EAAWT,SAAAA,CAAUS,SAAAA,CAAUK,QAAVL,CAAmB,QAAnBA,CAAVT,CAFO;IAGlBU,SAAAA,EAAWV,SAAAA,CAAUU,SAAAA,CAAUI,QAAVJ,CAAmB,QAAnBA,CAAVV,CAHO;IAIlBe,KAAAA,EAAOC,QAAAA,CAASC;EAJE,CAApB;EAMA,IAAIV,KAAJ,EAAW;IACTA,KAAAA,CAAM,KAAA,GAAQd,IAAAA,CAAKqB,QAALrB,CAAc,KAAdA,CAAdc,CAAAA;EACD;EACD,OAAO,CAAA,CAAA,EAAA,OAAA,CAAA,IAAA,EAAKK,WAAL,EAAkBN,aAAAA,GAAgB,IAAlC,CAAA,CAAwCY,IAAxC,CAA6C,UAAA,QAAA,EAAY;IAAA,IACtDC,aADsD,GACpCC,QADoC,CACtDD,aADsD;IAE9D,IAAI,OAAOA,aAAP,KAAyB,QAA7B,EAAuC;MACrC,IAAME,IAAAA,GAAOzB,MAAAA,CAAOe,IAAPf,CAAYO,QAAAA,CAASgB,aAAThB,CAAZP,EAAqC,QAArCA,CAAb;MACA,IAAMD,MAAAA,GAAS0B,IAAAA,CAAKC,KAALD,CAAW,CAAXA,CAAf;MACA,IAAId,KAAJ,EAAW;QACTA,KAAAA,CAAM,KAAA,GAAQZ,MAAAA,CAAOmB,QAAPnB,CAAgB,KAAhBA,CAAdY,CAAAA;MACD;MACD,OAAOZ,MAAP;IACD,CAPD,MAOO;MACL,MAAMyB,QAAN;IACD;EACF,CAZM,CAAP;AAaD;AAED,IAAIG,kBAAAA,GAAqB,EAAzB;AAEA,SAASC,cAAT,CAAA,EAA0B;EACxBD,kBAAAA,CAAmBE,OAAnBF,CAA2B,UAAA,CAAA,EAAA;IAAA,OAAKG,CAAAA,CAAEC,IAAFD,CAAO,YAAPA,CAAL;EAAA,CAA3BH,CAAAA;EACAA,kBAAAA,GAAqB,EAArBA;AACD;AAED,SAASK,iBAAT,CAA2BC,QAA3B,EAAqC;EACnC,OAAOA,QAAAA,CAASC,QAATD,CAAkBE,IAAlBF,KAA2B,CAAlC;AACD;;AAED;;;;;;;;IAOqBG,Y;;;;IAkCnB;;;;2GAGkBa,C;YAAMC,Y,uEAAwB,I;;;;;iDA+BvC,IAAId,YAAJ,E;;;;;;;;;;;;;;IAjET;;;EAoEA,SAAA,YAAA,CAAA,EAAc;IAAA,CAAA,CAAA,EAAA,gBAAA,CAAA,OAAA,EAAA,IAAA,EAAA,YAAA,CAAA;IAAA,IAAA,KAAA,GAAA,CAAA,CAAA,EAAA,2BAAA,CAAA,OAAA,EAAA,IAAA,EAAA,CAAA,YAAA,CAAA,SAAA,IAAA,CAAA,CAAA,EAAA,gBAAA,CAAA,OAAA,EAAA,YAAA,CAAA,EAAA,IAAA,CAAA,IAAA,CAAA,CAAA;IAEZT,kBAAAA,CAAmBwB,IAAnBxB,CAAAA,KAAAA,CAAAA;IAFY,OAAA,KAAA;EAGb;;;;6GAEc9B,I;;;;;;;;uBAEEY,eAAAA,CACXZ,IADWY,EAEX,IAAA,CAAK2C,eAFM3C,EAGX,IAAA,CAAKE,KAHMF,EAIX,IAAA,CAAKG,WAJMH,C;;;;;;gBAOP4C,U,GAAa,CAAA,CAAA,EAAA,QAAA,CAAA,OAAA,EAAO,SAAA,CAAA,EAAA,CAAEnB,QAAT,CAAA,KAAsB,Q;qBACrCmB,U;;;;gBACF,IAAIrB,iBAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAJ,EAA0B;kBACxBJ,cAAAA,EAAAA;gBACD;gBACD;sBACMrC,qBAAAA,CAAAA,SAAAA,CAAAA,EAAAA,EAEJ,yCAAA,GAA4C,SAAA,CAAA,EAAA,CAAE2C,QAAF,CAAWU,IAFnDrD,EAGJ,MAAA,GAAS,SAAA,CAAA,EAAA,CAAE2C,QAAF,CAAWC,IAHhB5C,C;;;;;;;;;;;;;;;;;mCAWGqB,W,EAAqB;MAClC,IAAA,CAAKA,WAAL,GAAmBZ,MAAAA,CAAOe,IAAPf,CAAYY,WAAZZ,EAAyB,OAAzBA,CAAnB;IACD;;;4BAEsB;MACrB,IAAMG,CAAAA,GAAIwB,kBAAAA,CAAmB2B,OAAnB3B,CAA2B,IAA3BA,CAAV;MACA,IAAIxB,CAAAA,KAAM,CAAC,CAAX,EAAc;QACZ,MAAM,IAAIoD,KAAJ,CAAU,4BAAV,CAAN;MACD;MACD5B,kBAAAA,CAAmB6B,MAAnB7B,CAA0BxB,CAA1BwB,EAA6B,CAA7BA,CAAAA;MACA,OAAO,SAAA,CAAA,OAAA,CAAQ8B,OAAR,EAAP;IACD;;;;AAjHkBrB,Y,CACZC,W;AADYD,Y,CAIZE,I,GAAO,YAAA;EAAA,OACZ,CAAA,CAAA,EAAA,OAAA,CAAA,WAAA,GAAA,CAAchB,IAAd,CAAmB,UAAA,SAAA,EAAA;IAAA,OAAciB,SAAAA,GAAY,CAAC,IAAD,CAAZA,GAAqB,EAAnC;EAAA,CAAnB,CADY;AAAA,C;AAJKH,Y,CAOZI,M,GAAS,UAACC,QAAD,EAAiB;EAC/B,IAAIC,YAAAA,GAAe,KAAnB;EACA,CAAA,CAAA,EAAA,OAAA,CAAA,WAAA,GAAA,CAAcpB,IAAd,CAAmB,UAAA,SAAA,EAAa;IAC9B,IAAIoB,YAAJ,EAAkB;IAClB,IAAIH,SAAJ,EAAe;MACbE,QAAAA,CAASE,IAATF,CAAc;QAAEG,IAAAA,EAAM,KAAR;QAAeC,UAAAA,EAAf;MAAA,CAAdJ,CAAAA;MACAA,QAAAA,CAASK,QAATL,EAAAA;IACD,CAHD,MAGO;MACLA,QAAAA,CAASM,KAATN,CACE,IAAA,YAAA,CAAA,cAAA,CACE,4CAAA,GACE,4DADF,GAEE,8CAHJ,EAIE,iBAJF,CADFA,CAAAA;IAQD;EACF,CAfD,CAAA;EAgBA,OAAO;IACLO,WAAAA,EAAa,SAAA,WAAA,CAAA,EAAM;MACjBN,YAAAA,GAAe,IAAfA;IACD;EAHI,CAAP;AAKD,C;kBA9BkBN,Y","sourcesContent":["//@flow\n\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport, { TransportError } from \"@ledgerhq/hw-transport\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu: Buffer, key: Buffer) {\n  const result = Buffer.alloc(apdu.length);\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nconst webSafe64 = (base64: string) =>\n  base64\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=+$/, \"\");\n\n// Convert from web-safe to normal, add trailing \"=\"s\nconst normal64 = (base64: string) =>\n  base64.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n  \"==\".substring(0, (3 * base64.length) % 4);\n\nfunction attemptExchange(\n  apdu: Buffer,\n  timeoutMillis: number,\n  debug: *,\n  scrambleKey: Buffer\n): Promise<Buffer> {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"hex\"\n  );\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  if (debug) {\n    debug(\"=> \" + apdu.toString(\"hex\"));\n  }\n  return sign(signRequest, timeoutMillis / 1000).then(response => {\n    const { signatureData } = response;\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      const result = data.slice(5);\n      if (debug) {\n        debug(\"<= \" + result.toString(\"hex\"));\n      }\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach(t => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nexport default class TransportU2F extends Transport<null> {\n  static isSupported = isSupported;\n\n  // this transport is not discoverable but we are going to guess if it is here with isSupported()\n  static list = (): * =>\n    isSupported().then(supported => (supported ? [null] : []));\n\n  static listen = (observer: *) => {\n    let unsubscribed = false;\n    isSupported().then(supported => {\n      if (unsubscribed) return;\n      if (supported) {\n        observer.next({ type: \"add\", descriptor: null });\n        observer.complete();\n      } else {\n        observer.error(\n          new TransportError(\n            \"U2F browser support is needed for Ledger. \" +\n              \"Please use Chrome, Opera or Firefox with a U2F extension. \" +\n              \"Also make sure you're on an HTTPS connection\",\n            \"U2FNotSupported\"\n          )\n        );\n      }\n    });\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      }\n    };\n  };\n\n  scrambleKey: Buffer;\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_: *, _openTimeout?: number = 5000): Promise<TransportU2F> {\n    /*try {\n      // This is not a valid exchange at all, but this allows to have a way to know if there is a device.\n      // in case it reaches the timeout, we will throw timeout error, in other case, we will return the U2FTransport.\n      await attemptExchange(\n        Buffer.alloc(0),\n        openTimeout,\n        false,\n        Buffer.alloc(1)\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n          throw wrapU2FTransportError(\n            e,\n            \"Ledger device unreachable.\\n\" +\n              \"Make sure the device is plugged, unlocked and with the correct application opened.\" +\n              (location && location.protocol !== \"https:\"\n                ? \"\\nYou are not running on HTTPS. U2F is likely to not work in unsecure protocol.\"\n                : \"\"),\n            \"Timeout\"\n          );\n        } else {\n          // we don't throw if it's another u2f error\n        }\n      } else {\n        throw e;\n      }\n    }*/\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    transportInstances.push(this);\n  }\n\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    try {\n      return await attemptExchange(\n        apdu,\n        this.exchangeTimeout,\n        this.debug,\n        this.scrambleKey\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        }\n        // the wrapping make error more usable and \"printable\" to the end user.\n        throw wrapU2FTransportError(\n          e,\n          \"Failed to sign with Ledger device: U2F \" + e.metaData.type,\n          \"U2F_\" + e.metaData.code\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  close(): Promise<void> {\n    const i = transportInstances.indexOf(this);\n    if (i === -1) {\n      throw new Error(\"invalid transport instance\");\n    }\n    transportInstances.splice(i, 1);\n    return Promise.resolve();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}