{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n    i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _ = require(\"lodash\");\nexports.classUtils = {\n  // This is useful for classes that have nested methods. Nested methods don't get bound out of the box.\n  bindAll: function bindAll(self, exclude, thisArg) {\n    if (exclude === void 0) {\n      exclude = ['contructor'];\n    }\n    var e_1, _a;\n    try {\n      for (var _b = __values(Object.getOwnPropertyNames(self)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        var val = self[key];\n        if (!_.includes(exclude, key)) {\n          if (_.isFunction(val)) {\n            self[key] = val.bind(thisArg || self);\n          } else if (_.isObject(val)) {\n            exports.classUtils.bindAll(val, exclude, self);\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return self;\n  }\n};","map":{"version":3,"sources":["../../src/class_utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,IAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAEa,OAAA,CAAA,UAAU,GAAG;EACtB;EACA,OAAO,EAAP,SAAA,QAAQ,IAAS,EAAE,OAAkC,EAAE,OAAa,EAAA;IAAjD,IAAA,OAAA,KAAA,KAAA,CAAA,EAAA;MAAA,OAAA,GAAA,CAAqB,YAAY,CAAC;IAAA;;;MACjD,KAAkB,IAAA,EAAA,GAAA,QAAA,CAAA,MAAM,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAA,EAAA,EAAA,GAAA,EAAA,CAAA,IAAA,EAAA,EAAA,CAAA,EAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,CAAA,IAAA,EAAA,EAAE;QAA/C,IAAM,GAAG,GAAA,EAAA,CAAA,KAAA;QACV,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QACrB,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,OAAO,EAAE,GAAG,CAAC,EAAE;UAC3B,IAAI,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;YACnB,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC;WACxC,MAAM,IAAI,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YACxB,OAAA,CAAA,UAAU,CAAC,OAAO,CAAC,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC;UACzC;QACJ;MACJ;;;;;;;;;;;;IACD,OAAO,IAAI;EACf;CACH","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = require(\"lodash\");\nexports.classUtils = {\n    // This is useful for classes that have nested methods. Nested methods don't get bound out of the box.\n    bindAll: function (self, exclude, thisArg) {\n        if (exclude === void 0) { exclude = ['contructor']; }\n        var e_1, _a;\n        try {\n            for (var _b = __values(Object.getOwnPropertyNames(self)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var key = _c.value;\n                var val = self[key];\n                if (!_.includes(exclude, key)) {\n                    if (_.isFunction(val)) {\n                        self[key] = val.bind(thisArg || self);\n                    }\n                    else if (_.isObject(val)) {\n                        exports.classUtils.bindAll(val, exclude, self);\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return self;\n    },\n};\n//# sourceMappingURL=class_utils.js.map"]},"metadata":{},"sourceType":"script"}