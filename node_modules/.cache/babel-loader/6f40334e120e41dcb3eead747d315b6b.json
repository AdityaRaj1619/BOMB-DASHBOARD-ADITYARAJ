{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar configured_bignumber_1 = require(\"../../configured_bignumber\");\nvar constants_1 = require(\"../utils/constants\");\nfunction sanityCheckBigNumberRange(value_, minValue, maxValue) {\n  var value = new configured_bignumber_1.BigNumber(value_, 10);\n  if (value.isGreaterThan(maxValue)) {\n    throw new Error(\"Tried to assign value of \" + value + \", which exceeds max value of \" + maxValue);\n  } else if (value.isLessThan(minValue)) {\n    throw new Error(\"Tried to assign value of \" + value + \", which exceeds min value of \" + minValue);\n  } else if (value.isNaN()) {\n    throw new Error(\"Tried to assign NaN value\");\n  }\n}\nfunction bigNumberToPaddedBuffer(value) {\n  var valueHex = \"0x\" + value.toString(constants_1.constants.HEX_BASE);\n  var valueBuf = ethUtil.toBuffer(valueHex);\n  var valueBufPadded = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n  return valueBufPadded;\n}\n/**\n * Takes a numeric value and returns its ABI-encoded value\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\nfunction encodeNumericValue(value_) {\n  var value = new configured_bignumber_1.BigNumber(value_, 10);\n  // Case 1/2: value is non-negative\n  if (value.isGreaterThanOrEqualTo(0)) {\n    var encodedPositiveValue = bigNumberToPaddedBuffer(value);\n    return encodedPositiveValue;\n  }\n  // Case 2/2: Value is negative\n  // Use two's-complement to encode the value\n  // Step 1/3: Convert negative value to positive binary string\n  var valueBin = value.times(-1).toString(constants_1.constants.BIN_BASE);\n  // Step 2/3: Invert binary value\n  var invertedValueBin = '1'.repeat(constants_1.constants.EVM_WORD_WIDTH_IN_BITS - valueBin.length);\n  _.each(valueBin, function (bit) {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n  var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE);\n  // Step 3/3: Add 1 to inverted value\n  var negativeValue = invertedValue.plus(1);\n  var encodedValue = bigNumberToPaddedBuffer(negativeValue);\n  return encodedValue;\n}\nexports.encodeNumericValue = encodeNumericValue;\n/**\n * Takes a numeric value and returns its ABI-encoded value.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\nfunction safeEncodeNumericValue(value, minValue, maxValue) {\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  var encodedValue = encodeNumericValue(value);\n  return encodedValue;\n}\nexports.safeEncodeNumericValue = safeEncodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\nfunction decodeNumericValue(encodedValue, minValue) {\n  var valueHex = ethUtil.bufferToHex(encodedValue);\n  // Case 1/3: value is definitely non-negative because of numeric boundaries\n  var value = new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n  if (!minValue.isLessThan(0)) {\n    return value;\n  }\n  // Case 2/3: value is non-negative because there is no leading 1 (encoded as two's-complement)\n  var valueBin = value.toString(constants_1.constants.BIN_BASE);\n  var isValueNegative = valueBin.length === constants_1.constants.EVM_WORD_WIDTH_IN_BITS && _.startsWith(valueBin[0], '1');\n  if (!isValueNegative) {\n    return value;\n  }\n  // Case 3/3: value is negative\n  // Step 1/3: Invert b inary value\n  var invertedValueBin = '';\n  _.each(valueBin, function (bit) {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n  var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE);\n  // Step 2/3: Add 1 to inverted value\n  // The result is the two's-complement representation of the input value.\n  var positiveValue = invertedValue.plus(1);\n  // Step 3/3: Invert positive value to get the negative value\n  var negativeValue = positiveValue.times(-1);\n  return negativeValue;\n}\nexports.decodeNumericValue = decodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\nfunction safeDecodeNumericValue(encodedValue, minValue, maxValue) {\n  var value = decodeNumericValue(encodedValue, minValue);\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  return value;\n}\nexports.safeDecodeNumericValue = safeDecodeNumericValue;","map":{"version":3,"sources":["../../../../src/abi_encoder/utils/math.ts"],"names":[],"mappings":";;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AACA,IAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAEA,IAAA,sBAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AAEA,SAAS,yBAAyB,CAC9B,MAAmC,EACnC,QAAmB,EACnB,QAAmB,EAAA;EAEnB,IAAM,KAAK,GAAG,IAAI,sBAAA,CAAA,SAAS,CAAC,MAAM,EAAE,EAAE,CAAC;EACvC,IAAI,KAAK,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE;IAC/B,MAAM,IAAI,KAAK,CAAC,2BAAA,GAA4B,KAAK,GAAA,+BAAA,GAAgC,QAAU,CAAC;GAC/F,MAAM,IAAI,KAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;IACnC,MAAM,IAAI,KAAK,CAAC,2BAAA,GAA4B,KAAK,GAAA,+BAAA,GAAgC,QAAU,CAAC;GAC/F,MAAM,IAAI,KAAK,CAAC,KAAK,EAAE,EAAE;IACtB,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC;EAC/C;AACL;AACA,SAAS,uBAAuB,CAAC,KAAgB,EAAA;EAC7C,IAAM,QAAQ,GAAG,IAAA,GAAK,KAAK,CAAC,QAAQ,CAAC,WAAA,CAAA,SAAS,CAAC,QAAQ,CAAG;EAC1D,IAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC;EAC3C,IAAM,cAAc,GAAG,OAAO,CAAC,aAAa,CAAC,QAAQ,EAAE,WAAA,CAAA,SAAS,CAAC,uBAAuB,CAAC;EACzF,OAAO,cAAc;AACzB;AACA;;;;AAIG;AACH,SAAgB,kBAAkB,CAAC,MAAmC,EAAA;EAClE,IAAM,KAAK,GAAG,IAAI,sBAAA,CAAA,SAAS,CAAC,MAAM,EAAE,EAAE,CAAC;EACvC;EACA,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC,CAAC,EAAE;IACjC,IAAM,oBAAoB,GAAG,uBAAuB,CAAC,KAAK,CAAC;IAC3D,OAAO,oBAAoB;EAC9B;EACD;EACA;EACA;EACA,IAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,WAAA,CAAA,SAAS,CAAC,QAAQ,CAAC;EAC7D;EACA,IAAI,gBAAgB,GAAG,GAAG,CAAC,MAAM,CAAC,WAAA,CAAA,SAAS,CAAC,sBAAsB,GAAG,QAAQ,CAAC,MAAM,CAAC;EACrF,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAC,GAAW,EAAA;IACzB,gBAAgB,IAAI,GAAG,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;EAC/C,CAAC,CAAC;EACF,IAAM,aAAa,GAAG,IAAI,sBAAA,CAAA,SAAS,CAAC,gBAAgB,EAAE,WAAA,CAAA,SAAS,CAAC,QAAQ,CAAC;EACzE;EACA,IAAM,aAAa,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;EAC3C,IAAM,YAAY,GAAG,uBAAuB,CAAC,aAAa,CAAC;EAC3D,OAAO,YAAY;AACvB;AArBA,OAAA,CAAA,kBAAA,GAAA,kBAAA;AAsBA;;;;;AAKG;AACH,SAAgB,sBAAsB,CAClC,KAAkC,EAClC,QAAmB,EACnB,QAAmB,EAAA;EAEnB,yBAAyB,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ,CAAC;EACpD,IAAM,YAAY,GAAG,kBAAkB,CAAC,KAAK,CAAC;EAC9C,OAAO,YAAY;AACvB;AARA,OAAA,CAAA,sBAAA,GAAA,sBAAA;AASA;;;;;AAKG;AACH,SAAgB,kBAAkB,CAAC,YAAoB,EAAE,QAAmB,EAAA;EACxE,IAAM,QAAQ,GAAG,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC;EAClD;EACA,IAAM,KAAK,GAAG,IAAI,sBAAA,CAAA,SAAS,CAAC,QAAQ,EAAE,WAAA,CAAA,SAAS,CAAC,QAAQ,CAAC;EACzD,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE;IACzB,OAAO,KAAK;EACf;EACD;EACA,IAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,WAAA,CAAA,SAAS,CAAC,QAAQ,CAAC;EACnD,IAAM,eAAe,GAAG,QAAQ,CAAC,MAAM,KAAK,WAAA,CAAA,SAAS,CAAC,sBAAsB,IAAI,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;EAC9G,IAAI,CAAC,eAAe,EAAE;IAClB,OAAO,KAAK;EACf;EACD;EACA;EACA,IAAI,gBAAgB,GAAG,EAAE;EACzB,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAC,GAAW,EAAA;IACzB,gBAAgB,IAAI,GAAG,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;EAC/C,CAAC,CAAC;EACF,IAAM,aAAa,GAAG,IAAI,sBAAA,CAAA,SAAS,CAAC,gBAAgB,EAAE,WAAA,CAAA,SAAS,CAAC,QAAQ,CAAC;EACzE;EACA;EACA,IAAM,aAAa,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;EAC3C;EACA,IAAM,aAAa,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7C,OAAO,aAAa;AACxB;AA1BA,OAAA,CAAA,kBAAA,GAAA,kBAAA;AA2BA;;;;;;AAMG;AACH,SAAgB,sBAAsB,CAAC,YAAoB,EAAE,QAAmB,EAAE,QAAmB,EAAA;EACjG,IAAM,KAAK,GAAG,kBAAkB,CAAC,YAAY,EAAE,QAAQ,CAAC;EACxD,yBAAyB,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ,CAAC;EACpD,OAAO,KAAK;AAChB;AAJA,OAAA,CAAA,sBAAA,GAAA,sBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar configured_bignumber_1 = require(\"../../configured_bignumber\");\nvar constants_1 = require(\"../utils/constants\");\nfunction sanityCheckBigNumberRange(value_, minValue, maxValue) {\n    var value = new configured_bignumber_1.BigNumber(value_, 10);\n    if (value.isGreaterThan(maxValue)) {\n        throw new Error(\"Tried to assign value of \" + value + \", which exceeds max value of \" + maxValue);\n    }\n    else if (value.isLessThan(minValue)) {\n        throw new Error(\"Tried to assign value of \" + value + \", which exceeds min value of \" + minValue);\n    }\n    else if (value.isNaN()) {\n        throw new Error(\"Tried to assign NaN value\");\n    }\n}\nfunction bigNumberToPaddedBuffer(value) {\n    var valueHex = \"0x\" + value.toString(constants_1.constants.HEX_BASE);\n    var valueBuf = ethUtil.toBuffer(valueHex);\n    var valueBufPadded = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n    return valueBufPadded;\n}\n/**\n * Takes a numeric value and returns its ABI-encoded value\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\nfunction encodeNumericValue(value_) {\n    var value = new configured_bignumber_1.BigNumber(value_, 10);\n    // Case 1/2: value is non-negative\n    if (value.isGreaterThanOrEqualTo(0)) {\n        var encodedPositiveValue = bigNumberToPaddedBuffer(value);\n        return encodedPositiveValue;\n    }\n    // Case 2/2: Value is negative\n    // Use two's-complement to encode the value\n    // Step 1/3: Convert negative value to positive binary string\n    var valueBin = value.times(-1).toString(constants_1.constants.BIN_BASE);\n    // Step 2/3: Invert binary value\n    var invertedValueBin = '1'.repeat(constants_1.constants.EVM_WORD_WIDTH_IN_BITS - valueBin.length);\n    _.each(valueBin, function (bit) {\n        invertedValueBin += bit === '1' ? '0' : '1';\n    });\n    var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE);\n    // Step 3/3: Add 1 to inverted value\n    var negativeValue = invertedValue.plus(1);\n    var encodedValue = bigNumberToPaddedBuffer(negativeValue);\n    return encodedValue;\n}\nexports.encodeNumericValue = encodeNumericValue;\n/**\n * Takes a numeric value and returns its ABI-encoded value.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\nfunction safeEncodeNumericValue(value, minValue, maxValue) {\n    sanityCheckBigNumberRange(value, minValue, maxValue);\n    var encodedValue = encodeNumericValue(value);\n    return encodedValue;\n}\nexports.safeEncodeNumericValue = safeEncodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\nfunction decodeNumericValue(encodedValue, minValue) {\n    var valueHex = ethUtil.bufferToHex(encodedValue);\n    // Case 1/3: value is definitely non-negative because of numeric boundaries\n    var value = new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n    if (!minValue.isLessThan(0)) {\n        return value;\n    }\n    // Case 2/3: value is non-negative because there is no leading 1 (encoded as two's-complement)\n    var valueBin = value.toString(constants_1.constants.BIN_BASE);\n    var isValueNegative = valueBin.length === constants_1.constants.EVM_WORD_WIDTH_IN_BITS && _.startsWith(valueBin[0], '1');\n    if (!isValueNegative) {\n        return value;\n    }\n    // Case 3/3: value is negative\n    // Step 1/3: Invert b inary value\n    var invertedValueBin = '';\n    _.each(valueBin, function (bit) {\n        invertedValueBin += bit === '1' ? '0' : '1';\n    });\n    var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE);\n    // Step 2/3: Add 1 to inverted value\n    // The result is the two's-complement representation of the input value.\n    var positiveValue = invertedValue.plus(1);\n    // Step 3/3: Invert positive value to get the negative value\n    var negativeValue = positiveValue.times(-1);\n    return negativeValue;\n}\nexports.decodeNumericValue = decodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\nfunction safeDecodeNumericValue(encodedValue, minValue, maxValue) {\n    var value = decodeNumericValue(encodedValue, minValue);\n    sanityCheckBigNumberRange(value, minValue, maxValue);\n    return value;\n}\nexports.safeDecodeNumericValue = safeDecodeNumericValue;\n//# sourceMappingURL=math.js.map"]},"metadata":{},"sourceType":"script"}