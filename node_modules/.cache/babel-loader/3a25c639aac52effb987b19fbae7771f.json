{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}(); /********************************************************************************\n      *   Ledger Node JS API\n      *   (c) 2016-2017 Ledger\n      *\n      *  Licensed under the Apache License, Version 2.0 (the \"License\");\n      *  you may not use this file except in compliance with the License.\n      *  You may obtain a copy of the License at\n      *\n      *      http://www.apache.org/licenses/LICENSE-2.0\n      *\n      *  Unless required by applicable law or agreed to in writing, software\n      *  distributed under the License is distributed on an \"AS IS\" BASIS,\n      *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n      *  See the License for the specific language governing permissions and\n      *  limitations under the License.\n      ********************************************************************************/\n\n// FIXME drop:\n\nvar _utils = require(\"./utils\");\nvar _errors = require(\"@ledgerhq/errors\");\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar remapTransactionRelatedErrors = function remapTransactionRelatedErrors(e) {\n  if (e && e.statusCode === 0x6a80) {\n    return new _errors.EthAppPleaseEnableContractData(\"Please enable Contract data on the Ethereum app Settings\");\n  }\n  return e;\n};\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\n\nvar Eth = function () {\n  function Eth(transport) {\n    var scrambleKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"w0w\";\n    _classCallCheck(this, Eth);\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"provideERC20TokenInformation\", \"signTransaction\", \"signPersonalMessage\", \"getAppConfiguration\"], scrambleKey);\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n\n  _createClass(Eth, [{\n    key: \"getAddress\",\n    value: function getAddress(path, boolDisplay, boolChaincode) {\n      var paths = (0, _utils.splitPath)(path);\n      var buffer = new Buffer(1 + paths.length * 4);\n      buffer[0] = paths.length;\n      paths.forEach(function (element, index) {\n        buffer.writeUInt32BE(element, 1 + 4 * index);\n      });\n      return this.transport.send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer).then(function (response) {\n        var result = {};\n        var publicKeyLength = response[0];\n        var addressLength = response[1 + publicKeyLength];\n        result.publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n        result.address = \"0x\" + response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString(\"ascii\");\n        if (boolChaincode) {\n          result.chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString(\"hex\");\n        }\n        return result;\n      });\n    }\n\n    /**\n     * This commands provides a trusted description of an ERC 20 token\n     * to associate a contract address with a ticker and number of decimals.\n     *\n     * It shall be run immediately before performing a transaction involving a contract\n     * calling this contract address to display the proper token information to the user if necessary.\n     *\n     * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n     *\n     * @example\n     * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n     * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n     * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n     * const signed = await appEth.signTransaction(path, rawTxHex)\n     */\n  }, {\n    key: \"provideERC20TokenInformation\",\n    value: function provideERC20TokenInformation(_ref) {\n      var data = _ref.data;\n      return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(function () {\n        return true;\n      }, function (e) {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n          // we return a flag to know if the call was effective or not\n          return false;\n        }\n        throw e;\n      });\n    }\n\n    /**\n     * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n     * @example\n     eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n     */\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(path, rawTxHex) {\n      var _this = this;\n      var paths = (0, _utils.splitPath)(path);\n      var offset = 0;\n      var rawTx = new Buffer(rawTxHex, \"hex\");\n      var toSend = [];\n      var response = void 0;\n      var _loop = function _loop() {\n        var maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n        var chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;\n        var buffer = new Buffer(offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize);\n        if (offset === 0) {\n          buffer[0] = paths.length;\n          paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n          });\n          rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n        } else {\n          rawTx.copy(buffer, 0, offset, offset + chunkSize);\n        }\n        toSend.push(buffer);\n        offset += chunkSize;\n      };\n      while (offset !== rawTx.length) {\n        _loop();\n      }\n      return (0, _utils.foreach)(toSend, function (data, i) {\n        return _this.transport.send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data).then(function (apduResponse) {\n          response = apduResponse;\n        });\n      }).then(function () {\n        var v = response.slice(0, 1).toString(\"hex\");\n        var r = response.slice(1, 1 + 32).toString(\"hex\");\n        var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return {\n          v: v,\n          r: r,\n          s: s\n        };\n      }, function (e) {\n        throw remapTransactionRelatedErrors(e);\n      });\n    }\n\n    /**\n     */\n  }, {\n    key: \"getAppConfiguration\",\n    value: function getAppConfiguration() {\n      return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(function (response) {\n        var result = {};\n        result.arbitraryDataEnabled = response[0] & 0x01;\n        result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n        return result;\n      });\n    }\n\n    /**\n    * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n    * @example\n    eth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n    var v = result['v'] - 27;\n    v = v.toString(16);\n    if (v.length < 2) {\n      v = \"0\" + v;\n    }\n    console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n    })\n     */\n  }, {\n    key: \"signPersonalMessage\",\n    value: function signPersonalMessage(path, messageHex) {\n      var _this2 = this;\n      var paths = (0, _utils.splitPath)(path);\n      var offset = 0;\n      var message = new Buffer(messageHex, \"hex\");\n      var toSend = [];\n      var response = void 0;\n      var _loop2 = function _loop2() {\n        var maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n        var chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n        var buffer = new Buffer(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);\n        if (offset === 0) {\n          buffer[0] = paths.length;\n          paths.forEach(function (element, index) {\n            buffer.writeUInt32BE(element, 1 + 4 * index);\n          });\n          buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n          message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n        } else {\n          message.copy(buffer, 0, offset, offset + chunkSize);\n        }\n        toSend.push(buffer);\n        offset += chunkSize;\n      };\n      while (offset !== message.length) {\n        _loop2();\n      }\n      return (0, _utils.foreach)(toSend, function (data, i) {\n        return _this2.transport.send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data).then(function (apduResponse) {\n          response = apduResponse;\n        });\n      }).then(function () {\n        var v = response[0];\n        var r = response.slice(1, 1 + 32).toString(\"hex\");\n        var s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return {\n          v: v,\n          r: r,\n          s: s\n        };\n      });\n    }\n  }]);\n  return Eth;\n}();\nexports.default = Eth;","map":{"version":3,"sources":["../src/Eth.js"],"names":["remapTransactionRelatedErrors","e","statusCode","Eth","transport","scrambleKey","decorateAppAPIMethods","path","boolDisplay","boolChaincode","paths","buffer","Buffer","length","forEach","element","index","writeUInt32BE","send","then","result","publicKeyLength","response","addressLength","publicKey","slice","toString","address","chainCode","data","rawTxHex","offset","rawTx","toSend","maxChunkSize","chunkSize","copy","push","i","apduResponse","v","r","s","arbitraryDataEnabled","version","messageHex","message"],"mappings":"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","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport type Transport from \"@ledgerhq/hw-transport\";\n\nconst remapTransactionRelatedErrors = e => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\n      \"Please enable Contract data on the Ethereum app Settings\"\n    );\n  }\n  return e;\n};\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\nexport default class Eth {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"w0w\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"provideERC20TokenInformation\",\n        \"signTransaction\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\"\n      ],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChaincode?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string\n  }> {\n    let paths = splitPath(path);\n    let buffer = new Buffer(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay ? 0x01 : 0x00,\n        boolChaincode ? 0x01 : 0x00,\n        buffer\n      )\n      .then(response => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\");\n        result.address =\n          \"0x\" +\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\");\n        if (boolChaincode) {\n          result.chainCode = response\n            .slice(\n              1 + publicKeyLength + 1 + addressLength,\n              1 + publicKeyLength + 1 + addressLength + 32\n            )\n            .toString(\"hex\");\n        }\n        return result;\n      });\n  }\n\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n  provideERC20TokenInformation({ data }: { data: Buffer }): Promise<boolean> {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(\n      () => true,\n      e => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n          // we return a flag to know if the call was effective or not\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = new Buffer(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      let buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(\n      () => {\n        const v = response.slice(0, 1).toString(\"hex\");\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      },\n      e => {\n        throw remapTransactionRelatedErrors(e);\n      }\n    );\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    version: string\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\neth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signPersonalMessage(\n    path: string,\n    messageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = new Buffer(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      let buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return { v, r, s };\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}